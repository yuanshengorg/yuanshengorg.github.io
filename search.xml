<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo折腾记录更新</title>
      <link href="/2019/12/18/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/12/18/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>   更新中 …</p></blockquote><hr><h2 id="增加域名，备份git仓库"><a href="#增加域名，备份git仓库" class="headerlink" title="增加域名，备份git仓库"></a>增加域名，备份git仓库</h2><blockquote><p>  20191218</p></blockquote><ul><li>绑定独立域名： <code>halfbamboo.com</code> ；</li><li>新修改的文件备份到 <code>git</code> 仓库： <a href="https://github.com/yuanshengorg/myHexoBlog" target="_blank" rel="noopener">myHexoBlog</a>；</li></ul><hr><h2 id="修改主题及压缩css-js"><a href="#修改主题及压缩css-js" class="headerlink" title="修改主题及压缩css/js"></a>修改主题及压缩css/js</h2><blockquote><p>  20191218</p></blockquote><ul><li>修改博客主题的CSS样式；</li><li>增加 pulyfile.js 压缩 html/css/js；（放弃）</li><li>增加 hexo-neat 插件压缩 css/js；（html未能压缩）</li></ul><p><img src="http://mdimg.95408.com/201912182118_637.png?imageView2/2/w/1200/h/1200" alt="修改后的3-hexo主题"></p><hr><h2 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h2><blockquote><p>  20191217</p></blockquote><ul><li>本地创建hexo博客：<code>d:/hexo</code> ；</li><li>更换主题：<code>hexo-theme-3-hexo</code> ；</li><li>上传至 <code>github.com</code> ： <a href="https://github.com/yuanshengorg/yuanshengorg.github.io" target="_blank" rel="noopener">yuanshengorg.github.io</a> ；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法CSS表现测试</title>
      <link href="/2019/12/18/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/18/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>下载： <code>$ npm install hexo-cli -g</code> 。</p><p>列表： <code>1.</code></p><ol><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ol><p>列表： <code>-</code></p><ul><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ul><p>链接：<code>[]()</code></p><p><a href="http://www.halfbamboo.com" target="_blank" rel="noopener">半根竹子的官方网站</a></p><p>块引用： <code>&gt;</code></p><blockquote><p>  回归20年，背靠<code>祖国</code>、面向世界的澳门特区迎来一次次发展机遇；脚踏实地、开拓进取的澳门创业者站上更为广阔的发展舞台。</p></blockquote><p>水平分割线：<code>------</code></p><hr><p>代码块： </p><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});   // 注释</code></pre><p>图片：</p><p><img src="http://mdimg.95408.com/20191218121717.png" alt="图片说明文字"></p><p>表格：</p><table><thead><tr><th>标题</th><th>标题2</th><th>标题2</th></tr></thead><tbody><tr><td>一</td><td>二</td><td>三</td></tr><tr><td>hello,hello,hello</td><td>python,python,python</td><td>js,js,js</td></tr><tr><td>css,css,css</td><td>html,html,html</td><td>node,node,node</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 vs code 命令快捷键</title>
      <link href="/2019/12/17/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/"/>
      <url>/2019/12/17/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、光标移动到行尾-行首"><a href="#1、光标移动到行尾-行首" class="headerlink" title="1、光标移动到行尾/行首"></a>1、光标移动到行尾/行首</h3><p>当软件自动补全时，我们常常会需要将光标移动到行尾，可以使用 <code>end</code> 键，或者自定义一个更方便的键，比如：<code>Ctrl + ;</code> 。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>END</td><td>cursorEnd   光标移动到行尾</td><td>/</td></tr><tr><td>HOME</td><td>cursorHome   光标移动到行首</td><td>Ctrl + Shift + ;</td></tr><tr><td>无</td><td>cursorLineEnd   光标移动到行尾</td><td>Ctrl + ;</td></tr><tr><td>无</td><td>cursorLineStart   光标移动到行首</td><td>/</td></tr></tbody></table><h3 id="2、选择当前单词"><a href="#2、选择当前单词" class="headerlink" title="2、选择当前单词"></a>2、选择当前单词</h3><p>连续按展开选择，第一次选中当前单词，第二次选择当前行；继续选择当前块；只按一次的话，就是选择当前单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Shift + Alt + Right</td><td>展开选择</td><td>Alt + I</td></tr><tr><td>Shift + Alt + Left</td><td>收起选择</td><td>Alt + O</td></tr></tbody></table><h3 id="3、光标移动到下-上一个单词"><a href="#3、光标移动到下-上一个单词" class="headerlink" title="3、光标移动到下/上一个单词"></a>3、光标移动到下/上一个单词</h3><p>我们需要将光标跳转到下一个单词或者上一个单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Ctrl + Right</td><td>cursorWordEndRight   光标移动到右边单词结尾</td><td>Alt + ;</td></tr><tr><td>Ctrl + Left</td><td>cursorWordStartLeft   光标移动到左边单词开关</td><td>Alt + L</td></tr></tbody></table><h3 id="4、不使用方向键上下移动"><a href="#4、不使用方向键上下移动" class="headerlink" title="4、不使用方向键上下移动"></a>4、不使用方向键上下移动</h3><p>我们要将光标上下移动时，使用上、下按键也是不方便，所以 vim 中使用了 <code>h j k l</code> ；</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>DOWN</td><td>cursorDown   向下移动光标</td><td>Alt + J</td></tr><tr><td>UP</td><td>cursorUp   向上移动光标</td><td>Alt + K</td></tr><tr><td>LEFT</td><td>cursorLeft   向左移动光标</td><td>/</td></tr><tr><td>RIGTH</td><td>cursorRight   向右移动光标</td><td>/</td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912111130_513.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code>![1575993392487](D:\Markdown\css-js-blog\assets\1575993392487.png)</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（一）</title>
      <link href="/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1、数组是一种特殊的变量，它能够一次存放一个以上的值。</p><p>2、数组是一种特殊类型的对象，在 JavaScript 中对数组使用 typeof 运算符会返回 “object”。JavaScript 数组最好以数组来描述。</p><p>4、数组使用数字来访问其“元素”，对象使用名称来访问其“成员”。数组和对象的区别：数组使用数字索引、象使用命名索引。数组是特殊类型的对象，具有数字索引。</p><p><code>var person = [&quot;Bill&quot;, &quot;Gates&quot;, 62];</code> 使用： <code>person[0]</code> </p><p><code>var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:46};</code> 使用： <code>person.firstName</code> </p><p>5、如果希望元素名为字符串（文本）则应该使用对象、如果希望元素名为数字则应该使用数组。</p><p>6、可以在数组保存对象、函数、甚至是数组；</p><p><code>myArray[0] = Date.now;  myArray[1] = myFunction;  myArray[2] = myCars;</code> </p><h3 id="1、定义数组"><a href="#1、定义数组" class="headerlink" title="1、定义数组"></a>1、定义数组</h3><pre><code class="js">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 以逗号隔开；// 最后不要加逗号；// var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);// 尽量不要使用 new Array() ，执行效率更低；</code></pre><h3 id="2、-识别数组"><a href="#2、-识别数组" class="headerlink" title="2、 识别数组"></a>2、 识别数组</h3><pre><code class="js">typeof cars; // 返回 object// typeof 运算符返回 &quot;object&quot;，因为 JavaScript 数组属于对象。Array.isArray(cars); // 返回 true</code></pre><h3 id="3、访问数组元素"><a href="#3、访问数组元素" class="headerlink" title="3、访问数组元素"></a>3、访问数组元素</h3><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);console.log(cars[0]); // Saab</code></pre><h3 id="4、改变数组元素"><a href="#4、改变数组元素" class="headerlink" title="4、改变数组元素"></a>4、改变数组元素</h3><p>通过使用它们的索引号来访问、更改数组元素</p><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);cars[0] = &#39;abc&#39;console.log(cars[0]); // abc</code></pre><h3 id="5、访问完整数组"><a href="#5、访问完整数组" class="headerlink" title="5、访问完整数组"></a>5、访问完整数组</h3><pre><code class="js">var cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars; &lt;p id = &quot;demo&quot; &gt; &lt; /p&gt;//&lt;p id=&quot;demo&quot;&gt;Audi,BMW,porsche&lt;/p&gt;</code></pre><h2 id="数组属性方法"><a href="#数组属性方法" class="headerlink" title="数组属性方法"></a>数组属性方法</h2><h3 id="1、length-属性"><a href="#1、length-属性" class="headerlink" title="1、length 属性"></a>1、length 属性</h3><p>返回数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.length; // 4</code></pre><h3 id="2、length-访问最后一个元素"><a href="#2、length-访问最后一个元素" class="headerlink" title="2、length 访问最后一个元素"></a>2、length 访问最后一个元素</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var first = fruits[0]; // 访问第一个元素var last = fruits[fruits.length - 1]; // Mango// str.length 为长度4，减1表示是索引3（索引从0开始）</code></pre><h3 id="3、push-、length添加元素"><a href="#3、push-、length添加元素" class="headerlink" title="3、push()、length添加元素"></a>3、push()、length添加元素</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// str.length是数组长度，比索引大1（索引从0开始）// 等于在原来最大索引+1的位置添加元素</code></pre><h3 id="4、添加元素时的空位"><a href="#4、添加元素时的空位" class="headerlink" title="4、添加元素时的空位"></a>4、添加元素时的空位</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[6] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// Banana// Orange// Apple// Mango// undefined 添加最高索引的元素可在数组中创建未定义的“洞”：// undefined// Lemon</code></pre><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="1、toString-转为字符串"><a href="#1、toString-转为字符串" class="headerlink" title="1、toString() 转为字符串"></a>1、toString() 转为字符串</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.toString()); // Banana,Orange,Apple,Mangoconsole.log(fruits); // 也可以直接调用// 所有 JavaScript 对象都拥有 toString() 方法。</code></pre><h3 id="2、join-转字符串"><a href="#2、join-转字符串" class="headerlink" title="2、join() 转字符串"></a>2、join() 转字符串</h3><p>类似 toString()，但是您还可以规定分隔符</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.join(&#39;*&#39;)); // Banana*Orange*Apple*Mango</code></pre><h3 id="3、pop-删除最后元素"><a href="#3、pop-删除最后元素" class="headerlink" title="3、pop() 删除最后元素"></a>3、pop() 删除最后元素</h3><p>1、pop() 删除最后元素，返回被删除元素</p><p>2、push() 在最后增加元素，返回数组长度</p><p>3、shift() 删除开始元素，返回被删除元素</p><p>4、unshift() 在开始增加元素，返回数组长度</p><p>返回被删除的值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop()// console.log(fruits.pop()); // Mango// console.log(fruits); // Banana,Orange,Apple</code></pre><h3 id="4、push-在最后增加元素"><a href="#4、push-在最后增加元素" class="headerlink" title="4、push() 在最后增加元素"></a>4、push() 在最后增加元素</h3><p>返回新数组的长度值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var f = fruits.push(&#39;Kiwi&#39;);// console.log(f); // 5// console.log(fruits); // Banana Orange Apple Mango Kiwi</code></pre><h3 id="5、shift-删除第一个元素"><a href="#5、shift-删除第一个元素" class="headerlink" title="5、shift() 删除第一个元素"></a>5、shift() 删除第一个元素</h3><p>返回被“位移出”的字符串</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 返回 &quot;Banana&quot;</code></pre><h3 id="6、unshift-在最前面增加元素"><a href="#6、unshift-在最前面增加元素" class="headerlink" title="6、unshift() 在最前面增加元素"></a>6、unshift() 在最前面增加元素</h3><p>返回新数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 返回 5</code></pre><h3 id="7、delete-删除元素"><a href="#7、delete-删除元素" class="headerlink" title="7、delete 删除元素"></a>7、delete 删除元素</h3><p>使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // 把 fruits 中的首个元素改为 undefined</code></pre><h3 id="8、splice-向数组添加新项"><a href="#8、splice-向数组添加新项" class="headerlink" title="8、splice() 向数组添加新项"></a>8、splice() 向数组添加新项</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi,Apple,Mango</code></pre><p>第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>第二个参数（0）定义应删除多少元素。</p><p>其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>splice() 方法返回一个包含已删除项的数组：</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi// 已删除项： Apple,Mango</code></pre><h3 id="8、splice-删除元素"><a href="#8、splice-删除元素" class="headerlink" title="8、splice() 删除元素"></a>8、splice() 删除元素</h3><p>第一个参数（0）定义新元素应该被添加（接入）的位置。</p><p>第二个参数（1）定义应该删除多个元素。</p><p>其余参数被省略。没有新元素将被添加。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 Banana// 原数组： Banana,Orange,Apple,Mango// 新数组： Orange,Apple,Mangofruits.splice(1, 2); // Banana,Mango</code></pre><h3 id="9、concat-合并、连接数组"><a href="#9、concat-合并、连接数组" class="headerlink" title="9、concat() 合并、连接数组"></a>9、concat() 合并、连接数组</h3><p>concat() 方法不会更改现有数组。它总是返回一个新数组。</p><p>concat() 方法可以使用任意数量的数组参数：</p><p>concat() 方法也可以将值作为参数：</p><pre><code class="js">var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var arr2 = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var arr3 = [&quot;Robin&quot;, &quot;Morgan&quot;];arr1.concat(arr2); // 将arr1 与 arr2 连接在一起arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起arr1.concat([&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]); // 也可以将值作为参数</code></pre><h3 id="10、slice-裁剪新数组"><a href="#10、slice-裁剪新数组" class="headerlink" title="10、slice() 裁剪新数组"></a>10、slice() 裁剪新数组</h3><p>slice() 方法创建新数组。它不会从源数组中删除任何元素。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.slice(1); // Orange,Lemon,Apple,Mangofruits.slice(3); // Apple,Mango</code></pre><p>slice() 可接受两个参数，从开始参数选取元素，直到结束参数（不包括）为止。</p><p>第2个参数可省略，表示从第1个参数往后所有的元素；</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // Orange,Lemon</code></pre><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（二）</title>
      <link href="/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h2><h3 id="1、for循环遍历数组"><a href="#1、for循环遍历数组" class="headerlink" title="1、for循环遍历数组"></a>1、for循环遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (var i = 0; i &lt; fruits.length; i++) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="2、for-in-遍历数组"><a href="#2、for-in-遍历数组" class="headerlink" title="2、for in 遍历数组"></a>2、for in 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (i in fruits) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="3、forEach-遍历数组"><a href="#3、forEach-遍历数组" class="headerlink" title="3、forEach() 遍历数组"></a>3、forEach() 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});// Banana// Orange// Apple// Mango  fruits.forEach(v =&gt; {    console.log(v);});// Banana// Orange// Apple// Mango  </code></pre><p>数组元素和元素索引</p><pre><code class="js">var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    console.log(&#39;数组元素&#39; + value);    console.log(&#39;数组元素索引号&#39; + index);})// 数组元素1// 数组元素索引号0// 数组元素2// 数组元素索引号1// 数组元素3// 数组元素索引号2</code></pre><p>求数组的和</p><pre><code class="js">var sum = 0;var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    sum += value;})console.log(sum); // 6</code></pre><h2 id="二、数组迭代"><a href="#二、数组迭代" class="headerlink" title="二、数组迭代"></a>二、数组迭代</h2><h3 id="1、filter-筛选数组"><a href="#1、filter-筛选数组" class="headerlink" title="1、filter() 筛选数组"></a>1、filter() 筛选数组</h3><p>返回一个新数组，接受 3 个参数：项目值、项目索引、数组本身</p><p>返回大于50的元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value) {    return value &gt;= 50;})console.log(newArr); // [66, 88]</code></pre><p>返回偶数元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr2 = arr.filter(function(value) {    return value % 2 === 0;})console.log(newArr2); // [12, 66, 4, 88]</code></pre><h3 id="2、some-查找满足条件的元素是否存在"><a href="#2、some-查找满足条件的元素是否存在" class="headerlink" title="2、some() 查找满足条件的元素是否存在"></a>2、some() 查找满足条件的元素是否存在</h3><p>filter() 查找满足条件的元素 返回一个 <code>新数组</code> </p><p>some() 查找满足条件的元素是否存在 返回一个 <code>布尔值</code> </p><p>接受 3 个参数： <code>项目值</code> 、 <code>项目索引</code> 、 <code>数组本身</code> </p><p>sonme() 如果查找到第一个满足条件的元素就终止循环，效率更高</p><pre><code class="js">var arr = [10, 30, 4];var flag = arr.some(function(value) {    return value &lt; 3;});console.log(flag); // falsevar arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;];var flag1 = arr1.some(function(value) {    return value == &#39;pink&#39;;});console.log(flag1); // true</code></pre><h3 id="3、forEach-和-some-的区别"><a href="#3、forEach-和-some-的区别" class="headerlink" title="3、forEach() 和 some() 的区别"></a>3、forEach() 和 some() 的区别</h3><p>如果查询数组中唯一的元素, 用some方法更合适</p><p>在 some 里面 遇到 return true 就是终止遍历 迭代效率更高</p><p>在forEach 里面 return 不会终止迭代</p><pre><code class="js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];arr.some(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在 some 里面 return true 就终止遍历 迭代效率更高        return true;    }    console.log(11);    // 11    // 找到了该元素});var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];// 1. forEach迭代 遍历arr.forEach(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在forEach 里面 return 不会终止迭代        return true;    }    console.log(11);})// 11// 找到了该元素// 11// 11</code></pre><h3 id="4、indexOf"><a href="#4、indexOf" class="headerlink" title="4、indexOf()"></a>4、indexOf()</h3><p>在数组中搜索元素值并返回其位置</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); // 0</code></pre><h3 id="5、lastIndexOf"><a href="#5、lastIndexOf" class="headerlink" title="5、lastIndexOf()"></a>5、lastIndexOf()</h3><p>在数组中搜索元素值并返回其位置，从数组结尾开始搜索</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); // 2</code></pre><h3 id="6、find"><a href="#6、find" class="headerlink" title="6、find()"></a>6、find()</h3><p>返回通过测试函数的第一个数组元素的值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.find(function(value) {    return value &gt; 18;})console.log(first); // 25 第一个比18大的值</code></pre><h3 id="7、findIndex"><a href="#7、findIndex" class="headerlink" title="7、findIndex()"></a>7、findIndex()</h3><p>返回通过测试函数的第一个数组元素的索引</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(function(value) {    return value &gt; 18;})console.log(first); // 3 第一个比18大的值的索引号是3</code></pre><h3 id="8、map"><a href="#8、map" class="headerlink" title="8、map()"></a>8、map()</h3><p>对每个数组元素执行函数来创建新数组，不会更改原始数组。</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.map(function(value) {    return value * 2;})console.log(first); // [2, 4, 6] 将每个数组值乘以2</code></pre><h3 id="9、reduce-reduceRight"><a href="#9、reduce-reduceRight" class="headerlink" title="9、reduce() reduceRight()"></a>9、reduce() reduceRight()</h3><p>在每个数组元素上运行函数，以生成（减少它）单个值</p><p>reduceRight() 方法在数组中从左到右工作</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.reduce(function(total, value) {    return total + value;})console.log(first); // 6 总和为6</code></pre><h3 id="10、every"><a href="#10、every" class="headerlink" title="10、every()"></a>10、every()</h3><p>检查所有数组值是否通过测试，返回布尔值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.every(function(value) {    return value &gt; 18;})console.log(first); // false(并非所有元素都大于18)</code></pre><h2 id="三、数组排序"><a href="#三、数组排序" class="headerlink" title="三、数组排序"></a>三、数组排序</h2><h3 id="1、reverse-反转数组"><a href="#1、reverse-反转数组" class="headerlink" title="1、reverse() 反转数组"></a>1、reverse() 反转数组</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // Mango,Apple,Orange,Banana</code></pre><h3 id="2、sort-以字母方式排序"><a href="#2、sort-以字母方式排序" class="headerlink" title="2、sort() 以字母方式排序"></a>2、sort() 以字母方式排序</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // Apple,Banana,Mango,Orange</code></pre><h3 id="3、sort-以数字方式排序"><a href="#3、sort-以数字方式排序" class="headerlink" title="3、sort() 以数字方式排序"></a>3、sort() 以数字方式排序</h3><p>如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b}); // 1,5,10,25,40,100</code></pre><p>通过一个比值函数，对数组进行降序排序。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a}); // 100,40,25,10,5,1</code></pre><h3 id="4、sort-随机排序"><a href="#4、sort-随机排序" class="headerlink" title="4、sort() 随机排序"></a>4、sort() 随机排序</h3><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return 0.5 - Math.random()});// 40,10,5,100,1,25  随机生成排序// 5,40,100,25,1,10</code></pre><h3 id="5、sort-查找最高-最低数组值"><a href="#5、sort-查找最高-最低数组值" class="headerlink" title="5、sort() 查找最高/最低数组值"></a>5、sort() 查找最高/最低数组值</h3><p>升序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b});// 现在 points[0] 包含最低值// 而 points[points.length-1] 包含最高值</code></pre><p>降序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a});// 现在 points[0] 包含最高值// 而 points[points.length-1] 包含最低值</code></pre><h3 id="6、Math-max-apply-查找最高数组值"><a href="#6、Math-max-apply-查找最高数组值" class="headerlink" title="6、Math.max.apply() 查找最高数组值"></a>6、Math.max.apply() 查找最高数组值</h3><p>apply() 第二个参数须是数组，与 <code>Math.max</code> 相结合使用。</p><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> .</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.max.apply(Math, points)var a = Math.max.apply(null, points) // null 也可以console.log(a); // 100</code></pre><h3 id="7、Math-min-apply-查找最低数组值"><a href="#7、Math-min-apply-查找最低数组值" class="headerlink" title="7、Math.min.apply() 查找最低数组值"></a>7、Math.min.apply() 查找最低数组值</h3><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> 。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.min.apply(Math, points)console.log(a); // 1</code></pre><p><img src="http://mdimg.95408.com/20191213144049.png" alt="20191213144049"></p><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github</title>
      <link href="/2019/12/17/tools/git%E5%92%8Cgithub/"/>
      <url>/2019/12/17/tools/git%E5%92%8Cgithub/</url>
      
        <content type="html"><![CDATA[<h1 id="git-本地仓库"><a href="#git-本地仓库" class="headerlink" title="git 本地仓库"></a>git 本地仓库</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>Git 使用前配置</strong></p><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名： <code>git config --global user.name 提交人姓名</code> </li><li>配置提交人姓名： <code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息： <code>git config --list</code> </li></ol><p><strong>提交步骤</strong></p><ol><li><code>git init</code> 初始化git仓库</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件/提交到暂存区</li><li><code>git commit -m 提交信息</code> 向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><p><strong>撤销</strong></p><ul><li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code> </li><li>将文件从暂存区中删除： <code>git rm --cached 文件</code> </li><li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录： <code>git rest --hard commitID</code> （ID号可以通过 <code>git log</code> 查看） </li></ul><p><strong>分支命令</strong></p><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 来源分支</code> 合并分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><p><strong>暂时保存更改</strong></p><ul><li>存储临时改动： <code>git stash</code> </li><li>恢复改动： <code>git stash pop</code> </li></ul><h2 id="创建-git-init"><a href="#创建-git-init" class="headerlink" title="创建 git init"></a>创建 git init</h2><p>进入到一个目标管理文件夹，输入 <code>init</code> 命令创建完成；</p><pre><code class="git">$ git init  // 初始化工作区，创建.git的隐藏文件夹</code></pre><h2 id="保存-git-add-commit"><a href="#保存-git-add-commit" class="headerlink" title="保存 git add / commit"></a>保存 git add / commit</h2><p>保存一个文件的版本：</p><pre><code class="git">$ git add code1.py   // 保存到暂存区$ git commit -m &#39;这是第一个版本&#39;   // 保存到本地文件库</code></pre><p>再保存一个文件的另一个版本：</p><pre><code class="git">$ git add code1.py$ git commit -m &#39;这是第二个版本&#39;</code></pre><p>将工作区所有文件保存到暂存区：</p><pre><code class="git">$ git add .</code></pre><h2 id="查看版本-git-log"><a href="#查看版本-git-log" class="headerlink" title="查看版本 git log"></a>查看版本 git log</h2><p>查看文件多个版本：</p><pre><code class="git">$ git logcommit 699977fa2a89db2dabc8bf9c1d2e17f23dc4a73f (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 15:02:37 2019 +0800    &#39;这是第二个版本。&#39;commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>以简短形式显示：</p><pre><code class="git">$ git log --pretty=oneline</code></pre><p>ps.win窗口使用命令行<strong>不能显示中文字符</strong>：</p><p>使用 <code>Git Bash</code> 窗口，右键设置–文本设置为 <code>zh_ch UTF-8</code> 退出重新进入即可。</p><h2 id="回退-git-reset"><a href="#回退-git-reset" class="headerlink" title="回退 git reset"></a>回退 git reset</h2><p>回到第一个版本：</p><p>HEAD^ 前一个版本；HEAD^^ 前两个版本；HEAD<del>1 前一个版本；HEAD</del>100 前100个版本；</p><pre><code class="git">$ git reset --hard HEAD^commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154 (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>通过版本号回到第二个版本：</p><pre><code class="git">$ git reset --hard 6999HEAD is now at 699977f &#39;这是第二个版本。&#39;</code></pre><p>如果退回到第一版本记录后，即出终端就找不到第二版本的版本号时，我们可以使用 <code>git reflog</code> 查看操作记录，得到最前面的版本号；如下， <code>699977f</code> 就是第二个版本的版本号。</p><pre><code class="git">$ git reflog699977f (HEAD -&gt; master) HEAD@{0}: reset: moving to 6999325e516 HEAD@{1}: reset: moving to HEAD^699977f (HEAD -&gt; master) HEAD@{2}: commit: &#39;这是第二个版本。&#39;325e516 HEAD@{3}: commit (initial): &#39;这是第一个版本。&#39;</code></pre><h2 id="工作区-暂存区"><a href="#工作区-暂存区" class="headerlink" title="工作区 暂存区"></a>工作区 暂存区</h2><p>保存文件的 git_test 是工作区；</p><p>git_test 文件夹下的 .git 文件夹是版本库；其中包含暂存区；</p><p>git add 将文件添加到暂存区； git commit 把暂存区所有内容提交到当前分支，创建版本记录；</p><pre><code class="git">$ git add XXX$ git commit -m 保存到本地文件库要增加的说明文字</code></pre><p>查看未处理提交的文件状态：</p><pre><code class="git">$ git status</code></pre><h2 id="撤销修改-git-checkout"><a href="#撤销修改-git-checkout" class="headerlink" title="撤销修改 git checkout"></a>撤销修改 git checkout</h2><p>文件没有保存到暂存区时，取消修改：</p><pre><code class="git">git checkout -- code2.txt</code></pre><p>文件通过git add code2.txt 保存到了暂存区，取消修改：</p><pre><code class="git">git reset HEAD code2.txt  # 先取消暂存git checkout -- code2.txt # 和上一步一样，取消修改</code></pre><p>如果已经提交到了版本库（git commit -m ‘版本4’），就通过版本回退</p><pre><code class="git">$ git reset --hard HEAD^</code></pre><h2 id="查看不同-git-diff"><a href="#查看不同-git-diff" class="headerlink" title="查看不同 git diff"></a>查看不同 git diff</h2><p>查看工作区与之前版本的不同：</p><pre><code class="git">$ git diff HEAD -- code1.py</code></pre><p>查看上个版本和上上个版本的不同：</p><pre><code class="git">$ git diff Head HEAD^ -- code1.py</code></pre><h2 id="删除文件-git-rm"><a href="#删除文件-git-rm" class="headerlink" title="删除文件 git rm"></a>删除文件 git rm</h2><pre><code class="git">git add code2.txt  # 文件提交到了暂存区rm code2.txt  # 工作区删除文件git rm code2.txt # 将删除提交到暂存区git commit -m &#39;删除后提交的版本&#39;  # 将删除后提交一个版本# 删除后恢复与撤销修改相同</code></pre><h2 id="切换分支-git-branch"><a href="#切换分支-git-branch" class="headerlink" title="切换分支 git branch"></a>切换分支 git branch</h2><p>查看当前所有分支：git branch</p><pre><code class="git">$ git branch* master</code></pre><p>创建分支：git branch dev</p><pre><code class="git">// 创建新分支后：$ git branch* master  // 当前分支  dev  // 新创建的分支</code></pre><p>切换分支：git checkout dev</p><pre><code class="git">// 切换分支后：$ git branch  master* dev  // 当前分支为dev</code></pre><p>创建并切换分支：git checkout -b dev</p><pre><code class="git">$ git checkout -b dev$ git branch* dev  master</code></pre><p>切换回master分支：git checkout master</p><pre><code class="git">$ git checkout master$ git branch  dev* master</code></pre><p>在dev分支上做修改并提交后，可以切换到master分支，并使用以下方式合并dev分支；</p><h2 id="合并分支-git-merge"><a href="#合并分支-git-merge" class="headerlink" title="合并分支 git merge"></a>合并分支 git merge</h2><p>回到主分支master上，合并dev分支：git merge dev</p><pre><code class="git">$ git merge dev</code></pre><h2 id="删除分支-git-branch"><a href="#删除分支-git-branch" class="headerlink" title="删除分支 git branch"></a>删除分支 git branch</h2><p>分支上所有内容都合并到主分支时，可以删除分支：git branch -d dev</p><pre><code class="git">$ git branch -d dev// 如果没有合并子分支上的内容，并需要强制合并，改成大写 -D</code></pre><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>当切换到dev分支修改code.txt并提交add、commit；</p><p>又切换回master分支修改code.txt并提交add、commit；</p><p>将dev分支合并到master时（git merge dev），会出现冲突；</p><p>（现在在master分支当中），手动修改code.txt冲突文件，并再次add、commit提交；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>当在dev分支修改一个文件，并提交commit；</p><p>又在master分支增加一个新文件，并提交commit；</p><p>此时，在两个不同分支下有两个不同的提交；</p><p>此时合并时，git会提示输入一个分支注释文字，并自动创建一个新的分支；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="禁用快速合并-–no-ff"><a href="#禁用快速合并-–no-ff" class="headerlink" title="禁用快速合并 –no-ff"></a>禁用快速合并 –no-ff</h2><p>在dev分支上做了修改并提交一个分支为“dev分支”；</p><p>切换回master分支，将dev分支合并：</p><pre><code class="git">$ git merge dev</code></pre><p>无冲突时，git会使用快速合并 <code>Fast forward</code> ，如果我们要保存分支信息时，需要禁止快速合并；</p><pre><code class="git">$ git merge --no-ff -m &#39;禁用fast forward版本&#39; dev</code></pre><p>此时，原来dev创建的“dev分支”会保留下来，</p><p>并会创建一个新的分支：“禁用fast forward版本”；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p><strong>禁用快速合并的情况</strong></p><p>当我们在dev分支进行工作时，需要临时进入一个临时分支进行bug处理；</p><p>可以先将当前分支存储起来：</p><pre><code class="git">git stash</code></pre><p>此时我们使用 <code>git status</code> 查看，变成了干净的工作区；</p><p>切换回master分支：git checkout master</p><p>创建一个临时分支：bug-001；</p><p>修改bug完成，提交commit一个“修改bug-001版本”；</p><p>切换回master分支；</p><p>此时如果直接合并分支，就没有修改bug-001版本的记录；</p><p>我们就采用禁用快速合并的处理方式；</p><p>合并临时分支：bug-001；</p><pre><code class="git">git merge --no-ff -m &quot;修复bug后的版本&quot; bug-001</code></pre><h2 id="存储工作现场-git-stash-暂时保存更改"><a href="#存储工作现场-git-stash-暂时保存更改" class="headerlink" title="存储工作现场 git stash 暂时保存更改"></a>存储工作现场 git stash 暂时保存更改</h2><p>当我们在dev分支上工作时，需要临时进入master分支上做修改，</p><p>只需在分支上临时保存，再进入master分支操作保存。</p><p>返回dev分支上重新开始工作。</p><pre><code class="git">git stash  // 当前在dev分支，暂存文件$ git statusOn branch dev  // 当前在dev分支nothing to commit, working tree clean  // 暂存文件后，分支变干净了</code></pre><p>回到master分支，进行bug修改，保存：</p><pre><code class="git">git checkout master</code></pre><p>查看存储的工作记录：</p><pre><code class="git">git stash list</code></pre><p>在master分支上完成操作后，返回到dev分支上，恢复工作记录：</p><pre><code class="git">git checkout dev   // 返回dev分支git stash pop   // 恢复工作记录</code></pre><h1 id="github-远程仓库"><a href="#github-远程仓库" class="headerlink" title="github 远程仓库"></a>github 远程仓库</h1><p><img src="http://mdimg.95408.com/201912171203_333.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="1、-A-将新项目-push-至-github"><a href="#1、-A-将新项目-push-至-github" class="headerlink" title="1、  A 将新项目 push 至 github"></a>1、  A 将新项目 push 至 github</h2><p>(1)、A 将地址文件夹1215_git中的项目修改完成，保存到本地仓库；</p><p>(2)、A 在 github.com 上创建一个新项目：1215_git；并得到了项目远程地址： <code>https://github.com/yuanshengorg/1215_git.git</code> 。</p><p>(3)、A 将本地项目 push 至远程仓库：master 表示本地仓库的分支；</p><pre><code class="git">$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>将远程地址改为简短别名：</p><pre><code class="git">$ git remote add origin https://github.com/yuanshengorg/1215_git.gitorigin 表示将远程地址改为的别名</code></pre><p>通过别名推送到远程仓库：</p><pre><code class="git">$ git push origin master</code></pre><p>在第一次推送时，加上 -u 记录：</p><pre><code class="git">$ git push -u origin master</code></pre><p>下一次推送可以更简单：</p><pre><code class="git">$ git push</code></pre><h2 id="2、-B-将项目-clone-到-本地"><a href="#2、-B-将项目-clone-到-本地" class="headerlink" title="2、 B 将项目 clone 到 本地"></a>2、 B 将项目 clone 到 本地</h2><p>在网站上获取 Clone 地址：</p><p><img src="http://mdimg.95408.com/201912171139_943.png?imageView2/2/w/1200/h/1200" alt=""></p><p>克隆远端数据仓库到本地： <code>git clone 仓库地址</code> </p><pre><code class="git">git clone https://github.com/yuanshengorg/1215_git.git</code></pre><h2 id="3、-B-将项目修改后-push-至-github"><a href="#3、-B-将项目修改后-push-至-github" class="headerlink" title="3、 B 将项目修改后 push 至 github"></a>3、 B 将项目修改后 push 至 github</h2><p>B 将项目克隆到本地后，直接在本地修改，add 至暂存区，commit 至本地仓库；</p><p>完成修改，上传到 A 创建的项目远程仓库：</p><pre><code class="git">$ git push origin master   // A 创建的远程地址别名 B 也可以使用或者：$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>B 如果想摄推送内容至 A 的仓库，需要 A 设置一下：邀请 B 为团队成员。</p><p><img src="http://mdimg.95408.com/201912171157_660.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="4、-A-拉取远程仓库中最新的版本"><a href="#4、-A-拉取远程仓库中最新的版本" class="headerlink" title="4、 A 拉取远程仓库中最新的版本"></a>4、 A 拉取远程仓库中最新的版本</h2><p>拉取远程仓库中最新的版本： <code>git pull 远程仓库地址 分支名称</code> </p><pre><code class="git">$ git pull origin master或者：$ git pull https://github.com/yuanshengorg/1215_git.git master</code></pre><p>git clone 是完全克隆；</p><p>git pull 是本地已有项目，只拉取远程仓库中更新的内容；</p><h2 id="SSH-推送"><a href="#SSH-推送" class="headerlink" title="SSH 推送"></a>SSH 推送</h2><p><img src="http://mdimg.95408.com/201912171137_313.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code class="git">$ ssh-keygen</code></pre><p>会在本地（/c/Users/用户名/.ssh/）生成：id_rsa 文件和 id_rsa.pub 文件；</p><p>将 <code>id_rsa.pub</code> 文件打开复制内容设置到 github.com 网站上，即可。</p><p>github.com ——右上角个人中心——settings——SSH and GPG keys——SSH keys，新增保存即可。</p><p><img src="http://mdimg.95408.com/201912171135_162.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="跨团队合作："><a href="#跨团队合作：" class="headerlink" title="跨团队合作："></a>跨团队合作：</h2><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h2 id="忽略清单文件创建："><a href="#忽略清单文件创建：" class="headerlink" title="忽略清单文件创建："></a>忽略清单文件创建：</h2><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>git忽略清单文件名称：<strong>.gitignore</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo创建博客</title>
      <link href="/2019/12/17/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/17/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912180011_408.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="node-js-和-npm"><a href="#node-js-和-npm" class="headerlink" title="node.js 和 npm"></a>node.js 和 npm</h3><p>Hexo是基于nodejs的静态博客，首先需要安装nodejs，并且需要nodejs中的重要工具：<code>npm</code> ；</p><p>查看 nodejs 版本：<code>node -V</code> ；</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>有了nodejs，其他就简单了！安装hexo： <code>npm install -g hexo</code> ；</p><p>查看 hexo 版本： <code>hexo -v</code> ；</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>你也可以安装一个必备的代码管理工具：<code>git</code> ；这样我们就可以使用 <code>git bash</code> 这个工具了；</p><p>查看 git 版本： <code>git version</code> ；</p><h2 id="创建-hexo"><a href="#创建-hexo" class="headerlink" title="创建 hexo"></a>创建 hexo</h2><p>我们在本地创建一个文件夹 <code>d\hexo</code> 做为博客的目录；</p><p>只需3步，完成博客的搭建：</p><p>1、在 <code>d\hexo</code>目录下，执行以下命令，创建 hexo 完成；</p><pre><code class="git">hexo init</code></pre><p>2、开始书写文章：</p><pre><code class="git">hexo new &#39;我的第一篇hexo博客文章&#39;</code></pre><p>3、运行本地博客服务器：</p><pre><code class="git">$ hexo s    INFO  Start processing    INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>此时，我们在浏览器当中输入：<code>http://local:4000</code> 即可查看网站。</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>使用以下命令创建文章，我们就可以通过 <code>D:\hexo\source\_posts</code> 查看创建的文件，开始创作即可。</p><pre><code class="git">$ hexo new [layout] &lt;title&gt;</code></pre><p>或者直接将md文章放入到 <code>D:\hexo\source\_posts</code> 目录下；</p><h2 id="文章预定义参数"><a href="#文章预定义参数" class="headerlink" title="文章预定义参数"></a>文章预定义参数</h2><p>我们在md文章形状，使用yaml定义标题、分类、标签、日期等等，可以自己增减。</p><pre><code class="yaml">---title: 文章标题date： 日期categories: 分类tags: 标签---</code></pre><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">官方文档：更多预先定义的参数</a></p><p>如果是有子分类：</p><pre><code class="yaml">categories: [父分类， 子分类]</code></pre><p>如果是有多个标签：</p><pre><code class="yaml">tags: [标签1， 标签2]</code></pre><h2 id="搭建到-github"><a href="#搭建到-github" class="headerlink" title="搭建到 github"></a>搭建到 github</h2><p>1、创建 github 账号，并创建 ssh （参考：<a href="https://yuanshengorg.github.io/2019/12/17/tools/git%E5%92%8Cgithub/#SSH-%E6%8E%A8%E9%80%81" target="_blank" rel="noopener">git和github：SSH</a>）； </p><p>2、在自己的账号下，新建一个repo：<code>New repository</code> （github右上角 + 号——New repository）；</p><p>3、项目名称（Repository name）为：<code>你的名称.github.io</code> ，如 <code>yuansheng.github.io</code>；</p><p><img src="http://mdimg.95408.com/201912172352_728.png?imageView2/2/w/1200/h/1200" alt=""></p><p>4、回到本地文件夹：<code>d/hexo</code> ，修改文件： <code>_config.yml</code> ：</p><pre><code class="git">deploy:  type: git  repo: https://github.com/yuansheng/yuansheng.github.io.git  branch: master</code></pre><p>repo 请修改为你创建的地址。</p><p>5、安装工具：hexo-deployer-git</p><pre><code class="git">npm install hexo-deployer-git --save</code></pre><p>6、回到命令行工具运行：</p><pre><code class="git">hexo clean // 清除之前生成的文件hexo generate   // 生成新的静态文件hexo depoly   // 部署网站</code></pre><p>执行 <code>hexo depoly</code> 时，第一次可能会需要注册 github.com 的账号及密码；</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>输入 <code>yuansheng.github.io</code> ，即你设置的项目文件名，即可访问网站；</p><p>你也可以绑定自己的域名，如 <code>www.yuanblogname.com</code>；</p><h2 id="增-改文章"><a href="#增-改文章" class="headerlink" title="增/改文章"></a>增/改文章</h2><p>上面的三个命令 <code>hexo clean / generate / depoly</code> 可简写为：</p><pre><code class="git">hexo cleanhexo ghexo d</code></pre><p>以后每次在文件夹中增加、修改了 md 文章后，执行这三个命令即可；</p><p>所有在本地电脑上修改的文档，远程博客也就修改了。</p><h2 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo官方文档：指令</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档：中文</a></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
