<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript（六）对象、构造函数、Math、Date</title>
      <link href="/2020/01/06/js/JavaScript%EF%BC%88%E5%85%AD%EF%BC%89%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/01/06/js/JavaScript%EF%BC%88%E5%85%AD%EF%BC%89%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象概念"><a href="#对象概念" class="headerlink" title="对象概念"></a>对象概念</h3><ul><li>在 JavaScript 中，对象是一组无序的相关属性和方法的集合</li><li>所有的事物都是对象，例如字符串、数值、数组、函数等。</li><li>对象是由属性和方法组成的。<ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法：事物的行为，在对象中用方法来表示（常用动词）</li></ul></li><li>为了让更好地存储一组数据，对象应运而生<ul><li>对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显</li><li>JS中的对象表达结构更清晰，更强大。</li></ul></li></ul><pre><code class="js">var obj = {    name: &quot;张三&quot;,    sex: &quot;男&quot;,    age: 28,    height: 170}</code></pre><h3 id="字面量创建对象"><a href="#字面量创建对象" class="headerlink" title="字面量创建对象"></a>字面量创建对象</h3><ul><li>花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；</li><li>花括号 { } 里面采取键值对的形式表示；<ul><li>键：相当于属性名；</li><li>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）;</li></ul></li></ul><pre><code class="js">var star = {    name : &#39;pink&#39;,    age : 18,    sex : &#39;男&#39;,    sayHi : function(){        alert(&#39;大家好啊~&#39;);    }};</code></pre><h3 id="对象的属性和方法"><a href="#对象的属性和方法" class="headerlink" title="对象的属性和方法"></a>对象的属性和方法</h3><ul><li>对象的属性；<ul><li>对象中存储<strong>具体数据</strong>的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项；</li></ul></li><li>对象的方法；<ul><li>对象中存储<strong>函数</strong>的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项；</li></ul></li><li>访问对象的属性；<ul><li>对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ”  ；</li><li>对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号    ；</li></ul></li><li>调用对象的方法；<ul><li>对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号 ；</li></ul></li></ul><p>访问对象的属性</p><pre><code class="js">// 访问对象的属性console.log(star.name)     // 调用名字属性console.log(star[&#39;name&#39;])  // 调用名字属性</code></pre><p>调用对象的方法</p><pre><code class="js">// 调用对象的方法star.sayHi(); // 调用sayHi方法 带后面的括号</code></pre><h3 id="变量与属性、函数和方法"><a href="#变量与属性、函数和方法" class="headerlink" title="变量与属性、函数和方法"></a>变量与属性、函数和方法</h3><ul><li><p>变量、属性总结；</p><ul><li>属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器；</li><li>变量：单独声明赋值，单独存在；</li><li>属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征；</li></ul></li><li><p>函数、方法总结；</p><ul><li><p>方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器；</p></li><li><p>函数：单独存在的，通过“函数名()”的方式就可以调用；</p></li><li><p>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能；</p></li></ul></li></ul><h3 id="new-Object-创建对象"><a href="#new-Object-创建对象" class="headerlink" title="new Object 创建对象"></a>new Object 创建对象</h3><pre><code class="js">var xyz = new Obect();xyz.name = &#39;pink&#39;;xyz.age = 18;xyz.sex = &#39;男&#39;;xyz.sayHi = function(){    alert(&#39;Hello JS~&#39;);}</code></pre><ul><li>通过内置构造函数Object创建对象，此时xyz变量已经保存了创建出来的空对象；</li><li>通过对象操作属性和方法的方式，来为对象增加属性和方法；</li><li>Object() ：第一个字母大写；</li><li>new Object() ：需要 new 关键字；</li><li>使用的格式：对象.属性 =  值；</li></ul><h3 id="构造函数实例化对象"><a href="#构造函数实例化对象" class="headerlink" title="构造函数实例化对象"></a>构造函数实例化对象</h3><pre><code class="js">// 构造函数的封装格式function 构造函数名(形参1,形参2,形参3) {     this.属性名1 = 参数1;     this.属性名2 = 参数2;     this.属性名3 = 参数3;     this.方法名 = 函数体;}// 构造函数的调用格式var obj = new 构造函数名(实参1，实参2，实参3)// obj即接收到构造函数创建出来的对象</code></pre><ul><li>构造函数：<ul><li>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用；</li><li>我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面；</li></ul></li><li>构造函数注意事项：<ul><li>构造函数约定<strong>首字母大写</strong>；</li><li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法；</li><li>构造函数中<strong>不需要 return 返回结果</strong>；</li><li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>；</li></ul></li><li>类与实例化对象：<ul><li>构造函数，如 function Stars() {}，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） ；</li><li>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化；</li></ul></li><li>new关键字作用：<ul><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码；</li><li>在函数完成之后，返回this—即创建出来的对象；</li></ul></li></ul><h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><pre><code class="js">for (变量 in 对象名字) {    // 在此执行代码}// 语法中的变量是自定义的，它需要符合命名规范// 通常我们会将这个变量写为 k 或者 keyfor (var k in obj) {    console.log(k);      // 这里的 k 是属性名    console.log(obj[k]); // 这里的 obj[k] 是属性值}</code></pre><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象</li><li>前面两种对象属于 ECMAScript；  第三个浏览器对象属于 JS 独有的</li><li>MDN文档: <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></li></ul><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><p>Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</p><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()/Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><p>注意：上面的方法使用时必须带括号</p><p><strong>获取指定范围内的随机整数</strong>：</p><pre><code class="js">function getRandom(min, max) {  return Math.floor(Math.random() * (max - min + 1)) + min; }</code></pre><h3 id="Date-日期对象"><a href="#Date-日期对象" class="headerlink" title="Date 日期对象"></a>Date 日期对象</h3><p>Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p><pre><code class="js">// 获取当前时间实例化var now = new Date();// 获取指定时间的日期对象var future = new Date(&#39;2019/5/1&#39;);</code></pre><ul><li>创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</li></ul><p><img src="http://mdimg.95408.com/202001060233_997.png?null" alt="使用Date实例的方法和属性"></p><p>通过Date实例获取总毫秒数</p><pre><code class="js">// 实例化Date对象var now = new Date();// 1. 用于获取对象的原始值console.log(date.valueOf())    console.log(date.getTime())    // 2. 简单写可以这么做var now = + new Date();            // 3. HTML5中提供的方法，有兼容性问题var now = Date.now();</code></pre><h3 id="String-字符串对象"><a href="#String-字符串对象" class="headerlink" title="String 字符串对象"></a>String 字符串对象</h3><ul><li>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean</li><li>基本包装类型<ul><li>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法</li></ul></li><li>字符串的不可变<ul><li>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。</li><li>由于字符串的不可变，在<strong>大量拼接字符串</strong>的时候会有效率问题</li></ul></li></ul><pre><code class="js">// 基本包装类型// 下面代码有什么问题？var str = &#39;andy&#39;;console.log(str.length);// 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法// 但上面代码却可以执行，这是因为// js 会把基本数据类型包装为复杂数据类型，其执行过程如下 // 1. 生成临时变量，把简单类型包装为复杂数据类型var temp = new String(&#39;andy&#39;);// 2. 赋值给我们声明的字符变量str = temp;// 3. 销毁临时变量temp = null;</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（五）函数、作用域、预解析</title>
      <link href="/2020/01/06/js/JavaScript%EF%BC%88%E4%BA%94%EF%BC%89%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/01/06/js/JavaScript%EF%BC%88%E4%BA%94%EF%BC%89%E5%87%BD%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数就是封装了一段可被重复调用执行的代码块；</li><li>通过此代码块可以<strong>实现大量代码的重复使用</strong>；</li></ul><h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><ul><li>function 是声明函数的关键字,必须小写；</li><li>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum；</li></ul><pre><code class="js">// 声明函数function 函数名() {    //函数体代码}</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><ul><li>调用时要加小括号；</li><li>口诀：函数不调用，自己不执行；</li><li>声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码；</li></ul><pre><code class="js">// 调用函数函数名();  // 通过调用函数名来执行函数体代码</code></pre><p>例子：封装计算1-100累加和</p><pre><code class="js">// 声明函数function getSum(){    var sumNum = 0; // 准备一个变量，保存数字和    for (var i = 1; i &lt;= 100; i++) {        sumNum += i; // 把每个数值 都累加 到变量中    }    alert(sumNum);}// 调用函数getSum();</code></pre><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul><li>形参：函数定义时设置接收调用时传入；</li><li>实参：函数调用时传入小括号内的真实数据；</li><li>调用的时候实参值是传递给形参的；</li><li>形参简单理解为：不用声明的变量；</li><li>实参和形参的多个参数之间用逗号（ , ）分隔；</li></ul><pre><code class="js">// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔  // 函数体}// 带参数的函数调用函数名(实参1, 实参2, 实参3...); </code></pre><p>函数形参和实参数量不匹配时：</p><ul><li>实参个数 = 形参个数：正确；</li><li>实参个数 &gt; 形参个数：只取到形参的个数；</li><li>实参个数 &lt; 形参个数：多的形参为undefined，结果为NaN；</li><li>在JavaScript中，形参的默认值是undefined；</li></ul><p>小结：</p><ul><li>函数可以带参数也可以不带参数；</li><li>声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined；</li><li>调用函数的时候，函数名括号里面的是实参；</li><li>多个参数中间用逗号分隔；</li><li>形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配；</li></ul><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>return 语句</p><ul><li>在使用 return 语句时，函数会停止执行，并返回指定的值；</li><li>如果函数没有 return ，返回的值是 undefined；</li></ul><pre><code class="js">// 声明函数function 函数名（）{    ...    return  需要返回的值；}// 调用函数函数名();    // 此时调用函数就可以得到函数体内return 后面的值</code></pre><h3 id="break、continue-和-return"><a href="#break、continue-和-return" class="headerlink" title="break、continue 和 return"></a>break、continue 和 return</h3><ul><li>break ：结束当前的循环体（如 for、while）；</li><li>continue ：跳出本次循环，继续执行下次循环（如 for、while）；</li><li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码；</li></ul><h3 id="arguments-不确定参数"><a href="#arguments-不确定参数" class="headerlink" title="arguments 不确定参数"></a>arguments 不确定参数</h3><ul><li>不确定有多少个参数传递的时候，可以用 arguments 来获取；</li><li>JavaScript 中，arguments实际上它是当前函数的一个内置对象；</li><li>所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参；</li><li>arguments展示形式是一个伪数组，因此可以进行遍历；</li><li>伪数组具有以下特点：<ul><li>具有 length 属性；</li><li>按索引方式储存数据；</li><li>不具有数组的 push , pop 等方法；</li><li>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参；</li></ul></li></ul><h3 id="函数内部调用其他函数"><a href="#函数内部调用其他函数" class="headerlink" title="函数内部调用其他函数"></a>函数内部调用其他函数</h3><p>函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。</p><h3 id="函数声明方式"><a href="#函数声明方式" class="headerlink" title="函数声明方式"></a>函数声明方式</h3><p>自定义函数方式 (<strong>命名函数</strong>)：</p><ul><li>利用函数关键字 function 自定义函数方式；</li><li>因为有名字，所以也被称为命名函数；</li><li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面；</li></ul><pre><code class="js">// 声明定义方式function fn1() {    ...};// 调用  fn1();  </code></pre><p>函数表达式方式 (<strong>匿名函数</strong>）：</p><ul><li>因为函数没有名字，所以也被称为匿名函数；</li><li>这个fn 里面存储的是一个函数  ；</li><li>函数表达式方式原理跟声明变量方式是一致的；</li><li>函数调用的代码必须写到函数体后面；</li></ul><pre><code class="js">// 这是函数表达式写法，匿名函数后面跟分号结束var fn2 = function( ) {    ...}；// 调用的方式，函数调用必须写到函数体下面fn2();</code></pre><h2 id="作用域、预解析"><a href="#作用域、预解析" class="headerlink" title="作用域、预解析"></a>作用域、预解析</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>全局作用域<ul><li>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。</li></ul></li><li>局部作用域<ul><li>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</li></ul></li><li>JS没有块级作用域<ul><li>块作用域由 { } 包括。</li></ul></li></ul><p>java有块级作用域：</p><pre><code class="java">if (true) {  int num = 123;  system.out.print(num);  // 123}system.out.print(num);    // 报错</code></pre><ul><li><p>以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；</p></li><li><p>而与之类似的JavaScript代码，则不会报错：</p></li></ul><p>Js中没有块级作用域（在ES6之前）</p><pre><code class="js">if (true) {    var num = 123;    console.log(123); //123}console.log(123);   //123</code></pre><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul><li>全局变量<ul><li>在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</li><li>全局变量在代码的任何位置都可以使用</li><li>在全局作用域下 var 声明的变量 是全局变量</li><li>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</li></ul></li><li>局部变量<ul><li>局部变量只能在该函数内部使用</li><li>在函数内部 var 声明的变量是局部变量</li><li>函数的形参实际上就是局部变量</li></ul></li><li>全局变量和局部变量的区别<ul><li>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</li><li>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</li></ul></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul><li>只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；</li><li>如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；</li><li>根据在<strong>[内部函数可以访问外部函数变量]</strong>的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链</li></ul><pre><code class="js">function f1() {    var num = 123;    function f2() {        console.log( num );    }    f2();}var num = 456;f1();</code></pre><p>作用域链：采取就近原则的方式来查找变量最终的值。</p><pre><code class="js">var a = 1;function fn1() {    var a = 2;    var b = &#39;22&#39;;    fn2();    function fn2() {        var a = 3;        fn3();        function fn3() {            var a = 4;            console.log(a); //a的值 ?            console.log(b); //b的值 ?        }    }}fn1();</code></pre><p><img src="http://mdimg.95408.com/202001060155_624.png?null" alt=""></p><h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><ul><li>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。</li><li>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。</li><li>代码执行： 从上到下执行JS语句。</li><li>预解析会把变量和函数的声明在代码执行之前执行完成。</li></ul><p><strong>变量预解析</strong></p><ul><li>预解析也叫做变量、函数提升。</li><li>变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。</li></ul><pre><code class="js">console.log(num);  // 结果是多少？var num = 10;      // 结果：undefined// 相当于：// 注意：变量提升只提升声明，不提升赋值var num;console.log(num); // undefinednum = 10;</code></pre><p><strong>函数预解析</strong></p><ul><li>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</li></ul><pre><code class="js">fn();function fn() {    console.log(&#39;打印&#39;);}// 结果：输出字符串 --- 打印// 相当于：// 函数声明代表函数整体// 函数提升后，函数名代表整个函数，但函数并没有被调用function fn() {    console.log(&#39;打印&#39;);}fn();</code></pre><p><strong>函数表达式声明函数问题</strong></p><ul><li>函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：</li></ul><pre><code class="js">fn();var fn = function() {    console.log(&#39;想不到吧&#39;);}// 结果：报错提示 ”fn is not a function&quot;// 先做变量声明提升，fn在提升之后的值是undefined；// fn调用是在fn被赋值为函数体之前// 此时fn的值是undefined，所以无法正确调用// 相当于：var fn;fn();fn = function() {    console.log(&#39;想不到吧&#39;);}</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（二）运算符、流程控制</title>
      <link href="/2020/01/06/js/JavaScript%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/01/06/js/JavaScript%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="运算符分类"><a href="#运算符分类" class="headerlink" title="运算符分类"></a>运算符分类</h3><ul><li>运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号</li><li>JavaScript中常用的运算符有：<ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul></li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>浮点数的精度：</p><ul><li>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</li><li>不要直接判断两个浮点数是否相等 ! </li></ul><p><img src="http://mdimg.95408.com/202001060045_820.png?null" alt="算数运算符"></p><pre><code class="js">// 浮点数的精度var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001</code></pre><h3 id="递增、递减运算符"><a href="#递增、递减运算符" class="headerlink" title="递增、递减运算符"></a>递增、递减运算符</h3><p>如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ – ）运算符来完成；</p><p>前置递增运算符：</p><ul><li><p>++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单</p></li><li><p>使用口诀：先自加，后返回值</p></li></ul><pre><code class="js">var  num = 10;alert(++num + 10);   // 21</code></pre><p>后置递增运算符：</p><ul><li><p>num++ 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。</p></li><li><p>使用口诀：先返回原值，后自加 </p></li></ul><pre><code class="js">var  num = 10;alert(10 + num++);  // 20</code></pre><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li>比较运算符（关系运算符）是两个数据进行比较时所使用的运算符</li><li>比较运算后，会返回一个布尔值（true / false）作为比较运算的结果</li></ul><p><img src="http://mdimg.95408.com/202001060050_105.png?null" alt="比较运算符"></p><p><strong>等号比较：</strong></p><p><img src="http://mdimg.95408.com/202001060051_754.png?null" alt="等号比较"></p><pre><code class="js">console.log(18 == &#39;18&#39;);   // trueconsole.log(18 === &#39;18&#39;);    // false</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值；</p><p><img src="http://mdimg.95408.com/202001060052_738.png?null" alt="逻辑运算符"></p><p><strong>逻辑与 &amp;&amp;</strong></p><p>两边都是 true才返回 true，否则返回 false</p><p><strong>逻辑或 ||</strong></p><p>两边都是 true才返回 true，否则返回 false</p><p><strong>逻辑非 ！</strong></p><p>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p><pre><code class="js">var isOk = !true;console.log(isOk);  // false</code></pre><p><strong>短路运算（逻辑中断）</strong></p><p>当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p><p><strong>逻辑与</strong></p><pre><code class="js">// 如果第一个表达式的值为真，则返回表达式2// 如果第一个表达式的值为假，则返回表达式1console.log( 123 &amp;&amp; 456 );        // 456console.log( 0 &amp;&amp; 456 );          // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789</code></pre><p><strong>逻辑或</strong></p><pre><code class="js">// 如果第一个表达式的值为真，则返回表达式1// 如果第一个表达式的值为假，则返回表达式2console.log( 123 || 456 );         //  123console.log( 0 ||  456 );          //  456console.log( 123 || 456 || 789 );  //  123</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>用来把数据赋值给变量的运算符；</p><p><img src="http://mdimg.95408.com/202001060057_944.png?null" alt="赋值运算符"></p><pre><code class="js">var age = 10;age += 5;  // 相当于 age = age + 5;age -= 5;  // 相当于 age = age - 5;age *= 10; // 相当于 age = age * 10;</code></pre><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="http://mdimg.95408.com/202001060057_921.png?null" alt="运算符优先级"></p><ul><li>一元运算符里面的逻辑非优先级很高</li><li>逻辑与比逻辑或优先级高</li></ul><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-else-分支流程"><a href="#if-else-分支流程" class="headerlink" title="if else 分支流程"></a>if else 分支流程</h3><p>if else语句（双分支语句）</p><pre><code class="js">// 条件成立  执行 if 里面代码，否则执行else 里面的代码if (条件表达式) {    // [如果] 条件成立执行的代码} else {    // [否则] 执行的代码}</code></pre><p>if else if 语句(多分支语句)</p><pre><code class="js">// 适合于检查多重条件。if (条件表达式1) {    语句1；} else if (条件表达式2)  {    语句2；} else if (条件表达式3)  {   语句3；} else {    // 上述条件都不成立执行此处代码}</code></pre><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><pre><code class="js">表达式1 ? 表达式2 : 表达式3;1 &lt; 2 ? &#39;真的&#39; : &#39;假的&#39;; </code></pre><ul><li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</li><li>简单理解： 就类似于  if  else （双分支） 的简写</li></ul><h3 id="switch-分支流程"><a href="#switch-分支流程" class="headerlink" title="switch 分支流程"></a>switch 分支流程</h3><pre><code class="js">switch( 表达式 ){     case value1:        // 表达式 等于 value1 时要执行的代码        break;    case value2:        // 表达式 等于 value2 时要执行的代码        break;    default:        // 表达式 不等于任何一个 value 时要执行的代码}</code></pre><p><strong>switch 分支流程</strong></p><ul><li><p>switch ：开关 转换  ， case ：小例子   选项</p></li><li><p>关键字 switch 后面括号内可以是表达式或值， 通常是一个变量</p></li><li><p>关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号</p></li><li><p>switch 表达式的值会与结构中的 case 的值做比较 </p></li><li><p>如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束</p></li><li><p>如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码</p><p><strong>注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。</strong></p></li></ul><p><strong>switch 语句和 if else if 语句的区别</strong></p><ul><li>一般情况下，它们两个语句可以相互替换</li><li>switch…case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围)</li><li>switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。</li><li>当分支比较少时，if… else语句的执行效率比 switch语句高。</li><li>当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。 </li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre><code class="js">for (初始化变量; 条件表达式; 操作表达式 ) {    //循环体}</code></pre><ul><li>初始化变量：通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数</li><li>条件表达式：用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环</li><li>操作表达式：用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环</li><li>初始化变量，初始化操作在整个 for 循环只会执行一次</li><li>执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束</li></ul><p>for 循环重复相同的代码</p><pre><code class="js">for(var i = 1; i &lt;= 10; i++){    console.log(&#39;这句话后台输出10遍~&#39;);}</code></pre><p>for 循环重复不相同的代码</p><pre><code class="js">// 输出1到100岁for (var i = 1; i &lt;= 100; i++) {      console.log(&#39;这个人今年&#39; + i + &#39;岁了&#39;);}</code></pre><p>for 里面添加其他语句</p><pre><code class="js">// 输出1到100岁，并提示出生、死亡for (var i = 1; i &lt;= 100; i++) { if (i == 1) {    console.log(&#39;这个人今年1岁了， 它出生了&#39;); } else if (i == 100) {    console.log(&#39;这个人今年100岁了，它死了&#39;);  } else {       console.log(&#39;这个人今年&#39; + i + &#39;岁了&#39;);  }}</code></pre><p>for循环因为有了计数器的存在，还可以重复的执行某些操作，比如做一些算术运算；</p><p>###双重for循环</p><pre><code class="js">for (外循环的初始; 外循环的条件; 外循环的操作表达式) {    for (内循环的初始; 内循环的条件; 内循环的操作表达式) {         需执行的代码;   }}</code></pre><ul><li>内层循环可以看做外层循环的循环体语句</li><li>内层循环执行的顺序也要遵循 for 循环的执行顺序 </li><li>外层循环执行一次，内层循环要执行全部次数</li></ul><p>打印五行五列星星</p><pre><code class="js">var star = &#39;&#39;;// 外层循环负责打印五行for (var j = 1; j &lt;= 3; j++) {    // 内层循环负责一行打印五个星星    for (var i = 1; i &lt;= 3; i++) {      star += &#39;☆&#39;    }    star += &#39;\n&#39;; // 每次满 5个星星 就 加一次换行}console.log(star);</code></pre><p><strong>for 循环小结</strong></p><ul><li>for 循环可以重复执行某些相同代码</li><li>for 循环可以重复执行些许不同的代码，因为我们有计数器</li><li>for 循环可以重复执行某些操作，比如算术运算符加法操作</li><li>随着需求增加，双重for循环可以做更多、更好看的效果</li><li>双重 for 循环，外层循环一次，内层 for 循环全部执行</li><li>for 循环是循环条件和数字直接相关的循环</li></ul><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><pre><code class="js">while (条件表达式) {    // 循环体代码 }</code></pre><ul><li>先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</li><li>执行循环体代码</li><li>循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</li><li>必须要有退出条件，否则会成为死循环</li></ul><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h3><pre><code class="js">do {    // 循环体代码 - 条件表达式为 true 时重复执行循环体代码} while (条件表达式) {    // 循环体代码 }</code></pre><ul><li>先执行一次循环体代码 </li><li>再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码</li><li>do…while循环语句至少会执行一次循环体代码</li></ul><h3 id="continue和break"><a href="#continue和break" class="headerlink" title="continue和break"></a>continue和break</h3><ul><li>continue 关键字用于立即跳出本次循环，<strong>继续下一次循环</strong>（本次循环体中 continue 之后的代码就会少执行一次）;</li><li>例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子：</li></ul><pre><code class="js"> for (var i = 1; i &lt;= 5; i++) {     if (i == 3) {         console.log(&#39;这个包子有虫子，扔掉&#39;);         continue; // 跳出本次循环，跳出的是第3次循环       }      console.log(&#39;我正在吃第&#39; + i + &#39;个包子&#39;); }</code></pre><ul><li>break 关键字用于<strong>立即跳出整个循环</strong>（循环结束）；</li><li>例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了：</li></ul><pre><code class="js">  for (var i = 1; i &lt;= 5; i++) {     if (i == 3) {         console.log(&#39;发现半个虫子，其余都不吃了&#39;);         break; // 直接退出整个for 循环，跳到整个for下面的语句     }     console.log(&#39;我正在吃第&#39; + i + &#39;个包子&#39;);   }</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（一）基础、变量、数据类型</title>
      <link href="/2020/01/05/js/JavaScript%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/05/js/JavaScript%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-相关"><a href="#JavaScript-相关" class="headerlink" title="JavaScript 相关"></a>JavaScript 相关</h2><h3 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h3><ul><li>汇编语言和高级语言：<ul><li>语言类型之汇编语言：汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆；</li><li>语言类型之高级语言：高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等；</li></ul></li><li>翻译器：<ul><li>高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。</li><li>翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化；</li></ul></li><li>解释型语言和编译型语言：<ul><li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。</li><li>两种方式之间的区别在于翻译的时间点不同；</li><li>编译型语言：编译器是在代码执行之前进行编译，生成中间代码文件；</li><li>解释型语言：解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)；</li></ul></li><li>编程语言和标记语言：<ul><li>编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的指令，这是主动的；</li><li>标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的；</li></ul></li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li>JavaScript 是什么：<ul><li>是世界上最流行的语言之一；</li><li>是运行在客户端的<strong>脚本语言</strong>；</li></ul></li><li>脚本语言：<ul><li>不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行；</li><li>现在也可以基于 Node.js 技术进行服务器端编程；</li></ul></li><li>JavaScript 作用：<ul><li>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）；</li><li>网页特效；</li><li>服务端开发(Node.js)；</li><li>桌面程序(Electron)；</li><li>App(Cordova) ；</li><li>控制硬件-物联网(Ruff)；</li><li>游戏开发(cocos2d-js)；</li></ul></li><li>JavaScript 与HTML/CSS的关系：<ul><li>HTML 决定网页结构和内容；</li><li>CSS 决定网页的样式和美观；</li><li>JS 实现功能、页面控制；</li></ul></li><li>渲染引擎和 JS 引擎：<ul><li>渲染引擎：解析 HTML 和 CSS，俗称内核，如 blink、webkit；</li><li>JS 引擎：也叫JS解释器，读取并处理、运行 JS 代码，如 V8；</li><li>浏览器本身并不会执行JS代码，通过内置 JavaScript 引擎(解释器) 来执行 JS 代码；</li><li>JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行；</li></ul></li><li>JavaScript 组成：<ul><li>JavaScript 语法： <strong>ECMAScript</strong>；</li><li>页面文档对象模型：<strong>DOM</strong>；</li><li>浏览器对象模型：<strong>BOM</strong>；</li></ul></li><li>ECMAScript：<ul><li>规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准；</li></ul></li><li>DOM：<ul><li>文档对象模型（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）；</li></ul></li><li>BOM：<ul><li>浏览器对象模型(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等；</li></ul></li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li>标识符：<ul><li>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字；</li><li>标识符不能是关键字或保留字；</li></ul></li><li>关键字：<ul><li>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名；</li><li>包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等；</li></ul></li><li>保留字：<ul><li>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名；</li><li>包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等；</li><li>注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误；</li></ul></li></ul><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p><strong>标识符命名规范</strong></p><ul><li>变量、函数的命名必须要有意义</li><li>变量的名称一般用名词  </li><li>函数的名称一般用动词  </li></ul><p><strong>操作符规范</strong></p><pre><code class="js">// 操作符的左右两侧各保留一个空格// i空格&lt;=空格5;for (var i = 1; i &lt;= 5; i++) {   console.log(i);}</code></pre><p><strong>注释规范</strong></p><pre><code class="js">for (var i = 1; i &lt;= 5; i++) {   console.log(i); // 单行注释前面注意有个空格}</code></pre><p><strong>其他规范</strong>    </p><pre><code class="js">// 关键词、操作符之间后加空格// if空格(true)空格{if (true) {}</code></pre><h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="JS-书写位置"><a href="#JS-书写位置" class="headerlink" title="JS 书写位置"></a>JS 书写位置</h3><p>行内式</p><pre><code class="html">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#39;Hello World&#39;)&quot; /&gt;</code></pre><p>内嵌式</p><pre><code class="html">&lt;script&gt;    alert(&#39;Hello  World~!&#39;);&lt;/script&gt;</code></pre><p>外部JS文件</p><pre><code class="html">&lt;script src=&quot;./js/myjs.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="JS-注释"><a href="#JS-注释" class="headerlink" title="JS 注释"></a>JS 注释</h3><p>单行注释</p><pre><code class="js">// 用来注释单行文字（快捷键 ctrl + / ）alert(&#39;Hello World!&#39;);</code></pre><p>多行注释</p><pre><code class="js">/*  用来注释多行文字  默认快捷键 alt + shift + a*/</code></pre><h3 id="JS-输入输出语句"><a href="#JS-输入输出语句" class="headerlink" title="JS 输入输出语句"></a>JS 输入输出语句</h3><table><thead><tr><th>方法</th><th>说明</th><th>归属</th></tr></thead><tbody><tr><td>alert(msg)</td><td>浏览器弹出警示框</td><td>浏览器</td></tr><tr><td>console.log(msg)</td><td>浏览器控制台打印输出信息</td><td>浏览器</td></tr><tr><td>prompt(info)</td><td>浏览器弹出输入框，用户可以输入</td><td>浏览器</td></tr></tbody></table><h2 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h2><h3 id="JS-变量"><a href="#JS-变量" class="headerlink" title="JS 变量"></a>JS 变量</h3><ul><li>变量是用于存放数据的容器；</li><li>我们通过 变量名 获取数据、修改数据；</li><li>变量存储在内存中；<ul><li>本质：变量是程序在内存中申请的一块用来存放数据的空间；</li><li>变量名和变量：类似我们酒店的房间号和房间；</li></ul></li><li>变量的使用：<ul><li>变量的声明；</li><li>变量的赋值；</li></ul></li></ul><h3 id="JS-变量使用"><a href="#JS-变量使用" class="headerlink" title="JS 变量使用"></a>JS 变量使用</h3><p>变量声明</p><pre><code class="js">// 声明变量  var age;  // 声明一个 名称为age 的变量  </code></pre><p>变量赋值</p><pre><code class="js">age = 10;  // 给 age 这个变量赋值为 10          </code></pre><p>变量的初始化（声明一个变量并赋值）</p><pre><code class="js">var age  = 18;  // 声明变量同时赋值为 18// 声明一个变量并赋值， 我们称之为变量的初始化。</code></pre><ul><li>var 是一个 JS关键字，用来声明变量( variable 变量的意思 )；</li><li>使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管；</li><li>age 是我们自己定义的变量名，我们要通过变量名来访问内存中分配的空间；</li><li>= 用来把右边的值赋给左边的变量空间中   此处代表赋值的意思；</li><li>变量值是我们保存到变量空间里的值；</li></ul><p>更新变量</p><pre><code class="js">var age = 18;  // 声明变量同时赋值为 18age = 81;   // 最后的结果就是81 因为18 被覆盖掉了      </code></pre><p>同时声明多个变量</p><pre><code class="js">var age = 10, name = &#39;zs&#39;, sex = 2;       // 同时声明多个变量时，只需要写一个 var// 多个变量名之间使用英文逗号隔开</code></pre><p>特殊情况</p><table><thead><tr><th>情况</th><th>说明</th><th>结果</th></tr></thead><tbody><tr><td>var  age;   console.log (age);</td><td>只声明 不赋值</td><td>undefined</td></tr><tr><td>console.log(age);</td><td>不声明 不赋值  直接使用</td><td>报错</td></tr><tr><td>age = 10;   console.log (age);</td><td>不声明   只赋值</td><td>10</td></tr></tbody></table><h3 id="JS-变量命名规范"><a href="#JS-变量命名规范" class="headerlink" title="JS 变量命名规范"></a>JS 变量命名规范</h3><ul><li>由字母( A-Za-z )、数字( 0-9 )、下划线( _ )、美元符号( $ )组成，如：usrAge, num01, _name；</li><li>严格区分大小写。var app; 和 var App; 是两个变量；</li><li>不能 以数字开头。  18age   是错误的；</li><li>不能 是关键字、保留字。例如：var、for、while；</li><li>变量名必须有意义。 MMD   BBD        nl   →     age  ；</li><li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName；</li></ul><h2 id="数字型-Number"><a href="#数字型-Number" class="headerlink" title="数字型 Number"></a>数字型 Number</h2><pre><code class="js">var age = 21;       // 整数var Age = 21.3747;  // 小数   </code></pre><ul><li><p>JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）；</p></li><li><p>最常见的进制有二进制、八进制、十进制、十六进制；</p></li><li><p>八进制前面加0，十六进制前面加 0x；</p></li><li><p>JavaScript中数值的最大值和最小值：</p><ul><li>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308；</li><li>最小值：Number.MIN_VALUE，这个值为：5e-32；</li></ul></li><li><p>数字型三个特殊值：</p><ul><li>Infinity ，代表无穷大，大于任何数值；</li><li>-Infinity ，代表无穷小，小于任何数值；</li><li>NaN ，Not a number，代表一个非数值；</li></ul></li><li><p>isNaN：</p><ul><li>用来判断一个变量是否为非数字的类型，返回 true 或者 false；</li><li>非数字类型，才返回 true；</li></ul></li></ul><pre><code class="js">var usrAge = 21;console.log(isNaN(userAge));   // false ，21 不是一个非数字var usrName = &quot;andy&quot;;console.log(isNaN(userName));   // true ，&quot;andy&quot;是一个非数字</code></pre><h2 id="字符串型-String"><a href="#字符串型-String" class="headerlink" title="字符串型 String"></a>字符串型 String</h2><h3 id="字符串写法"><a href="#字符串写法" class="headerlink" title="字符串写法"></a>字符串写法</h3><pre><code class="js">var strMsg = &quot;半竹博客&quot;;   // 使用双引号表示字符串var strMsg2 = &#39;半竹博客~&#39;;   // 使用单引号表示字符串// 常见错误// 没使用引号，会被认为是js代码，但js没有这些语法var strMsg3 = 半竹博客;   // 报错</code></pre><ul><li>字符串型可以是引号中的任意文本，其语法为 双引号 <code>&quot; text &quot;</code> 和 单引号 <code>&#39; text &#39;</code>；</li><li>因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号；</li><li>JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)；</li></ul><pre><code class="js">var strMsg = &#39;我是&quot;半竹&quot;博客&#39;;   // 可以用&#39;&#39;包含&quot;&quot;var strMsg2 = &quot;我是&#39;半竹&#39;博客&quot;;   // 也可以用&quot;&quot; 包含&#39;&#39;//  常见错误var badQuotes = &#39;半竹博客&quot;;   // 报错，不能 单双引号搭配</code></pre><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><ul><li>类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。</li><li>转义符都是 \ 开头的，常用的转义符及其说明如下：</li></ul><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n   是   newline   的意思</td></tr><tr><td>\ \</td><td>斜杠   \</td></tr><tr><td>&#39;</td><td>‘   单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab  缩进</td></tr><tr><td>\b</td><td>空格 ，b   是   blank  的意思</td></tr></tbody></table><h3 id="字符串长度-length"><a href="#字符串长度-length" class="headerlink" title="字符串长度 length"></a>字符串长度 length</h3><pre><code class="js">var strMsg = &quot;半竹博客&quot;;alert(strMsg.length);   // 4</code></pre><h3 id="字符串“-”-加号拼接"><a href="#字符串“-”-加号拼接" class="headerlink" title="字符串“ +” 加号拼接"></a>字符串“ +” 加号拼接</h3><pre><code class="js">// 1.1 字符串 &quot;相加&quot;alert(&#39;hello&#39; + &#39; &#39; + &#39;world&#39;);   // hello world// 1.2 数值字符串 &quot;相加&quot;alert(&#39;100&#39; + &#39;100&#39;);   // 100100// 1.3 数值字符串 + 数值alert(&#39;11&#39; + 12);   // 1112 // 只要有字符就会相连 console.log(&#39;pink老师&#39; + 18);// 字符串连接变量var age = 10;console.log(&#39;半竹博客age岁啦&#39;);      // 这样不行哦，半竹博客age岁啦console.log(&#39;半竹博客&#39; + age);         // 半竹博客10console.log(&#39;半竹博客&#39; + age + &#39;岁啦&#39;); // 半竹博客10岁啦</code></pre><ul><li>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串；</li><li>加号 <code>+</code> 口诀：数值相加 ，字符相连；</li><li>可以将字符串和变量来拼接，变量可以很方便地修改里面的值；</li><li>变量两侧都有字符串拼接，口诀“引引加加 ”，变量写两个加号中间；</li></ul><h2 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h2><ul><li>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）；</li><li>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0；</li></ul><pre><code class="js">console.log(true + 1);  // 2console.log(false + 1); // 1</code></pre><h3 id="Undefined-和-Null："><a href="#Undefined-和-Null：" class="headerlink" title="Undefined 和 Null："></a>Undefined 和 Null：</h3><ul><li>一个声明后没有被赋值的变量会有一个默认值 undefined；</li><li>如果进行相连或者相加时，要注意结果；</li></ul><pre><code class="js">var variable;   // 声明后没有被赋值的变量console.log(variable);           // undefinedconsole.log(&#39;你好&#39; + variable);  // 你好undefinedconsole.log(11 + variable);     // NaNconsole.log(true + variable);   //  NaN</code></pre><ul><li>一个声明变量给 null 值，里面存的值为空；</li></ul><pre><code class="js">var vari = null;   // 声明变量给 null 值console.log(&#39;你好&#39; + vari);  // 你好nullconsole.log(11 + vari);     // 11console.log(true + vari);   //  1</code></pre><h2 id="JavaScript-简单数据类型"><a href="#JavaScript-简单数据类型" class="headerlink" title="JavaScript 简单数据类型"></a>JavaScript 简单数据类型</h2><h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><p><img src="http://mdimg.95408.com/202001052353_857.png?null" alt="简单数据类型"></p><h3 id="获取数据类型-typeof"><a href="#获取数据类型-typeof" class="headerlink" title="获取数据类型 typeof"></a>获取数据类型 typeof</h3><pre><code class="js">var num = 18;console.log(typeof num)   // 结果 number      </code></pre><p><strong>typeof：</strong></p><ul><li>typeof 可用来获取检测变量的数据类型</li></ul><p><img src="http://mdimg.95408.com/202001060020_89.png?null" alt="不同类型的返回值"></p><p><strong>字面量：</strong></p><ul><li>字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值；</li><li>数字字面量：8, 9, 10</li><li>字符串字面量：’半竹博客’, “大半竹”</li><li>布尔字面量：true，false</li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>把一种数据类型的变量转换成另一种数据类型；</li><li>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型；</li><li>通常会实现3种方式的转换：<ul><li>转换为字符串类型</li><li>转换为数字型</li><li>转换为布尔型</li></ul></li></ul><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><ul><li>toString() 和 String()  使用方式不一样</li><li>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换</li></ul><p><img src="http://mdimg.95408.com/202001060025_59.png?null" alt="转换为字符串"></p><h4 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h4><ul><li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li><li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li></ul><p><img src="http://mdimg.95408.com/202001060026_540.png?null" alt="转换为数字型"></p><h4 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h4><ul><li>代表空、否定的值会被转换为 false  ，如 ‘’、0、NaN、null、undefined  </li><li>其余值都会被转换为 true</li></ul><p><img src="http://mdimg.95408.com/202001060027_847.png?null" alt="转换为布尔型*"></p><pre><code class="js">console.log(Boolean(&#39;&#39;)); // falseconsole.log(Boolean(0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean(&#39;半竹&#39;)); // trueconsole.log(Boolean(12)); // true</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（九）代码规范</title>
      <link href="/2020/01/03/css/html+css%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2020/01/03/css/html+css%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="1-代码规范概述"><a href="#1-代码规范概述" class="headerlink" title="1. 代码规范概述"></a>1. 代码规范概述</h2><p>以下规范是团队基本约定的内容，必须严格遵循。</p><h3 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h3><p>基于 <a href="http://www.w3.org/" target="_blank" rel="noopener">W3C</a>、<a href="https://developer.apple.com/" target="_blank" rel="noopener">苹果开发者</a> 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p><h3 id="图片规范"><a href="#图片规范" class="headerlink" title="图片规范"></a>图片规范</h3><p>了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p><h3 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h3><p>统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p><p>###命名规范</p><p>从 <code>目录</code>、<code>图片</code>、<code>HTML/CSS文件</code>、<code>ClassName</code> 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p><h2 id="2-HTML-规范"><a href="#2-HTML-规范" class="headerlink" title="2. HTML 规范"></a>2. HTML 规范</h2><h3 id="DOCTYPE-声明"><a href="#DOCTYPE-声明" class="headerlink" title="DOCTYPE 声明"></a>DOCTYPE 声明</h3><p>HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明：</p><pre><code class="html">&lt;!DOCTYPE html&gt;</code></pre><p><strong>HTML5标准模版</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;  &lt;html lang=&quot;zh-CN&quot;&gt;  &lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;HTML5标准模版&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="页面语言lang"><a href="#页面语言lang" class="headerlink" title="页面语言lang"></a>页面语言lang</h3><p>推荐使用属性值 <code>cmn-Hans-CN</code>（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 <code>zh-CN</code> 属性值</p><pre><code>&lt;html lang=&quot;zh-CN&quot;&gt;</code></pre><p>更多地区语言参考：</p><pre><code>zh-SG 中文 (简体, 新加坡)   对应 cmn-Hans-SG 普通话 (简体, 新加坡)zh-HK 中文 (繁体, 香港)     对应 cmn-Hant-HK 普通话 (繁体, 香港)zh-MO 中文 (繁体, 澳门)     对应 cmn-Hant-MO 普通话 (繁体, 澳门)zh-TW 中文 (繁体, 台湾)     对应 cmn-Hant-TW 普通话 (繁体, 台湾)</code></pre><h3 id="charset-字符集合"><a href="#charset-字符集合" class="headerlink" title="charset 字符集合"></a>charset 字符集合</h3><p>一般情况下统一使用 “UTF-8” 编码</p><pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><p>由于历史原因，有些业务可能会使用 “GBK” 编码</p><pre><code>&lt;meta charset=&quot;GBK&quot;&gt;</code></pre><p>请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 <a href="http://www.ietf.org/rfc/rfc3629" target="_blank" rel="noopener">IETF对UTF-8的定义</a>，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。</p><h3 id="书写风格"><a href="#书写风格" class="headerlink" title="书写风格"></a>书写风格</h3><p><strong>HTML代码大小写</strong></p><p>HTML标签名、类名、标签属性和大部分属性值统一用小写</p><p><em>推荐：</em></p><pre><code>&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;</code></pre><p><em>不推荐：</em></p><pre><code>&lt;div class=&quot;DEMO&quot;&gt;&lt;/div&gt;&lt;DIV CLASS=&quot;DEMO&quot;&gt;&lt;/DIV&gt;</code></pre><h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含</p><p><em>推荐：</em></p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; &gt;&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></pre><p><em>不推荐：</em></p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot; &gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;</code></pre><h3 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h3><ul><li>元素属性值使用双引号语法</li><li>元素属性值可以写上的都写上</li></ul><p><em>推荐：</em></p><pre><code>&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; &gt;</code></pre><p><em>不推荐：</em></p><pre><code>&lt;input type=text&gt;    &lt;input type=&#39;text&#39;&gt;&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked &gt;</code></pre><h3 id="特殊字符引用"><a href="#特殊字符引用" class="headerlink" title="特殊字符引用"></a>特殊字符引用</h3><p>文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。</p><p>在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</p><p><em>推荐：</em></p><pre><code>&lt;a href=&quot;#&quot;&gt;more&amp;gt;&amp;gt;&lt;/a&gt;</code></pre><p><em>不推荐：</em></p><pre><code>&lt;a href=&quot;#&quot;&gt;more&gt;&gt;&lt;/a&gt;</code></pre><h3 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p><pre><code>&lt;div class=&quot;jdc&quot;&gt;    &lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/div&gt;</code></pre><h3 id="代码嵌套"><a href="#代码嵌套" class="headerlink" title="代码嵌套"></a>代码嵌套</h3><p>元素嵌套规范，每个块状元素独立一行，内联元素可选</p><p><em>推荐：</em></p><pre><code>&lt;div&gt;    &lt;h1&gt;&lt;/h1&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</code></pre><p><em>不推荐：</em></p><pre><code>&lt;div&gt;    &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;    &lt;p&gt;     &lt;span&gt;&lt;/span&gt;    &lt;span&gt;&lt;/span&gt;&lt;/p&gt;</code></pre><p>段落元素与标题元素只能嵌套内联元素</p><p><em>推荐：</em></p><pre><code>&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;</code></pre><p><em>不推荐：</em></p><pre><code>&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;</code></pre><h2 id="3-图片规范"><a href="#3-图片规范" class="headerlink" title="3. 图片规范"></a>3. 图片规范</h2><h3 id="内容图"><a href="#内容图" class="headerlink" title="内容图"></a>内容图</h3><p>内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大</p><ul><li>优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式</li><li>尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大</li><li><strong>PC平台单张的图片的大小不应大于 200KB。</strong></li></ul><h3 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h3><p>背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片</p><ul><li>PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率</li><li>图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式</li><li>图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式</li><li>图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式</li><li>条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式</li></ul><h2 id="4-CSS规范"><a href="#4-CSS规范" class="headerlink" title="4. CSS规范"></a>4. CSS规范</h2><h3 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h3><p>样式书写一般有两种：一种是紧凑格式 (Compact)</p><pre><code>.jdc{ display: block;width: 50px;}</code></pre><p>一种是展开格式（Expanded）</p><pre><code>.jdc {    display: block;    width: 50px;}</code></pre><p><strong>团队约定</strong></p><p>统一使用展开格式书写样式</p><h3 id="代码大小写"><a href="#代码大小写" class="headerlink" title="代码大小写"></a>代码大小写</h3><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p><pre><code>/* 推荐 */.jdc{    display:block;}/* 不推荐 */.JDC{    DISPLAY:BLOCK;}</code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>尽量少用通用选择器 <code>*</code></li><li>不使用 ID 选择器</li><li>不使用无具体语义定义的标签选择器</li></ul><pre><code class="css">/* 推荐 */.jdc {}.jdc li {}.jdc li p{}/* 不推荐 */*{}#jdc {}.jdc div{}</code></pre><h3 id="代码缩进-1"><a href="#代码缩进-1" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）</p><pre><code>.jdc {    width: 100%;    height: 100%;}</code></pre><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>每个属性声明末尾都要加分号；</p><pre><code>.jdc {    width: 100%;    height: 100%;}</code></pre><h3 id="代码易读性"><a href="#代码易读性" class="headerlink" title="代码易读性"></a>代码易读性</h3><p>左括号与类名之间一个空格，冒号与属性值之间一个空格</p><p><em>推荐：</em></p><pre><code>.jdc {     width: 100%; }</code></pre><p><em>不推荐：</em></p><pre><code>.jdc{     width:100%;}</code></pre><p>逗号分隔的取值，逗号之后一个空格</p><p><em>推荐：</em></p><pre><code>.jdc {    box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;}</code></pre><p><em>不推荐：</em></p><pre><code>.jdc {    box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;}</code></pre><p>为单个css选择器或新申明开启新行</p><p><em>推荐：</em></p><pre><code class="css">.jdc, .jdc_logo, .jdc_hd {    color: #ff0;}.nav{    color: #fff;}</code></pre><p><em>不推荐：</em></p><pre><code class="css">.jdc,jdc_logo,.jdc_hd {    color: #ff0;}.nav{    color: #fff;}</code></pre><p>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0</p><p><em>推荐：</em></p><pre><code>.jdc {    color: rgba(255,255,255,.5);}</code></pre><p><em>不推荐：</em></p><pre><code>.jdc {    color: rgba( 255, 255, 255, 0.5 );}</code></pre><p>属性值十六进制数值能用简写的尽量用简写</p><p><em>推荐：</em></p><pre><code>.jdc {    color: #fff;}</code></pre><p><em>不推荐：</em></p><pre><code class="css">.jdc {    color: #ffffff;}</code></pre><p>不要为 <code>0</code> 指明单位</p><p><em>推荐：</em></p><pre><code class="css">.jdc {    margin: 0 10px;}</code></pre><p><em>不推荐：</em></p><pre><code class="css">.jdc {    margin: 0px 10px;}</code></pre><h3 id="属性值引号"><a href="#属性值引号" class="headerlink" title="属性值引号"></a>属性值引号</h3><p>css属性值需要用到引号时，统一使用单引号</p><pre><code class="css">/* 推荐 */.jdc {     font-family: &#39;Hiragino Sans GB&#39;;}/* 不推荐 */.jdc {     font-family: &quot;Hiragino Sans GB&quot;;}</code></pre><h3 id="属性书写顺序"><a href="#属性书写顺序" class="headerlink" title="属性书写顺序"></a>属性书写顺序</h3><p>建议遵循以下顺序：</p><ol><li>布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）</li><li>自身属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li></ol><pre><code class="css">.jdc {    display: block;    position: relative;    float: left;    width: 100px;    height: 100px;    margin: 0 10px;    padding: 20px 0;    font-family: Arial, &#39;Helvetica Neue&#39;, Helvetica, sans-serif;    color: #333;    background: rgba(0,0,0,.5);    -webkit-border-radius: 10px;    -moz-border-radius: 10px;    -o-border-radius: 10px;    -ms-border-radius: 10px;    border-radius: 10px;}</code></pre><p><a href="https://www.mozilla.org/css/base/content.css" target="_blank" rel="noopener">mozilla官方属性顺序推荐</a></p><h2 id="5-命名规范"><a href="#5-命名规范" class="headerlink" title="5. 命名规范"></a>5. 命名规范</h2><p>由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。</p><h3 id="目录命名"><a href="#目录命名" class="headerlink" title="目录命名"></a>目录命名</h3><ul><li>项目文件夹：</li><li>样式文件夹：css</li><li>脚本文件夹：js</li><li>样式类图片文件夹：img</li><li>产品类图片文件夹： upload</li><li>字体类文件夹： fonts</li></ul><h3 id="ClassName命名"><a href="#ClassName命名" class="headerlink" title="ClassName命名"></a>ClassName命名</h3><p>ClassName的命名应该尽量精短、明确，必须以<strong>字母开头命名</strong>，且<strong>全部字母为小写</strong>，单词之间<strong>统一使用下划线</strong> “_” 连接</p><p>.nav_top</p><h2 id="6-常用命名推荐"><a href="#6-常用命名推荐" class="headerlink" title="6. 常用命名推荐"></a>6. 常用命名推荐</h2><p><strong>注意</strong>：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此</p><pre><code>&lt;div class=&quot;ad&quot;&gt;&lt;/div&gt;</code></pre><p>这种广告的英文或拼音类名不应该出现</p><p>另外，<strong>敏感不和谐字眼</strong>也不应该出现，如：</p><pre><code>&lt;div class=&quot;fuck&quot;&gt;&lt;/div&gt;&lt;div class=&quot;jer&quot;&gt;&lt;/div&gt;&lt;div class=&quot;sm&quot;&gt;&lt;/div&gt;&lt;div class=&quot;gcd&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ass&quot;&gt;&lt;/div&gt; &lt;div class=&quot;KMT&quot;&gt;&lt;/div&gt; ...</code></pre><table><thead><tr><th>ClassName</th><th>含义</th></tr></thead><tbody><tr><td>about</td><td>关于</td></tr><tr><td>account</td><td>账户</td></tr><tr><td>arrow</td><td>箭头图标</td></tr><tr><td>article</td><td>文章</td></tr><tr><td>aside</td><td>边栏</td></tr><tr><td>audio</td><td>音频</td></tr><tr><td>avatar</td><td>头像</td></tr><tr><td>bg,background</td><td>背景</td></tr><tr><td>bar</td><td>栏（工具类）</td></tr><tr><td>branding</td><td>品牌化</td></tr><tr><td>crumb,breadcrumbs</td><td>面包屑</td></tr><tr><td>btn,button</td><td>按钮</td></tr><tr><td>caption</td><td>标题，说明</td></tr><tr><td>category</td><td>分类</td></tr><tr><td>chart</td><td>图表</td></tr><tr><td>clearfix</td><td>清除浮动</td></tr><tr><td>close</td><td>关闭</td></tr><tr><td>col,column</td><td>列</td></tr><tr><td>comment</td><td>评论</td></tr><tr><td>community</td><td>社区</td></tr><tr><td>container</td><td>容器</td></tr><tr><td>content</td><td>内容</td></tr><tr><td>copyright</td><td>版权</td></tr><tr><td>current</td><td>当前态，选中态</td></tr><tr><td>default</td><td>默认</td></tr><tr><td>description</td><td>描述</td></tr><tr><td>details</td><td>细节</td></tr><tr><td>disabled</td><td>不可用</td></tr><tr><td>entry</td><td>文章，博文</td></tr><tr><td>error</td><td>错误</td></tr><tr><td>even</td><td>偶数，常用于多行列表或表格中</td></tr><tr><td>fail</td><td>失败（提示）</td></tr><tr><td>feature</td><td>专题</td></tr><tr><td>fewer</td><td>收起</td></tr><tr><td>field</td><td>用于表单的输入区域</td></tr><tr><td>figure</td><td>图</td></tr><tr><td>filter</td><td>筛选</td></tr><tr><td>first</td><td>第一个，常用于列表中</td></tr><tr><td>footer</td><td>页脚</td></tr><tr><td>forum</td><td>论坛</td></tr><tr><td>gallery</td><td>画廊</td></tr><tr><td>group</td><td>模块，清除浮动</td></tr><tr><td>header</td><td>页头</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>hide</td><td>隐藏</td></tr><tr><td>hightlight</td><td>高亮</td></tr><tr><td>home</td><td>主页</td></tr><tr><td>icon</td><td>图标</td></tr><tr><td>info,information</td><td>信息</td></tr><tr><td>last</td><td>最后一个，常用于列表中</td></tr><tr><td>links</td><td>链接</td></tr><tr><td>login</td><td>登录</td></tr><tr><td>logout</td><td>退出</td></tr><tr><td>logo</td><td>标志</td></tr><tr><td>main</td><td>主体</td></tr><tr><td>menu</td><td>菜单</td></tr><tr><td>meta</td><td>作者、更新时间等信息栏，一般位于标题之下</td></tr><tr><td>module</td><td>模块</td></tr><tr><td>more</td><td>更多（展开）</td></tr><tr><td>msg,message</td><td>消息</td></tr><tr><td>nav,navigation</td><td>导航</td></tr><tr><td>next</td><td>下一页</td></tr><tr><td>nub</td><td>小块</td></tr><tr><td>odd</td><td>奇数，常用于多行列表或表格中</td></tr><tr><td>off</td><td>鼠标离开</td></tr><tr><td>on</td><td>鼠标移过</td></tr><tr><td>output</td><td>输出</td></tr><tr><td>pagination</td><td>分页</td></tr><tr><td>pop,popup</td><td>弹窗</td></tr><tr><td>preview</td><td>预览</td></tr><tr><td>previous</td><td>上一页</td></tr><tr><td>primary</td><td>主要</td></tr><tr><td>progress</td><td>进度条</td></tr><tr><td>promotion</td><td>促销</td></tr><tr><td>rcommd,recommendations</td><td>推荐</td></tr><tr><td>reg,register</td><td>注册</td></tr><tr><td>save</td><td>保存</td></tr><tr><td>search</td><td>搜索</td></tr><tr><td>secondary</td><td>次要</td></tr><tr><td>section</td><td>区块</td></tr><tr><td>selected</td><td>已选</td></tr><tr><td>share</td><td>分享</td></tr><tr><td>show</td><td>显示</td></tr><tr><td>sidebar</td><td>边栏，侧栏</td></tr><tr><td>slide</td><td>幻灯片，图片切换</td></tr><tr><td>sort</td><td>排序</td></tr><tr><td>sub</td><td>次级的，子级的</td></tr><tr><td>submit</td><td>提交</td></tr><tr><td>subscribe</td><td>订阅</td></tr><tr><td>subtitle</td><td>副标题</td></tr><tr><td>success</td><td>成功（提示）</td></tr><tr><td>summary</td><td>摘要</td></tr><tr><td>tab</td><td>标签页</td></tr><tr><td>table</td><td>表格</td></tr><tr><td>txt,text</td><td>文本</td></tr><tr><td>thumbnail</td><td>缩略图</td></tr><tr><td>time</td><td>时间</td></tr><tr><td>tips</td><td>提示</td></tr><tr><td>title</td><td>标题</td></tr><tr><td>video</td><td>视频</td></tr><tr><td>wrap</td><td>容器，包，一般用于最外层</td></tr><tr><td>wrapper</td><td>容器，包，一般用于最外层</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《HTML和CSS进阶教程》笔记（一）</title>
      <link href="/2020/01/02/css/HTML%E5%92%8CCSS%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/02/css/HTML%E5%92%8CCSS%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS优先级与样式冲突"><a href="#CSS优先级与样式冲突" class="headerlink" title="CSS优先级与样式冲突"></a>CSS优先级与样式冲突</h2><p>3.3.3 指定样式冲突</p><p>所谓的指定样式，指的是指定“当前元素”的样式。当直接指定的样式发生冲突时，样式权值高者获胜。</p><p><img src="http://mdimg.95408.com/202001022223_461.png?null" alt=""></p><p><code>! important</code></p><ul><li>在CSS中，我们可以使用！important规则来改变样式的优先级。如果一个样式使用!important来声明，则这个样式会覆盖CSS中任何的其他样式声明。</li><li>例子：有人在jQuery插件中写了糟糕的行内样式（行内样式优先级往往是最高的），而你需要在CSS文件中修改这些样式，可以使用! important来覆盖那些行内样式。</li><li>如果在同一样式中出现了多个！important，则遵循后来者居上原则。</li></ul><p>伪元素：常见的伪元素只有四个：即 <code>::before</code>、<code>::after</code>、<code>::first-letter</code>、<code>::first-line</code>。</p><p>伪类：伪类我们经常见到，如：<code>hover</code>、<code>:first-child</code> 等。</p><blockquote><p>  有权重问题，按权重大小；权重相同，按代码优先；</p></blockquote><p>选择器权重的计算只针对指定样式（当前元素），并不能用于继承样式；</p><pre><code class="html">&lt;style&gt;    .aaa #bbb {        color:blue;    }    .aaa p {        color: red;    }&lt;/style&gt;&lt;div class=&quot;aaa&quot;&gt;    &lt;div id=&quot;bbb&quot;&gt;        &lt;p&gt;文字仍是红色&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>如上：虽然蓝色样式的权重非常高，但仍然使用的是红色，因为：</p><ul><li>所谓的指定样式冲突，指的是“当前元素”的样式发生冲突；</li><li>在这个例子中，我们所针对的当前元素是 p ，然而“.aaa #bbb”针对的元素是 p 的祖先元素，并不是 p；</li></ul><p>对于CSS优先级，主要就是以下两个黄金定律。</p><ul><li>（1）优先级高的样式覆盖优先级低的样式。</li><li>（2）同一优先级的样式，后定义的覆盖先定义的，即后来者居上。</li></ul><h2 id="兄弟选择器与相邻选择器"><a href="#兄弟选择器与相邻选择器" class="headerlink" title="兄弟选择器与相邻选择器"></a>兄弟选择器与相邻选择器</h2><p><strong>层次选择器</strong></p><p>常见的层次关系包括：父子、后代、兄弟和相邻。</p><p><img src="http://mdimg.95408.com/202001022305_27.png?null" alt=""></p><p><strong>兄弟选择器</strong></p><p>就是选中元素后面（不包括前面）的某一类兄弟元素。</p><p><strong>相邻选择器</strong></p><p>相邻选择器，就是选中元素后面（不包括前面）的某一个“相邻”的兄弟元素。相邻选择器跟兄弟选择器也非常相似，不过也有明显的区别。</p><p>（1）兄弟选择器选取元素后面“所有”的某一类元素。</p><p>（2）相邻选择器选取元素后面“相邻”的某一个元素。</p><h2 id="相邻选择器的妙用"><a href="#相邻选择器的妙用" class="headerlink" title="相邻选择器的妙用"></a>相邻选择器的妙用</h2><p>“li+li”使用的是相邻选择器，表示“选择li元素相邻的下一个li元素”。由于最后一个li元素没有相邻的下一个li元素，所以对于最后一个li元素，它是没有下一个li元素可以选取的。“li+li{border-top:2px solid red; }”达到在两个li元素之间添加一个边框的效果。</p><p>这是一个非常棒的技巧，在实际开发中如果我们想要在两个元素之间实现什么效果（border、margin等），我们会经常用到这个技巧！</p><p><img src="http://mdimg.95408.com/202001022326_629.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    li {        float: left;        font-size: 18px;        padding: 0 20px;        list-style: none;    }    li+li {        border-left: 1px solid #000;    }&lt;/style&gt;&lt;ul&gt;    &lt;li&gt;aaa&lt;/li&gt;    &lt;li&gt;aaa&lt;/li&gt;    &lt;li&gt;aaa&lt;/li&gt;    &lt;li&gt;aaa&lt;/li&gt;    &lt;li&gt;aaa&lt;/li&gt;    &lt;li&gt;aaa&lt;/li&gt;&lt;/ul&gt;</code></pre><h2 id="class命名参考"><a href="#class命名参考" class="headerlink" title="class命名参考"></a>class命名参考</h2><h3 id="网页主体部分命名"><a href="#网页主体部分命名" class="headerlink" title="网页主体部分命名"></a>网页主体部分命名</h3><p><img src="http://mdimg.95408.com/202001022342_442.png?null" alt=""></p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p><img src="http://mdimg.95408.com/202001022343_959.png?null" alt=""></p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p><img src="http://mdimg.95408.com/202001022343_855.png?null" alt=""></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="http://mdimg.95408.com/202001022344_497.png?null" alt=""></p><h3 id="CSS文件命名"><a href="#CSS文件命名" class="headerlink" title="CSS文件命名"></a>CSS文件命名</h3><p><img src="http://mdimg.95408.com/202001022346_301.png?null" alt=""></p><h2 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h2><p><img src="http://mdimg.95408.com/202001022347_593.png?null" alt=""></p><p>把影响元素页面布局的样式（如float、margin、padding、height、width等）排到前面，而把不影响布局的样式（如background、color、font等）排到后面。这种主次分明的排列方式，极大地提高了代码的可阅读性和可维护性。</p><p>注意：功能代码块还是应该放在一起；</p><p>对于单行文本居中、块元素居中等具有某一个特殊功能的代码块，我们就不应该那么呆板了。因为功能代码往往是用多个CSS属性来实现的，此时如果也按照表4-6的书写顺序来的话，这些功能代码就会被打乱，并且难以维护。因此，对于功能代码，我们应该集中放在一块。</p><h2 id="CSS-reset"><a href="#CSS-reset" class="headerlink" title="CSS reset"></a>CSS reset</h2><p>来源：<a href="https://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">https://meyerweb.com/eric/tools/css/reset/</a></p><pre><code class="css">/* http://meyerweb.com/eric/tools/css/reset/    v2.0 | 20110126   License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video {    margin: 0;    padding: 0;    border: 0;    font-size: 100%;    font: inherit;    vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section {    display: block;}body {    line-height: 1;}ol, ul {    list-style: none;}blockquote, q {    quotes: none;}blockquote:before, blockquote:after,q:before, q:after {    content: &#39;&#39;;    content: none;}table {    border-collapse: collapse;    border-spacing: 0;}</code></pre><p>Eric Meyer建议此CSS reset代码是应该根据个人需求不同来定义，例如有的页面不会用到address、code元素，直接把这两个元素剔除即可。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（八）CSS高级技术</title>
      <link href="/2020/01/02/css/html+css%EF%BC%88%E5%85%AB%EF%BC%89CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/01/02/css/html+css%EF%BC%88%E5%85%AB%EF%BC%89CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="字体图标-icomoon"><a href="#字体图标-icomoon" class="headerlink" title="字体图标 icomoon"></a>字体图标 icomoon</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li>设计保存为svg格式，上传后生成自己的图标；</li><li>使用网站上通用的字体图标；</li><li>网站：<ul><li>icomoon字库：<a href="http://icomoon.io" target="_blank" rel="noopener">http://icomoon.io</a></li><li>阿里iconfont字库：<a href="http://www.iconfont.cn" target="_blank" rel="noopener">http://www.iconfont.cn</a></li></ul></li><li>选中需要的图标，Generate Font 生成、Download 下载图标；（图一）</li><li>得到 icomoon.zip 压缩包：<ul><li>将其中的 fonts 文件夹放入到项目目录；</li><li>selection.json 更新字体文件时上传使用；</li><li>查看 demo.html 中的字体效果，制作下方的样式到工作中即可；（图二）</li></ul></li><li>更新：<ul><li>将下载压缩包中的 selection.json 重新 Impoft Icons 导入网站；（图三）</li><li>再增减图标后，生成、下载、替换原有文件；</li></ul></li></ul><p><img src="http://mdimg.95408.com/202001031809_213.png?null" alt="图一）"></p><p><img src="http://mdimg.95408.com/202001031815_893.png?null" alt="图二"></p><p><img src="http://mdimg.95408.com/202001031820_587.png?null" alt="图三"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>首先把 fonts文件夹放入我们 根目录下 ;</li><li>html标签内里面添加结构；（这里的符号不能正常显示，复制下载的demo文件）</li></ul><pre><code class="html">&lt;span&gt;  &lt;/span&gt;&lt;div&gt;  &lt;/div&gt;&lt;strong&gt;  &lt;/strong&gt;</code></pre><ul><li>在CSS样式里面声明字体： 告诉别人我们自己定义的字体(一定注意字体文件路径的问题)；</li></ul><pre><code class="css">@font-face {    /* 字体名称 */    font-family: &#39;icomoon&#39;;    /* 要注意路径的问题 */    src:  url(&#39;fonts/icomoon.eot?7kkyc2&#39;);    src:  url(&#39;fonts/icomoon.eot?7kkyc2#iefix&#39;) format(&#39;embedded-opentype&#39;),        url(&#39;fonts/icomoon.ttf?7kkyc2&#39;) format(&#39;truetype&#39;),        url(&#39;fonts/icomoon.woff?7kkyc2&#39;) format(&#39;woff&#39;),        url(&#39;fonts/icomoon.svg?7kkyc2#icomoon&#39;) format(&#39;svg&#39;);    font-weight: normal;    font-style: normal;}</code></pre><ul><li>针对单个例子写样式，使用字体；</li></ul><pre><code class="css">span, div, strong {    /* 声明前一步定义的字体 */    font-family: &#39;icomoon&#39;;    /* 可以改大小颜色等等 */    font-size: 50px;    color: red;}</code></pre><h2 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h2><p>建议遵循以下顺序：</p><ul><li>布局定位属性：<ul><li>display / position / float / clear / visibility / overflow</li><li>建议 display 第一个写，毕竟关系到模式</li></ul></li><li>自身属性：<ul><li>width / height / margin / padding / border / background</li></ul></li><li>文本属性：<ul><li>color / font / text-decoration / text-align / vertical-align / white- space / break-word</li></ul></li><li>其他属性（CSS3）：<ul><li>content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li></ul></li></ul><pre><code class="css">.bamboo {    display: block;    position: relative;    float: left;    width: 100px;    height: 100px;    margin: 0 10px;    padding: 20px 0;    font-family: Arial, &#39;Helvetica Neue&#39;, Helvetica, sans-serif;    color: #333;    background: rgba(0,0,0,.5);    -webkit-border-radius: 10px;    -moz-border-radius: 10px;    -o-border-radius: 10px;    -ms-border-radius: 10px;    border-radius: 10px;}</code></pre><h2 id="显示与隐藏"><a href="#显示与隐藏" class="headerlink" title="显示与隐藏"></a>显示与隐藏</h2><h3 id="display-显示"><a href="#display-显示" class="headerlink" title="display 显示"></a>display 显示</h3><ul><li>display 设置或检索对象是否及如何显示；<ul><li><code>display: none</code> 隐藏对象；</li><li><code>display：block</code> 除了转换为块级元素之外，同时还有显示元素的意思；</li></ul></li><li>特点： 隐藏之后，不再保留位置；</li><li>配合 js 做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛；</li></ul><h3 id="visibility-可见性"><a href="#visibility-可见性" class="headerlink" title="visibility 可见性"></a>visibility 可见性</h3><ul><li>设置或检索是否显示对象；<ul><li><code>visibility：visible ;</code>　对象可视</li><li><code>visibility：hidden;</code>　  对象隐藏</li></ul></li><li>特点： 隐藏之后，继续保留原有位置；</li></ul><blockquote><p>  左：两个盒子正常流；</p><p>  中：pink色盒子隐藏 <code>display: none</code> ：不占位置；</p><p>  右：pink色盒子隐藏 <code>visibility：hidden;</code> ，占位置；</p></blockquote><p><img src="http://mdimg.95408.com/202001022021_130.png?null" alt=""></p><pre><code class="css">/* 左图 */.pink-div {    width: 200px;    height: 200px;    background-color: pink;}/* 中图 */.pink-div {    /* 这里除了转换为块级元素以外，还可以 显示元素 */    /* display: block; */    /* 隐藏元素 */    display: none;    width: 200px;    height: 200px;    background-color: pink;}/* 右图 */.pink-div {    /* 默认：显示元素 */    /* visibility: visible; */    /* 隐藏元素 */    visibility: hidden;        width: 200px;    height: 200px;    background-color: pink;}</code></pre><h3 id="overflow-溢出"><a href="#overflow-溢出" class="headerlink" title="overflow 溢出"></a>overflow 溢出</h3><ul><li>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容；</li><li>实际开发场景：<ul><li>清除浮动</li><li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li></ul></li></ul><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>visible</strong></td><td>不剪切内容也不添加滚动条</td></tr><tr><td><strong>hidden</strong></td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td><strong>scroll</strong></td><td>不管超出内容否，总是显示滚动条</td></tr><tr><td><strong>auto</strong></td><td>超出自动显示滚动条，不超出不显示滚动条</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>属性</th><th>区别</th><th>用途</th></tr></thead><tbody><tr><td><strong>display</strong></td><td>隐藏对象，不保留位置</td><td>配合后面js做特效，比如下拉菜单</td></tr><tr><td><strong>visibility</strong></td><td>隐藏对象，保留位置</td><td>使用较少</td></tr><tr><td><strong>overflow</strong></td><td>只是隐藏超出大小的部分</td><td>1. 清除浮动 2. 保证盒子里内容不会超出盒子范围</td></tr></tbody></table><h2 id="用户界面样式"><a href="#用户界面样式" class="headerlink" title="用户界面样式"></a>用户界面样式</h2><p>界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验；</p><h3 id="鼠标样式-cursor"><a href="#鼠标样式-cursor" class="headerlink" title="鼠标样式 cursor"></a>鼠标样式 cursor</h3><p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>default</strong></td><td>小白  默认</td></tr><tr><td><strong>pointer</strong></td><td>小手</td></tr><tr><td><strong>move</strong></td><td>移动</td></tr><tr><td><strong>text</strong></td><td>文本</td></tr><tr><td><strong>not-allowed</strong></td><td>禁止</td></tr></tbody></table><pre><code class="html">&lt;ul&gt;  &lt;li style=&quot;cursor:default&quot;&gt;默认的&lt;/li&gt;  &lt;li style=&quot;cursor:pointer&quot;&gt;小手&lt;/li&gt;  &lt;li style=&quot;cursor:move&quot;&gt;移动&lt;/li&gt;  &lt;li style=&quot;cursor:text&quot;&gt;文本&lt;/li&gt;  &lt;li style=&quot;cursor:not-allowed&quot;&gt;禁止&lt;/li&gt;&lt;/ul&gt;</code></pre><p><img src="http://mdimg.95408.com/web_2020010202.gif" alt=""></p><h3 id="轮廓线-outline"><a href="#轮廓线-outline" class="headerlink" title="轮廓线 outline"></a>轮廓线 outline</h3><p>绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用；</p><p>我们写样式时，一般是去除outline：</p><pre><code class="css">input {    outline: none;        /* 或者 */    outline: 0;}</code></pre><blockquote><p>  上图：未取消轮廓线，下图：<code>outline: none;</code>：</p></blockquote><p><img src="http://mdimg.95408.com/web_2020010203.gif" alt=""></p><h3 id="防止拖拽文本域-resize"><a href="#防止拖拽文本域-resize" class="headerlink" title="防止拖拽文本域 resize"></a>防止拖拽文本域 resize</h3><ul><li>文件域 <code>textare</code> 可以拖拽右下角，放大缩小；</li><li>实际开发中，我们文本域右下角是不可以拖拽： </li></ul><pre><code class="css">textarea {    resize: none;}</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>属性</th><th>用途</th><th>用途</th></tr></thead><tbody><tr><td><strong>鼠标样式</strong></td><td>更改鼠标样式cursor</td><td>样式很多，重点记住 pointer</td></tr><tr><td><strong>轮廓线</strong></td><td>表单默认outline</td><td>outline 轮廓线，我们一般直接去掉</td></tr><tr><td><strong>防止拖拽</strong></td><td>主要针对文本域resize</td><td>防止用户随意拖拽文本域，造成页面布局混乱</td></tr></tbody></table><h2 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align 垂直对齐"></a>vertical-align 垂直对齐</h2><ul><li>有宽度的块级元素居中对齐，是 <code>margin: 0 auto;</code> ；</li><li>让文字居中对齐，是 <code>text-align: center;</code> ；</li><li>但是我们从来没有讲过有垂直居中的属性；</li><li>vertical-align 垂直对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>；</li></ul><pre><code class="css">vertical-align : baseline |top |middle |bottom </code></pre><ul><li>设置或检索对象内容的垂直对其方式；</li><li>vertical-align 不影响块级元素中的内容对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>；</li><li>特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>；</li></ul><h3 id="图片、表单和文字对齐"><a href="#图片、表单和文字对齐" class="headerlink" title="图片、表单和文字对齐"></a>图片、表单和文字对齐</h3><ul><li>可以通过vertical-align 控制图片和文字的垂直关系；</li><li>默认的图片会和文字基线对齐；</li></ul><blockquote><p>  图片与文字的对齐方式：默认为基线对齐（上）：</p></blockquote><p><img src="http://mdimg.95408.com/202001022046_668.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .one {        /* 基线对齐 默认 */        vertical-align: baseline;    }    .two {        /* 垂直居中*/        /* 让图片的中线 对齐 文字的中线*/        vertical-align: middle;    }    .three {        /* 顶部对齐*/        /*让图片的顶线 对齐 文字的顶线*/        vertical-align: top;    }&lt;/style&gt;&lt;div&gt;    &lt;img src=&quot;images/pic.jpg&quot; class=&quot;one&quot;&gt; 你瞅啥 &lt;/div&gt;&lt;div&gt;    &lt;img src=&quot;images/pic.jpg&quot; class=&quot;two&quot;&gt; 你瞅啥 &lt;/div&gt;&lt;div&gt;    &lt;img src=&quot;images/pic.jpg&quot; class=&quot;three&quot;&gt; 你瞅啥 &lt;/div&gt;</code></pre><h3 id="去除图片底侧空白缝隙"><a href="#去除图片底侧空白缝隙" class="headerlink" title="去除图片底侧空白缝隙"></a>去除图片底侧空白缝隙</h3><ul><li>一个父盒子由图片撑开时，图片下面会多出缝隙；</li><li>原因：图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐，就是图片底侧会有一个空白缝隙；</li><li><strong>解决方法：</strong>  </li><li>1、给img 添加 <code>vertical-align:middle | top| bottom</code> 等等，让图片不要和基线对齐；<ul><li>163写法：<code>img{vertical-align:top; border:0;}</code>；</li></ul></li><li>2、给img 添加 <code>display：block;</code> 转换为块级元素就不会存在问题了；<ul><li>sina写法：<code>img{border:0; display:block}</code> ；</li></ul></li></ul><blockquote><p>  去除图片底侧空白：</p></blockquote><p><img src="http://mdimg.95408.com/202001022055_459.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        border: 1px solid red;    }    div img {        /* 因为默认的是基线对齐，所有底册有空白缝隙 */        /* vertical-align: baseline; */        /* 只要不是 基线对齐就好了 */                /* vertical-align: bottom; */        /* vertical-align: middle; */        /* 块级元素来说 vertical-align是无效的，就不会有基线对齐的问题了 */        /* display: block; */    }&lt;/style&gt;&lt;div&gt;    &lt;img src=&quot;./img/pic3.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</code></pre><h2 id="溢出的文字省略号显示-text-overflow"><a href="#溢出的文字省略号显示-text-overflow" class="headerlink" title="溢出的文字省略号显示 text-overflow"></a>溢出的文字省略号显示 text-overflow</h2><h3 id="white-space-一行显示"><a href="#white-space-一行显示" class="headerlink" title="white-space 一行显示"></a>white-space 一行显示</h3><p>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 </p><pre><code>white-space:normal ；默认处理方式white-space:nowrap ；　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。</code></pre><h3 id="text-overflow-文字溢出"><a href="#text-overflow-文字溢出" class="headerlink" title="text-overflow 文字溢出"></a>text-overflow 文字溢出</h3><p>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出</p><pre><code>text-overflow : clip ；不显示省略标记（...），而是简单的裁切 text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）</code></pre><p><strong>注意</strong>：一定要首先强制一行内显示，再次和overflow属性  搭配使用</p><h3 id="总结三步曲"><a href="#总结三步曲" class="headerlink" title="总结三步曲"></a>总结三步曲</h3><pre><code class="css">/* 1. 先强制一行内显示文本 */white-space: nowrap;/* 2. 超出的部分隐藏 */overflow: hidden;/* 3. 文字用省略号替代超出的部分 */text-overflow: ellipsis;</code></pre><p><img src="http://mdimg.95408.com/202001022101_63.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        width: 150px;        height: 25px;        border: 1px solid pink;        /* 当文字显示不开的时候，自动换行 */        white-space: nowrap;        /* 溢出隐藏 */        overflow: hidden;        /* 文字溢出 用省略号替代  ellipsis 省略号 */        text-overflow: ellipsis;    }&lt;/style&gt;&lt;div&gt;这是一个灰常长灰常常的标题&lt;/div&gt;</code></pre><h2 id="CSS精灵技术-sprite"><a href="#CSS精灵技术-sprite" class="headerlink" title="CSS精灵技术 sprite"></a>CSS精灵技术 sprite</h2><ul><li>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度；</li><li>出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）；</li><li>CSS 精灵：<ul><li>是将网页中的一些背景图像整合到一张大图中（精灵图）；</li><li>只需向服务发送一次请求，网页中的背景图像即可全部展示出来；</li></ul></li><li>需要使用CSS的：<ul><li>background-image 设置精灵图；</li><li>background-repeat 不重复；</li><li>background-position 最关键的：属性精确地定位；</li></ul></li><li>CSS精灵技术主要针对于背景图片，放的都是小的装饰性质的背景图片；</li></ul><blockquote><p>  例：</p></blockquote><p><img src="http://mdimg.95408.com/202001022158_564.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .icon1 {        width: 20px;        height: 20px;        /* 使用相同的图片 最重要的是定位每个小图标的位置 */        background: url(images/index.png) no-repeat  0 -100px;    }    .icon2 {        width: 20px;        height: 20px;        background: url(images/index.png) no-repeat -150px -100px;    }&lt;/style&gt;&lt;div class=&quot;icon1&quot;&gt;&lt;/div&gt;---------&lt;div class=&quot;icon2&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>  从精灵图中选择出字母：</p></blockquote><p><img src="http://mdimg.95408.com/202001022154_321.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        float: left;        background: url(images/abcd.jpg) no-repeat;    }    .p {        width: 92px;        height: 108px;        background-position: -497px -278px;    }    .i {        width: 62px;        height: 106px;        background-position: -326px -142px;    }    .n {        width: 112px;        height: 113px;        background-position: -255px -274px;    }    .k {        width: 104px;        height: 111px;        background-position: -496px -142px;    }&lt;/style&gt;&lt;div class=&quot;p&quot;&gt;&lt;/div&gt;&lt;div class=&quot;i&quot;&gt;&lt;/div&gt;&lt;div class=&quot;n&quot;&gt;&lt;/div&gt;&lt;div class=&quot;k&quot;&gt;&lt;/div&gt;</code></pre><h3 id="滑动门"><a href="#滑动门" class="headerlink" title="滑动门"></a>滑动门</h3><p><img src="http://mdimg.95408.com/202001022205_242.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    /* a 是设置左侧背景（左门）*/    a {        /* 因为我们是滑动门，左右推拉 跟文字内容多少有关系 */        /* 此时需要用文字撑开盒子， 就要用到行内块 */        display: inline-block;        height: 33px;        background: url(images/to.png) no-repeat;        margin: 100px;        padding-left: 15px;        color: #fff;    }    /* span 是设置右侧背景（右门）*/    a span {        display: inline-block;        height: 33px;        line-height: 33px;        /* 一定注意 span 需要背景图片 右对齐 */        background: url(images/to.png) no-repeat right top;        padding-right: 15px;    }    /* 鼠标移动变换样式 */    /* 注意是鼠标移动到a上，再变换span，a:hover span*/    a:hover,    a:hover span {        background-image: url(images/ao.png);&lt;/style&gt;&lt;a href=&quot;#&quot;&gt;    &lt;span&gt;公司新闻&lt;/span&gt;&lt;/a&gt;</code></pre><h2 id="margin-负值使用"><a href="#margin-负值使用" class="headerlink" title="margin 负值使用"></a>margin 负值使用</h2><p><strong>负边距+定位：水平垂直居中</strong></p><p>咱们前面讲过， 一个绝对定位的盒子， 利用  父级盒子的 50%，  然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。</p><p><img src="http://mdimg.95408.com/202001021403_744.png?null" alt=""></p><pre><code class="css">div {      position: absolute;    /* left 50% 走父亲宽度的一半 */        left: 50%;    /* margin-left 左走自己宽度的一半  一定注意是 负值 */    margin-left: -100px;    width: 200px;    height: 200px;    background-color: pink;    }</code></pre><p><img src="http://mdimg.95408.com/202001022145_306.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .father {        /* 相对定位 */        position: relative;                    width: 400px;        height: 400px;        margin: 20px auto;        border: 1px solid red;    }    .son {        /* 绝对定位 */        position: absolute;        /* 向下移动50% */        top: 50%;        /* 向下移动50%是以son盒子顶边为准 */        /* 需还往回走son盒子的一半50px */        margin-top: -50px;        width: 100px;        height: 100px;        background-color: pink;    }&lt;/style&gt;&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>压住盒子相邻边框</strong> </p><blockquote><p>  左图：两个盒子的边框贴一起，成了4px</p><p>  右图：后一个盒子往左走2px，盖住了前一个盒子的2px右边框；下一排盒子往上走2px，盖住了上一排盒子的2px底边框；</p></blockquote><p><img src="http://mdimg.95408.com/202001022119_992.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* 浮动的盒子是紧贴在一起的 */        float: left;        width: 200px;        height: 300px;        border: 1px solid #ccc;        /* 左图：没有加下面两句，两个盒子的边框贴一起，成了4px */        /* 右图：加上下面两句，后一个盒子往左走2px，盖住了前一个盒子的2px */        margin-left: -2px;        margin-top: -2px;    }&lt;/style&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</code></pre><blockquote><p>  上一例，这时如果加hover，前一个边框变色会被后一个盖住：</p></blockquote><p><img src="http://mdimg.95408.com/202001022129_748.png?null" alt=""></p><pre><code class="css">div:hover {    border: 2px solid blue;}</code></pre><blockquote><p>  改进：</p></blockquote><p><img src="http://mdimg.95408.com/202001022133_286.png?null" alt=""></p><pre><code class="css">/* 方案一 */div:hover {    border: 1px solid #f40;    /* 我要让当前鼠标经过的这个div 升到最高处来就好了 */    /* 定位的盒子是最高层的 */    /* 我们只要保证当前的这个盒子 是定位 就会压住 标准流和浮动盒子 */    /* 我们只能用相对定位 它是占位置的 */    position: relative;}/* 方案二 */div {    position: relative;}div:hover {    border: 1px solid #f40;    /* 都是定位的盒子，我们通过z-index 来实现层级关系 */    z-index: 1;}</code></pre><h2 id="border-写三角形"><a href="#border-写三角形" class="headerlink" title="border 写三角形"></a>border 写三角形</h2><p>用 css 边框可以模拟三角效果：</p><ul><li>宽度高度为 0 ；</li><li>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好；</li><li>为了照顾兼容性 低版本的浏览器，加上 <code>font-size: 0;  line-height: 0;</code> ；</li></ul><p><img src="http://mdimg.95408.com/202001022107_171.png?null" alt=""></p><pre><code class="css">&lt;style&gt;div {    /* 用css边框可以模拟三角效果 */    width: 0;    height: 0;    border-top: 10px solid red;    border-right: 10px solid green;    border-bottom: 10px solid blue;    border-left: 10px solid pink;    font-size: 0;    line-height: 0;}p {    /* 模拟向右三角效果 */    width: 0;    height: 0;    border-style: solid;    border-width: 10px;    border-color:  transparent transparent transparent red;    font-size: 0;    line-height: 0;}&lt;/style&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</code></pre><p><img src="http://mdimg.95408.com/202001022113_890.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        position: relative;        width: 200px;        height: 100px;        background-color: pink;        margin: 100px auto;    }    p {        position: absolute;        top: -40px;        left: 50%;        margin-left: -20px;        /* 三角效果 */        width: 0;        height: 0;        border-style: solid;        border-width: 20px;        border-color: transparent transparent pink transparent;        font-size: 0;        line-height: 0;    }&lt;/style&gt;&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（七）CSS定位</title>
      <link href="/2020/01/02/css/html+css%EF%BC%88%E4%B8%83%EF%BC%89CSS%E5%AE%9A%E4%BD%8D/"/>
      <url>/2020/01/02/css/html+css%EF%BC%88%E4%B8%83%EF%BC%89CSS%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li>将盒子<strong>定</strong>在某一个<strong>位</strong>置  自由的漂浮在其他盒子的上面；</li><li>定位也是用来布局的；</li><li>两部分组成：<code>定位 = 定位模式 + 边偏移</code></li></ul><h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><ul><li>定位的盒子，是通过边偏移来移动位置的；</li><li>通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>；</li><li>定位的盒子有了边偏移才有价值，凡是有定位地方必定有边偏移；</li></ul><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><h3 id="定位模式"><a href="#定位模式" class="headerlink" title="定位模式"></a>定位模式</h3><pre><code class="css">选择器 { position: 属性值static/relative/absolute/fixed; }</code></pre><table><thead><tr><th>值</th><th align="center">语义</th></tr></thead><tbody><tr><td><code>static</code></td><td align="center"><strong>静态</strong>定位</td></tr><tr><td><code>relative</code></td><td align="center"><strong>相对</strong>定位</td></tr><tr><td><code>absolute</code></td><td align="center"><strong>绝对</strong>定位</td></tr><tr><td><code>fixed</code></td><td align="center"><strong>固定</strong>定位</td></tr></tbody></table><h2 id="定位模式-position"><a href="#定位模式-position" class="headerlink" title="定位模式 position"></a>定位模式 position</h2><h3 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位 static"></a>静态定位 static</h3><ul><li>默认定位方式，无定位的意思；</li><li>按照标准流特性摆放位置，它没有边偏移；</li><li>一般不用；</li></ul><h3 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h3><ul><li>元素<strong>相对</strong>于它原来在标准流中的位置；</li><li>相对于自己原来在标准流中位置来移动的；</li><li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它；</li></ul><p><strong>示例：</strong></p><blockquote><p>  div 盒子1、2、3按标准流显示；当 div2 盒子相对定位 <code>position: relative;</code>并向上、左偏移20px <code>top: 20px; left: 20px;</code> 时：</p><p>  1、div2 原本在标准流中的位置仍然占有，div3 没有上来；</p><p>  2、div2 的偏移，是以自己原本的位置来偏移的；</p></blockquote><p><img src="http://mdimg.95408.com/202001021257_318.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        width: 200px;        height: 100px;        background-color: pink;    }    .two {        background-color: yellow;        position: relative;        top: 20px;        left: 20px;    }&lt;/style&gt;&lt;div&gt;1&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;</code></pre><h3 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h3><ul><li><strong>绝对定位</strong>是元素以带有定位的<strong>父级</strong>元素来移动位置；</li><li><strong>完全脱标</strong> —— 完全不占位置；  </li><li><strong>父元素没有定位</strong>，则以<strong>浏览器</strong>为准定位（Document 文档）。</li></ul><blockquote><p>  如果父级有定位，绝对定位子盒子以父级为准移动位置：</p></blockquote><p><img src="http://mdimg.95408.com/202001021345_353.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .father {        margin: 0 auto;        width: 400px;        height: 400px;        background-color: pink;        /* 如果父级有定位，绝对定位子盒子以父级为准移动位置 */        position: relative;    }    .son {        width: 200px;        height: 200px;        background-color: purple;        /* 子盒子绝对定位 */        position: absolute;        top: 100px;        left: 100px;    }&lt;/style&gt;&lt;div class=&quot;father&quot;&gt;father    &lt;div class=&quot;son&quot;&gt;son&lt;/div&gt;&lt;/div&gt;</code></pre><blockquote><p>  如果父级没有定位 绝对定位子盒子以浏览器为准移动位置：</p></blockquote><p><img src="http://mdimg.95408.com/202001021345_988.png?null" alt=""></p><pre><code class="css">.father {    margin: 0 auto;    width: 400px;    height: 400px;    background-color: pink;    /* 如果父级没有定位 绝对定位子盒子以浏览器为准移动位置 */    /* 父盒子取消相对定位 */    /* position: relative; */}</code></pre><blockquote><p>  son1 紫色盒子绝对定位后：不占据文件流，son2 蓝色盒子上移；</p></blockquote><p><img src="http://mdimg.95408.com/202001021355_845.png?null" alt=""></p><h3 id="口诀：子绝父相"><a href="#口诀：子绝父相" class="headerlink" title="口诀：子绝父相"></a>口诀：子绝父相</h3><ul><li><strong>子级</strong>是<strong>绝对</strong>定位，<strong>父级</strong>要用<strong>相对</strong>定位；</li><li>常常用子绝父相来布局：</li><li>外层的父盒子：相对定位：<ul><li>相对定位，占据原有位置，按标准流显示，让后面的盒子布局正常显示；</li></ul></li><li>内层的子盒子：绝对定位：<ul><li>绝对定位，不占据位置，脱离标准流，不影响其他子盒子的位置；</li><li>给定偏移量，方便移动到想要的位置；</li></ul></li></ul><h3 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h3><ul><li>是<strong>绝对定位</strong>的一种特殊形式；</li><li><strong>完全脱标</strong> —— 完全不占位置；</li><li>只以唯一的：<strong>浏览器可视窗口</strong>来偏移位置；</li><li>不会随浏览器向下滚动；</li></ul><blockquote><p>  将猴子固定到浏览器的右下角示例：</p></blockquote><p><img src="http://mdimg.95408.com/web_2020010201.gif" alt=""></p><pre><code class="html">&lt;style&gt;    body {        height: 1500px;    }    img {        position: fixed;        right: 0;        bottom: 0;    }&lt;/style&gt;&lt;img src=&quot;images/houzi.jpg&quot; alt=&quot;&quot; width=&quot;150&quot;&gt;</code></pre><h2 id="定位扩展"><a href="#定位扩展" class="headerlink" title="定位扩展"></a>定位扩展</h2><h3 id="让定位后的盒子居中"><a href="#让定位后的盒子居中" class="headerlink" title="让定位后的盒子居中"></a>让定位后的盒子居中</h3><ul><li><strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>；</li><li>实现居中的办法（假设盒子宽度200px）：<ul><li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li><li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>；</li></ul></li><li><code>left:50%</code>水平居中；<code>top:50%</code>垂直居中；</li></ul><blockquote><p>  绝对定位的盒子水平居中示例：</p></blockquote><p><img src="http://mdimg.95408.com/202001021403_744.png?null" alt=""></p><pre><code class="css">div {    /* 绝对定位 margin 左右auto 不能让盒子水平居中 */    /* margin: auto; */    /* 解决办法 */    /* 0.定位position: absolute; */        position: absolute;    /* 1.left 50% 走父亲宽度的一半 */        left: 50%;    /* 2.margin-left 左走自己宽度的一半  一定注意是 负值 */    margin-left: -100px;    width: 200px;    height: 200px;    background-color: pink;    }</code></pre><h3 id="堆叠顺序-z-index"><a href="#堆叠顺序-z-index" class="headerlink" title="堆叠顺序 z-index"></a>堆叠顺序 z-index</h3><ul><li>使用<strong>定位</strong>布局，可能会<strong>出现盒子重叠的情况</strong>；</li><li>默认<strong>后来居上</strong>， 后面的盒子会压住前面的盒子；</li><li>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>；<ul><li>默认值是 0，数值越大，盒子越靠上；</li><li>可以是正整数、负整数；</li><li>如果<strong>属性值相同</strong>，按默认顺序：<strong>后来居上</strong>；</li><li><strong>数字后不加单位</strong>；</li></ul></li><li>只能用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效；</li></ul><p><img src="http://mdimg.95408.com/202001021230_452.png?null" alt=""></p><blockquote><p>  应用 z-index 层叠等级属性示例：</p></blockquote><p><img src="http://mdimg.95408.com/202001021408_891.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .son1 {        position: absolute;        width: 200px;        height: 200px;        background-color: red;    }    .son2 {        position: absolute;        /* son2向右下角偏移50px */        top: 50px;        left: 50px;        /* 左图：没加上z-index: 2; */        /* 右图：加上了z-index: 2; */        /* z-index: 2; */        width: 200px;        height: 200px;        background-color: green;    }    .son3 {        position: absolute;        /* son2向右下角偏移100px */        top: 100px;        left: 100px;        width: 200px;        height: 200px;        background-color: blue;    }&lt;/style&gt;&lt;div class=&quot;son1&quot;&gt;son1&lt;/div&gt;&lt;div class=&quot;son2&quot;&gt;son2&lt;/div&gt;&lt;div class=&quot;son3&quot;&gt;son3&lt;/div&gt;</code></pre><h3 id="定位-变-行内块"><a href="#定位-变-行内块" class="headerlink" title="定位 变 行内块"></a>定位 变 行内块</h3><p>一个元素，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，自动变<strong>行内块</strong>。</p><ul><li><code>display：inline-bolck;</code> display 显示模式：<ul><li>转行内块；</li></ul></li><li><code>float: left/right;</code> 浮动：<ul><li>默认转（类似）行内块；</li></ul></li><li><code>position: absolute/fixed;</code>绝对定位、固定定位：<ul><li>默认转行内块；</li></ul></li><li>块级元素：<ul><li>如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，自动变<strong>行内块</strong>；</li><li>原本不给width，默认通栏；</li><li>变成行内块后，默认宽度为内容的宽度；</li></ul></li><li>行内元素：<ul><li>如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，自动变<strong>行内块</strong>；</li><li>原本不能设置width、height，默认宽高以内容为准；</li><li>变成行内块后，可以直接设置宽、高等等；</li></ul></li><li>浮动、绝对定位（固定定位）转行内块，不会触发外边距合并（塌陷）的问题；</li></ul><blockquote><p>  不会触发外边距塌陷示例：</p></blockquote><p><img src="http://mdimg.95408.com/202001021420_4.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .father {        /* 使用浮动，可以解决外边距塌陷的问题 */        /* float: left; */        /* 使用绝对定位/固定定位，也可以解决 */        position: absolute;        width: 400px;        height: 400px;        background-color: pink;    }    .son {        width: 200px;        height: 200px;        background-color: purple;        /*外边距合并*/        margin-top: 100px;    }&lt;/style&gt;&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h2 id="定位小结"><a href="#定位小结" class="headerlink" title="定位小结"></a>定位小结</h2><p>关于<strong>边偏移</strong>：要和<strong>定位</strong>联合使用，<strong>单独使用无效</strong>；</p><ul><li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li><li><code>left</code> 和 <code>right</code> 不要同时使用；</li></ul><table><thead><tr><th>定位模式</th><th>是否脱标占有位置</th><th align="left">移动位置基准</th><th>转行内块</th><th>使用情况</th></tr></thead><tbody><tr><td>静态static</td><td>不脱标，正常模式</td><td align="left">正常模式</td><td>/</td><td>几乎不用</td></tr><tr><td>相对定位relative</td><td>不脱标，占有位置</td><td align="left">相对自身位置移动</td><td>/</td><td>基本单独使用</td></tr><tr><td>绝对定位absolute</td><td>完全脱标，不占有位置</td><td align="left">相对于定位父级移动位置</td><td>能</td><td>要和定位父级元素搭配使用</td></tr><tr><td>固定定位fixed</td><td>完全脱标，不占有位置</td><td align="left">相对于浏览器移动位置</td><td>能</td><td>单独使用，不需要父级</td></tr></tbody></table><h2 id="网页布局总结"><a href="#网页布局总结" class="headerlink" title="网页布局总结"></a>网页布局总结</h2><p>一个完整的网页，有标准流 、 浮动 、 定位 一起完成布局的；</p><p><strong>标准流</strong> </p><p>可以让盒子上下排列 或者 左右排列；</p><p><strong>浮动</strong></p><p>可以让多个块级元素一行显示，或者左右对齐盒子，浮动的盒子就是按照顺序左右排列；</p><p><strong>定位</strong></p><p>定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示；</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（六）CSS浮动</title>
      <link href="/2019/12/31/css/html+css%EF%BC%88%E5%85%AD%EF%BC%89CSS%E6%B5%AE%E5%8A%A8/"/>
      <url>/2019/12/31/css/html+css%EF%BC%88%E5%85%AD%EF%BC%89CSS%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h2><p><img src="http://mdimg.95408.com/201912311707_907.png?null" alt=""></p><ul><li>如何让多个盒子(div)水平排列成一行？</li><li>如何实现盒子的左右对齐？</li><li>行内块（inline-block）可以实现多个元素一行显示，但是中间会有空白缝隙；</li><li>因此我们需要浮动来完成网页布局。</li></ul><p><img src="http://mdimg.95408.com/201912311716_936.png?null" alt="行内块 inline-block"></p><pre><code class="css">/* 行内块（inline-block）可以实现多个元素一行显示，但是中间会有空白缝隙 */div {    display: inline-block;    width: 200px;    height: 200px;}</code></pre><h3 id="CSS-布局的三种机制"><a href="#CSS-布局的三种机制" class="headerlink" title="CSS 布局的三种机制"></a>CSS 布局的三种机制</h3><h4 id="普通流（标准流）"><a href="#普通流（标准流）" class="headerlink" title="普通流（标准流）"></a>普通流（标准流）</h4><p><strong>块级元素</strong>会独占一行，<strong>从上向下</strong>顺序排列；</p><ul><li>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li></ul><p><strong>行内元素</strong>会按照顺序，<strong>从左到右</strong>顺序排列，碰到父元素边缘则自动换行；</p><ul><li>常用元素：span、a、i、em等</li></ul><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>让盒子从普通流中<strong>浮</strong>起来, 主要作用让多个块级盒子一行显示。</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>将盒子<strong>定</strong>在浏览器的某一个<strong>位</strong>置——CSS 离不开定位，特别是后面的 js 特效。</p><h3 id="浮动-float-1"><a href="#浮动-float-1" class="headerlink" title="浮动 float"></a>浮动 float</h3><p>元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制，移动到指定位置。</p><ol><li><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</li><li>可以实现盒子的左右对齐等等..</li><li>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</li></ol><pre><code class="css">选择器 {    float: 属性值;}</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>none</strong></td><td>元素不浮动（<strong>默认值</strong>）</td></tr><tr><td><strong>left</strong></td><td>元素向<strong>左</strong>浮动</td></tr><tr><td><strong>right</strong></td><td>元素向<strong>右</strong>浮动</td></tr></tbody></table><blockquote><p>我们使用浮动的核心目的——让多个块级盒子在同一行显示。 因为这是我们最常见的一种布局方式</p></blockquote><p><strong>float</strong> —— <strong>浮漏特</strong></p><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>浮</td><td>加了浮动的盒子<strong>是浮起来</strong>的，漂浮在其他标准流盒子的上面。</td></tr><tr><td>漏</td><td>加了浮动的盒子<strong>是不占位置的</strong>，它原来的位置<strong>漏给了标准流的盒子</strong>。</td></tr><tr><td>特</td><td><strong>特别注意</strong>：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙</td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912311719_847.png?null" alt=""></p><pre><code class="css">&lt;style&gt;.one {    /*不是标准流了， 漂浮起来， 浮在 标准流的上面*/    float: left;    width: 200px;    height: 200px;    background-color: pink;}.two {    width: 300px;    height: 300px;    background-color: purple;}&lt;/style&gt;&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</code></pre><h3 id="浮动和标准流的父盒子搭配"><a href="#浮动和标准流的父盒子搭配" class="headerlink" title="浮动和标准流的父盒子搭配"></a>浮动和标准流的父盒子搭配</h3><p>我们知道，浮动是脱标的，会影响下面的标准流元素；</p><p>此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。</p><h3 id="浮动元素与父盒子的关系"><a href="#浮动元素与父盒子的关系" class="headerlink" title="浮动元素与父盒子的关系"></a>浮动元素与父盒子的关系</h3><ul><li>子盒子的浮动参照父盒子对齐</li><li>不会与父盒子的边框重叠，也不会超过父盒子的内边距</li></ul><blockquote><p>.son 右浮动后，还是有一定的间距，是 .father 的 padding 和 border ：</p></blockquote><p><img src="http://mdimg.95408.com/201912311654_325.png?null" alt=""></p><pre><code class="css">.father {    width: 500px;    height: 500px;    background-color: pink;    border: 20px solid red;    padding: 20px;}.son {    float: right;    width: 200px;    height: 200px;    background-color: purple;}</code></pre><h3 id="浮动元素与兄弟盒子的关系"><a href="#浮动元素与兄弟盒子的关系" class="headerlink" title="浮动元素与兄弟盒子的关系"></a>浮动元素与兄弟盒子的关系</h3><p>在一个父级盒子中，如果：</p><ul><li>前一个兄弟盒子是<strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li><li>前一个兄弟盒子是<strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。 </li></ul><blockquote><p>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</p><p>如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，防止引起问题。</p></blockquote><p><img src="http://mdimg.95408.com/201912311725_354.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .one {        /* 左图：加上了 float: left; */        /* 不是标准流了，漂浮起来 */        float: left;        width: 200px;        height: 200px;        background-color: pink;    }    .two {        width: 300px;        height: 300px;        background-color: purple;    }&lt;/style&gt;&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</code></pre><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p><img src="http://mdimg.95408.com/201912311707_487.png?null" alt=""></p><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。</p><ul><li>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响；</li><li>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong>；</li></ul><p><img src="http://mdimg.95408.com/201912311743_403.png?null" alt=""></p><blockquote><p>左图：正常流的盒子，父盒子（粉色）内的子盒子 a（紫色） b（蓝色） 会自然撑开粉色父盒子，灰色的下级盒子在下方正常排列；</p><p>右图：浮动的盒子，父盒子（粉色）内的子盒子 a（紫色） b（蓝色）浮动时，不能撑开父盒子，粉色父盒子高度为0，灰色的下级盒子会跑到粉色盒子下方；</p></blockquote><pre><code class="html">&lt;style&gt;    /* 右图 .a .b ：加上了 float: left; */    /* 右图 .a .b ：没有加 */    /* 父盒子不方便给高度，根据内容撑开，有多少内容，我的父盒子就有多高*/    .one {        width: 500px;        background-color: pink;    }    /* a b 浮动了，不占有位置，而父级又没有高度，所以 two 就到底下去了 */    .a {        float: left;        width: 200px;        height: 200px;        background-color: purple;    }    .b {        float: left;        width: 250px;        height: 250px;        background-color: skyblue;    }    .two {        width: 700px;        height: 400px;        background-color: #666;    }&lt;/style&gt;&lt;div class=&quot;one&quot;&gt;    &lt;div class=&quot;a&quot;&gt;a&lt;/div&gt;    &lt;div class=&quot;b&quot;&gt;b&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p><p><img src="http://mdimg.95408.com/201912311741_555.png?null" alt=""></p><blockquote><p>左图：上方的例子；</p><p>右图：将粉色父例子 清除浮动 <code>.one{overflow: hidden;}</code> ，灰色下级盒子可以正常显示了；</p></blockquote><pre><code class="css">/* 左图 */.one {    width: 300px;    background-color: pink;}/* 右图 */.one {    width: 300px;    background-color: pink;    overflow: hidden;}</code></pre><h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><pre><code class="css">W3C推荐的做法，通过在浮动元素末尾添加一个空的标签： &lt;div style=”clear:both”&gt;&lt;/div&gt;也可以是其他标签如 br 等都可以。</code></pre><h3 id="添加overflow属性"><a href="#添加overflow属性" class="headerlink" title="添加overflow属性"></a>添加overflow属性</h3><pre><code class="css">可以给父级添加： overflow 为 hidden| auto| scroll 都可以实现。 .father {    overflow: hidden;}</code></pre><h3 id="添加after伪元素"><a href="#添加after伪元素" class="headerlink" title="添加after伪元素"></a>添加after伪元素</h3><p>代表网站： 百度、淘宝网、网易等</p><pre><code class="css">/*声明清除浮动的样式*/.clearfix:after {    content: &quot;&quot;;    display: block;    height: 0;    visibility: hidden;    clear: both;}.clearfix {    *zoom: 1;    /* ie6 ie7 专门清除浮动的样式 */}</code></pre><h3 id="添加双伪元素"><a href="#添加双伪元素" class="headerlink" title="添加双伪元素"></a>添加双伪元素</h3><p>代表网站： 小米、腾讯等</p><pre><code class="css">/*声明清除浮动的样式*/.clearfix:before,.clearfix:after {    content: &quot;&quot;;    display: table;}.clearfix:after {    clear: both;}.clearfix {    *zoom: 1;}</code></pre><h3 id="清除浮动总结"><a href="#清除浮动总结" class="headerlink" title="清除浮动总结"></a>清除浮动总结</h3><table><thead><tr><th>清除浮动的方式</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td>额外标签法（隔墙法）</td><td align="left">通俗易懂，书写方便</td><td align="left">添加许多无意义的标签，结构化较差。</td></tr><tr><td>父级overflow:hidden;</td><td align="left">书写简单</td><td align="left">溢出隐藏</td></tr><tr><td>父级after伪元素</td><td align="left">结构语义化正确</td><td align="left">由于IE6-7不支持:after，兼容性问题</td></tr><tr><td>父级双伪元素</td><td align="left">结构语义化正确</td><td align="left">由于IE6-7不支持:after，兼容性问题</td></tr></tbody></table><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（五）CSS盒子模型</title>
      <link href="/2019/12/31/css/html+css%EF%BC%88%E4%BA%94%EF%BC%89CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/12/31/css/html+css%EF%BC%88%E4%BA%94%EF%BC%89CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子模型-box-model"><a href="#盒子模型-box-model" class="headerlink" title="盒子模型 box model"></a>盒子模型 box model</h2><ul><li>盒子模型有元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成</li><li>盒子里面的文字和图片等元素是 内容区域</li><li>盒子的厚度 我们成为 盒子的边框 </li><li>盒子内容与边框的距离是内边距</li><li>盒子与盒子之间的距离是外边距</li></ul><p><img src="http://mdimg.95408.com/201912311509_411.png?null" alt=""></p><h2 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 border</h2><p><img src="http://mdimg.95408.com/201912311521_486.png?null" alt=""></p><pre><code class="css">border: border-width || border-style || border-color</code></pre><table><thead><tr><th>属性</th><th align="center">作用</th></tr></thead><tbody><tr><td>border-width</td><td align="center">定义边框粗细，单位是px</td></tr><tr><td>border-style</td><td align="center">边框的样式</td></tr><tr><td>border-color</td><td align="center">边框颜色</td></tr></tbody></table><p>border-style边框的样式：</p><ul><li>none：没有边框即忽略所有边框的宽度（默认值）</li><li>solid：边框为单实线(最为常用的)</li><li>dashed：边框为虚线  </li><li>dotted：边框为点线</li></ul><p>边框综合设置：</p><pre><code class="css">border: 1px solid red;/* 没有顺序 */</code></pre><h3 id="附：盒子边框"><a href="#附：盒子边框" class="headerlink" title="附：盒子边框"></a>附：盒子边框</h3><ul><li>通过表格的 <code>cellspacing=&quot;0&quot;</code> , 将单元格与单元格之间的距离设置为0</li><li>但是两个单元格之间的边框会出现重叠，从而使边框变粗</li><li>通过css属性：border-collapse:collapse; 表示相邻边框合并在一起</li></ul><pre><code class="css">table,td {    border-collapse: collapse;    /*合并相邻边框*/}</code></pre><h3 id="圆角-border-radius"><a href="#圆角-border-radius" class="headerlink" title="圆角 border-radius"></a>圆角 border-radius</h3><pre><code class="css">border-radius: 10px;/* 设置10px的圆角 */border-radius: 50%;/* 让一个正方形变成圆圈 */</code></pre><h3 id="阴影-box-shadow"><a href="#阴影-box-shadow" class="headerlink" title="阴影 box-shadow"></a>阴影 box-shadow</h3><pre><code class="css">box-shadow: 水平位置 垂直位置 模糊距离 阴影尺寸 阴影颜色 内/外阴影；</code></pre><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><em>h-shadow</em></td><td align="left">必需的。水平阴影的位置。允许负值</td></tr><tr><td align="left"><em>v-shadow</em></td><td align="left">必需的。垂直阴影的位置。允许负值</td></tr><tr><td align="left"><em>blur</em></td><td align="left">可选。模糊距离</td></tr><tr><td align="left"><em>spread</em></td><td align="left">可选。阴影的大小</td></tr><tr><td align="left"><em>color</em></td><td align="left">可选。阴影的颜色。在CSS颜色值找颜色值的完整列表</td></tr><tr><td align="left">inset</td><td align="left">可选。从外层的阴影（开始时outset）改变阴影内侧阴影</td></tr></tbody></table><ul><li>前两个属性是必须写的，其余的可以省略；</li><li>外阴影 (outset) 是默认的 但是不能写，想要内阴影可以写 inset ；</li></ul><p><img src="http://mdimg.95408.com/201912311559_939.png?null" alt=""></p><pre><code class="css">div {    width: 200px;    height: 200px;    border: 10px solid red;    /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */    /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */    box-shadow: 0 15px 30px rgba(0, 0, 0, .3);}</code></pre><h2 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距 padding"></a>内边距 padding</h2><p><img src="http://mdimg.95408.com/201912311522_325.png?null" alt=""></p><p>边框与内容之间的距离；</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>padding-left</td><td align="left">左内边距</td></tr><tr><td>padding-right</td><td align="left">右内边距</td></tr><tr><td>padding-top</td><td align="left">上内边距</td></tr><tr><td>padding-bottom</td><td align="left">下内边距</td></tr></tbody></table><p>当我们给盒子指定padding值之后：</p><ol><li>内容和边框有了距离，添加了内边距</li><li>盒子会变大了。</li></ol><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>1个值</td><td>padding：上下左右内边距;</td></tr><tr><td>2个值</td><td>padding: 上下内边距    左右内边距 ；</td></tr><tr><td>3个值</td><td>padding：上内边距   左右内边距   下内边距；</td></tr><tr><td>4个值</td><td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td></tr></tbody></table><h3 id="附：内盒尺寸大小计算"><a href="#附：内盒尺寸大小计算" class="headerlink" title="附：内盒尺寸大小计算"></a>附：内盒尺寸大小计算</h3><p>盒子的整体大小 = 盒子的宽度高度 + padding + border 三者之和；</p><p>解决：例子宽度高度值 应减少 内边距和边框的数值；</p><p><img src="http://mdimg.95408.com/201912311516_389.png?null" alt=""></p><blockquote><p>下图：盒子的总大小这：330px宽、230px高：</p></blockquote><p><img src="http://mdimg.95408.com/201912311603_111.png?null" alt=""></p><h3 id="附：padding不影响盒子情况"><a href="#附：padding不影响盒子情况" class="headerlink" title="附：padding不影响盒子情况"></a>附：padding不影响盒子情况</h3><blockquote><p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</p></blockquote><pre><code class="css">div {    /* 宽度指定到父盒子div上，子盒子p会继承 */    width: 200px;    height: 200px;    background-color: pink;}p {    /* 子盒子p没有宽度 则padding不会撑开盒子*/    height: 100px;    background-color: purple;    padding: 10px;}&lt;div&gt;    &lt;p&gt;abc&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距 margin"></a>外边距 margin</h2><p><img src="http://mdimg.95408.com/201912311522_905.png?null" alt=""></p><p>控制盒子和盒子之间的距离；</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>margin-left</td><td align="left">左外边距</td></tr><tr><td>margin-right</td><td align="left">右外边距</td></tr><tr><td>margin-top</td><td align="left">上外边距</td></tr><tr><td>margin-bottom</td><td align="left">下外边距</td></tr></tbody></table><p>margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</p><h3 id="块级盒子水平居中"><a href="#块级盒子水平居中" class="headerlink" title="块级盒子水平居中"></a>块级盒子水平居中</h3><ul><li>盒子必须指定了宽度（width）</li><li>然后就给<em>*左右的外边距都设置为auto</em></li><li>实际工作中常用这种方式进行网页布局</li></ul><pre><code class="css">.header {    width: 960px;    margin: 0 auto;}</code></pre><p>常见的写法，以下下三种都可以：</p><ul><li>margin-left: auto; margin-right: auto; </li><li>margin: auto; </li><li>margin: 0 auto; </li></ul><h3 id="文字居中和盒子居中区别"><a href="#文字居中和盒子居中区别" class="headerlink" title="文字居中和盒子居中区别"></a>文字居中和盒子居中区别</h3><ol><li>盒子内的文字水平居中是  text-align: center,  而且还可以让 行内元素和行内块居中对齐</li><li>块级盒子水平居中  左右margin 改为 auto </li></ol><pre><code class="css">text-align: center;/* 文字 行内元素 行内块元素水平居中 */margin: 10px auto;/* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */</code></pre><p><img src="http://mdimg.95408.com/201912311554_284.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        width: 300px;        height: 200px;        background-color: pink;        /*块级盒子水平居中*/        margin: 50px auto;        /*盒子里面的文字 行内元素 、行内块居中对齐水平居中*/        text-align: center;    }&lt;/style&gt;&lt;div&gt;    我是文字 &lt;br /&gt;    &lt;input type=&quot;button&quot; value=&quot;点击提交&quot;&gt;&lt;/div&gt;</code></pre><h3 id="插入图片和背景图片区别"><a href="#插入图片和背景图片区别" class="headerlink" title="插入图片和背景图片区别"></a>插入图片和背景图片区别</h3><ol><li>插入图片 我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin</li><li>背景图片我们一般用于小图标背景 或者 超大背景图片  背景图片 只能通过  background-position</li></ol><pre><code class="css"> img {     width: 200px;     /* 插入图片更改大小 width 和 height */     height: 210px;     margin-top: 30px;     /* 插入图片更改位置 可以用margin 或padding  盒模型 */     margin-left: 50px;     /* 插入当图片也是一个盒子 */ } div {     width: 400px;     height: 400px;     border: 1px solid purple;     background: #fff url(images/sun.jpg) no-repeat;     background-position: 30px 50px;     /* 背景图片更改位置 background-position */ }</code></pre><h3 id="清除元素的默认内外边距"><a href="#清除元素的默认内外边距" class="headerlink" title="清除元素的默认内外边距"></a>清除元素的默认内外边距</h3><pre><code class="css">* {    padding: 0;    /* 清除内边距 */    margin: 0;    /* 清除外边距 */}</code></pre><h3 id="外边距塌陷"><a href="#外边距塌陷" class="headerlink" title="外边距塌陷"></a>外边距塌陷</h3><h4 id="相邻块元素垂直外边距的合并"><a href="#相邻块元素垂直外边距的合并" class="headerlink" title="相邻块元素垂直外边距的合并"></a>相邻块元素垂直外边距的合并</h4><ul><li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li><li>下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和</li><li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li></ul><p><img src="http://mdimg.95408.com/201912311530_335.png?null" alt=""></p><p><strong>解决方案：尽量给只给一个盒子添加margin值</strong>。</p><h4 id="嵌套块元素垂直外边距的合并（塌陷）"><a href="#嵌套块元素垂直外边距的合并（塌陷）" class="headerlink" title="嵌套块元素垂直外边距的合并（塌陷）"></a>嵌套块元素垂直外边距的合并（塌陷）</h4><ul><li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li><li>父元素的上外边距会与子元素的上外边距发生合并</li><li>合并后的外边距为两者中的较大者</li></ul><p><img src="http://mdimg.95408.com/201912311531_644.png?null" alt=""></p><p><strong>解决方案：</strong></p><ol><li>可以为父元素定义上边框。</li><li>可以为父元素定义上内边距</li><li>可以为父元素添加overflow:hidden。</li></ol><p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题；</p><pre><code class="html">&lt;style&gt;    .father {        width: 200px;        height: 200px;        background-color: pink;        /* 嵌套关系 垂直外边距合并  解决方案 */        /* 1. 可以为父元素定义上边框  transparent 透明 */        border-top: 1px solid transparent;        /* 2. 可以给父级指定一个 上 padding值 */        padding-top: 1px;        /* 3. 可以为父元素添加overflow:hidden */        overflow: hidden;    }    .son {        width: 100px;        height: 100px;        background-color: purple;        margin-top: 100px;    }&lt;/style&gt;&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="http://mdimg.95408.com/201912311556_673.png?null" alt=""></p><h3 id="使用优先级"><a href="#使用优先级" class="headerlink" title="使用优先级"></a>使用优先级</h3><p>按照 优先使用  宽度 （width）  其次使用 内边距（padding） 再次 外边距（margin）。   </p><pre><code>width &gt;  padding  &gt;   margin   </code></pre><h2 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h2><p><strong>空格规范</strong></p><ul><li>a 选择器 与 左花括号 { 之间必须包含空格</li><li>b 属性名 与之后的冒号 : 之间不允许包含空格</li><li>c 冒号  : 与 属性值 之间必须包含空格</li></ul><pre><code class="css">.selector {    font-size: 12px;}</code></pre><p><strong>选择器规范</strong></p><ul><li>并集选择器，每个选择器声明必须独占一行</li><li>选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确</li></ul><pre><code class="css">.post,.abc,.comment {    line-height: 1.5;}.page .header .login {}</code></pre><p><strong>属性规范</strong></p><ul><li>属性定义必须另起一行</li><li>属性定义后必须以分号结尾</li></ul><pre><code class="css">.selector {    margin: 0;    padding: 0;}</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（四）CSS显示模式、行高、背景、特性</title>
      <link href="/2019/12/31/css/html+css%EF%BC%88%E5%9B%9B%EF%BC%89CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E3%80%81%E8%A1%8C%E9%AB%98%E3%80%81%E8%83%8C%E6%99%AF%E3%80%81%E7%89%B9%E6%80%A7/"/>
      <url>/2019/12/31/css/html+css%EF%BC%88%E5%9B%9B%EF%BC%89CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E3%80%81%E8%A1%8C%E9%AB%98%E3%80%81%E8%83%8C%E6%99%AF%E3%80%81%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="显示模式-display"><a href="#显示模式-display" class="headerlink" title="显示模式 display"></a>显示模式 display</h2><p><img src="http://mdimg.95408.com/201912311503_941.png?null" alt=""></p><h3 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素 block-level"></a>块级元素 block-level</h3><pre><code class="css">常见的块元素有 &lt;h1&gt;~&lt;h6&gt;、 &lt;p&gt;、 &lt;div&gt;、 &lt;ul&gt;、 &lt;ol&gt;、 &lt;li&gt;等， 其中&lt;div&gt;标签是最典型的块元素。</code></pre><ul><li><p>独占一行</p></li><li><p>高度、宽度、外边距以及内边距都可以控制</p></li><li><p>宽度默认是容器（父级宽度）的100%</p></li><li><p>是一个容器及盒子，里面可以放行内或者块级元素。</p></li><li><p>只有 文字才 能组成段落  因此 p  里面不能放块级元素，特别是 p 不能放div </p></li><li><p>同理还有这些标签h1, h2, h3, h4, h5, h6, dt，他们都是文字类块级标签，里面不能放其他块级元素。</p></li></ul><h3 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素 inline-level"></a>行内元素 inline-level</h3><pre><code class="css">常见的行内元素有 &lt;a&gt;、 &lt;strong&gt;、 &lt;b&gt;、 &lt;em&gt;、 &lt;i&gt;、 &lt;del&gt;、 &lt;s&gt;、 &lt;ins&gt;、 &lt;u&gt;、 &lt;span&gt;等， 其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素</code></pre><ul><li><p>相邻行内元素在一行上，一行可以显示多个</p></li><li><p>高、宽直接设置是无效的</p></li><li><p>默认宽度就是它本身内容的宽度</p></li><li><p>行内元素只能容纳文本或则其他行内元素</p></li><li><p>链接里面不能再放链接</p></li><li><p>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全</p></li></ul><h3 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素 inline-block"></a>行内块元素 inline-block</h3><pre><code class="css">在行内元素中有几个特殊的标签 &lt;img /&gt;、 &lt;input /&gt;、 &lt;td&gt;， 可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</code></pre><ul><li>和相邻行内元素（行内块）在一行上, 但是之间会有空白缝隙。一行可以显示多个</li><li>默认宽度就是它本身内容的宽度</li><li>高度，行高、外边距以及内边距都可以控制</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置宽度高度</td><td>容器的100%</td><td>容器级可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以直接设置宽度高度</td><td>它本身内容的宽度</td><td>容纳文本或则其他行内元素</td></tr><tr><td>行内块元素</td><td>一行放多个行内块元素</td><td>可以设置宽度和高度</td><td>它本身内容的宽度</td><td></td></tr></tbody></table><h3 id="转换-display"><a href="#转换-display" class="headerlink" title="转换 display"></a>转换 display</h3><ul><li>块转行内：display:inline; </li><li>行内转块：display:block; </li><li>块、行内元素转换为行内块： display: inline-block; </li></ul><h2 id="行高-line-height"><a href="#行高-line-height" class="headerlink" title="行高 line-height"></a>行高 line-height</h2><ul><li>行高等于高度单行文字会垂直居中</li><li>行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐<ul><li>文字行高 = 盒子高度</li></ul></li><li>行高   =  上距离 +  内容高度  + 下距离 <ul><li>如果 行高 等 高度  文字会 垂直居中</li><li>如果行高 大于 高度   文字会 偏下 </li><li>如果行高小于高度   文字会  偏上 </li></ul></li></ul><p><img src="http://mdimg.95408.com/201912311431_851.png?null" alt=""></p><blockquote><p>当文字行高等于盒子高度：</p></blockquote><p><img src="http://mdimg.95408.com/201912311454_227.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        width: 100px;        height: 80px;        background-color: pink;        line-height: 80px;    }&lt;/style&gt;&lt;div&gt; 文字垂直居中 &lt;/div&gt;</code></pre><h2 id="CSS背景-background"><a href="#CSS背景-background" class="headerlink" title="CSS背景 background"></a>CSS背景 background</h2><p><img src="http://mdimg.95408.com/201912311501_370.png?null" alt=""></p><h3 id="背景颜色-background-color"><a href="#背景颜色-background-color" class="headerlink" title="背景颜色 background-color"></a>背景颜色 background-color</h3><pre><code class="css">background-color: red;/* 默认的值是 transparent 透明的  */</code></pre><h3 id="背景图片-background-image"><a href="#背景图片-background-image" class="headerlink" title="背景图片 background-image"></a>背景图片 background-image</h3><pre><code class="css">background-image : none | url(url地址);background-image : url(images/demo.png);</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>none</td><td align="center">无背景图（默认的）</td></tr><tr><td>url</td><td align="center">使用绝对或相对地址指定背景图像</td></tr></tbody></table><p>我们提倡 背景图片后面的地址，url不要加引号。</p><h3 id="背景平铺-background-repeat"><a href="#背景平铺-background-repeat" class="headerlink" title="背景平铺 background-repeat"></a>背景平铺 background-repeat</h3><pre><code class="css">background-repeat : repeat | no-repeat | repeat-x | repeat-y</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>repeat</td><td align="center">背景图像在纵向和横向上平铺（默认的）</td></tr><tr><td>no-repeat</td><td align="center">背景图像不平铺</td></tr><tr><td>repeat-x</td><td align="center">背景图像在横向上平铺</td></tr><tr><td>repeat-y</td><td align="center">背景图像在纵向平铺</td></tr></tbody></table><h3 id="背景位置-background-position"><a href="#背景位置-background-position" class="headerlink" title="背景位置 background-position"></a>背景位置 background-position</h3><pre><code class="css">background-position : length || length background-position : position || position</code></pre><table><thead><tr><th>参数</th><th align="center">值</th></tr></thead><tbody><tr><td>length</td><td align="center">百分数 | 由浮点数字和单位标识符组成的长度值</td></tr><tr><td>position</td><td align="center">top | center | bottom | left | center | right   方位名词</td></tr></tbody></table><ul><li>必须先指定background-image属性</li><li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li><li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致</li><li>如果只指定了一个方位名词，另一个值默认居中对齐。</li><li>如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y</li><li>如果只指定一个数值, 那该数值一定是x坐标，另一个默认垂直居中</li><li>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</li></ul><p><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></p><pre><code class="css">div {    width: 800px;    height: 500px;    background-color: pink;    /*背景图片 1. 必须加url 2. url 里面的地址不要加 引号*/    background-image: url(images/l.jpg);    /*背景图片不平铺*/    background-repeat: no-repeat;    /*背景位置*/    /*background-position: x坐标 y坐标;*/    /*background-position: right top; 右上角*/    /*background-position: left bottom; 左下角*/    /*background-position: center center; 水平居中 垂直居中*/    /*则两个值前后顺序无关 因为是方位名词*/    /*background-position:  center left; */    /*如果只指定了一个方位名词，另一个值默认居中对齐*/    background-position: top;    /*以下说明  x 10像素  y 垂直居中的*/    /*background-position: 10px center;*/    background-position: center 10px;    /*这种写法一般是我们以后常用 超大背景图片的做法 背景定位*/    background-position: center top;}</code></pre><h3 id="背景附着-background-attachment"><a href="#背景附着-background-attachment" class="headerlink" title="背景附着 background-attachment"></a>背景附着 background-attachment</h3><p>背景附着就是解释背景是滚动的还是固定的</p><pre><code class="css">background-attachment: scroll | fixed</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>scroll</td><td align="center">背景图像是随对象内容滚动</td></tr><tr><td>fixed</td><td align="center">背景图像固定</td></tr></tbody></table><pre><code class="css">div {    height: 3000px;    background-image: url(images/sms.jpg);    background-repeat: no-repeat;    /* 超大背景图片背景定位 */    background-position: center top;    /* 背景固定 */    background-attachment: fixed;}</code></pre><h3 id="背景连写-background"><a href="#背景连写-background" class="headerlink" title="背景连写 background"></a>背景连写 background</h3><ul><li>background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</li><li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; </li></ul><pre><code class="css">background: transparent url(image.jpg) repeat-y scroll center top;</code></pre><pre><code class="css">body {    background-color: #ccc;    background-image: url(images/sms.jpg);    background-repeat: no-repeat;    background-position: center top;    background-attachment: fixed;    /*background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;*/    background: #ccc url(images/sms.jpg) no-repeat fixed center top;}</code></pre><h3 id="背景透明-rgba"><a href="#背景透明-rgba" class="headerlink" title="背景透明 rgba"></a>背景透明 rgba</h3><pre><code class="css">background: rgba(0, 0, 0, 0.3);</code></pre><ul><li>最后一个参数是alpha 透明度  取值范围 0~1之间</li><li>我们习惯把0.3 的 0 省略掉  这样写  background: rgba(0, 0, 0, .3); </li><li>注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>属性</th><th align="left">作用</th><th align="left">值</th></tr></thead><tbody><tr><td>background-color</td><td align="left">背景颜色</td><td align="left">预定义的颜色值/十六进制/RGB代码</td></tr><tr><td>background-image</td><td align="left">背景图片</td><td align="left">url(图片路径)</td></tr><tr><td>background-repeat</td><td align="left">是否平铺</td><td align="left">repeat/no-repeat/repeat-x/repeat-y</td></tr><tr><td>background-position</td><td align="left">背景位置</td><td align="left">length/position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法</td></tr><tr><td>background-attachment</td><td align="left">背景固定还是滚动</td><td align="left">scroll/fixed</td></tr><tr><td>背景简写</td><td align="left">更简单</td><td align="left">背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 他们没有顺序</td></tr><tr><td>背景透明</td><td align="left">让盒子半透明</td><td align="left">background: rgba(0, 0, 0, 0.3); 后面必须是 4个值</td></tr></tbody></table><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><p><img src="http://mdimg.95408.com/201912311502_77.png?null" alt=""></p><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>所谓层叠性是指多种CSS样式的叠加；</p><ul><li>样式冲突，遵循的原则是<strong>就近原则。</strong> 那个样式离着结构近，就执行那个样式。</li><li>样式不冲突，不会层叠</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li>子标签会继承父标签的某些样式，如文本颜色和字号。</li><li>想要设置一个可继承的属性，只需将它应用于父元素即可。</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><h4 id="权重计算公式"><a href="#权重计算公式" class="headerlink" title="权重计算公式"></a>权重计算公式</h4><p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p><table><thead><tr><th>标签选择器</th><th>计算权重公式</th></tr></thead><tbody><tr><td>继承或者</td><td>0, 0, 0, 0</td></tr><tr><td>每个元素（标签选择器）</td><td>0, 0, 0, 1</td></tr><tr><td>每个类、伪类</td><td>0, 0, 1, 0</td></tr><tr><td>每个ID</td><td>0, 1, 0, 0</td></tr><tr><td>每个行内样式 style=””</td><td>1, 0, 0, 0</td></tr><tr><td>每个!important  重要的</td><td>∞ 无穷大</td></tr></tbody></table><p>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 </p><h4 id="权重叠加"><a href="#权重叠加" class="headerlink" title="权重叠加"></a>权重叠加</h4><p>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p><p>就是一个简单的加法计算</p><ul><li>div ul  li   ——&gt;      0, 0, 0, 3</li><li>.nav ul li   ——&gt;      0, 0, 1, 2</li><li>a:hover      —–—&gt;   0, 0, 1, 1</li><li>.nav a       ——&gt;      0, 0, 1, 1</li></ul><p>数位之间没有进制 比如说： 0, 0, 0, 5 + 0, 0, 0, 5 =0, 0, 0, 10 而不是 0, 0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（三）CSS选择器、字体及外观</title>
      <link href="/2019/12/31/css/html+css%EF%BC%88%E4%B8%89%EF%BC%89CSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E5%8F%8A%E5%A4%96%E8%A7%82/"/>
      <url>/2019/12/31/css/html+css%EF%BC%88%E4%B8%89%EF%BC%89CSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E5%AD%97%E4%BD%93%E5%8F%8A%E5%A4%96%E8%A7%82/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><ul><li>结构(html)与样式(css)相分离；</li><li>设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式；</li></ul><h2 id="引入css样式"><a href="#引入css样式" class="headerlink" title="引入css样式"></a>引入css样式</h2><p><img src="http://mdimg.95408.com/201912311401_442.png?null" alt=""></p><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p>通过标签的style属性来设置元素的样式；</p><pre><code class="html">&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt; 内容 &lt;/div&gt;</code></pre><h3 id="内部样式（内嵌式）"><a href="#内部样式（内嵌式）" class="headerlink" title="内部样式（内嵌式）"></a>内部样式（内嵌式）</h3><p>将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义；</p><pre><code class="css">&lt;head&gt;    &lt;style&gt;        div {            color: red;            font-size: 12px;        }    &lt;/style&gt;&lt;/head&gt;</code></pre><h3 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h3><p>将所有的样式放在一个或多个以<strong>. CSS</strong>为扩展名的外部样式表文件中；</p><pre><code class="html">&lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件所在路径&quot;&gt;&lt;/head&gt;</code></pre><h3 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h3><ul><li>link 是个单标签；</li><li>link标签需要放在head头部标签中，并且指定link标签的三个属性：<ul><li>rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件；</li><li>type：定义所链接文档的类型，在这里需要指定为“text/css”，表示链接的外部文件为CSS样式表；</li><li>href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径；</li></ul></li></ul><h3 id="三种样式表总结（位置）"><a href="#三种样式表总结（位置）" class="headerlink" title="三种样式表总结（位置）"></a>三种样式表总结（位置）</h3><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>没有实现样式和结构相分离</td><td>较少</td><td>控制一个标签（少）</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面（中）</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多，强烈推荐</td><td>控制整个站点（多）</td></tr></tbody></table><p>###样式规则</p><pre><code class="css">h2 {    color: red;    font-size: 20px;}</code></pre><p>说明：</p><pre><code class="css">h2 —— 选择器     指定CSS样式作用于哪个HTML标签 花括号内是对该对象设置的具体样式 color: red; —— 声明     属性和属性值以“键值对”形式出现 color —— 属性     设置的样式属性，例如字体大小、文本颜色等 red —— 值     样式属性的值 属性和值之间用 : 连接多个“键值对”之间用 ; 进行区分</code></pre><h2 id="CSS基础选择器"><a href="#CSS基础选择器" class="headerlink" title="CSS基础选择器"></a>CSS基础选择器</h2><p>作用：找到特定的HTML元素；</p><p><img src="http://mdimg.95408.com/201912311403_198.png?null" alt=""></p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>把某一类标签<strong>全部</strong>选择出来  比如所有的div标签  和 所有的 span标签；</p><pre><code class="css">标签名 {    属性1: 属性值1;    属性2: 属性值2;}div {    font-size: 18px;}</code></pre><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>可以为元素对象定义单独或相同的样式，可以选择一个或者多个标签；</p><p>可以有多个类名，类名中间用空格隔开；</p><pre><code class="css">&lt;div class=&#39;abc&#39;&gt;&lt;/div&gt;.abc {    color: red;}</code></pre><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>元素的id值是唯一的，只能对应于文档中某一个具体的元素；</p><pre><code class="css">&lt;div id=&quot;abc&quot;&gt;&lt;/div&gt;#abc {    color: red;}</code></pre><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>会匹配页面所有的元素，降低页面响应速度，不建议随便使用；</p><pre><code class="css">* {    margin: 0;    /* 定义外边距*/    padding: 0;    /* 定义内边距*/}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>选择器</th><th>作用</th><th>缺点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签，比如p</td><td>不能差异化选择</td><td>较多</td><td>p { color：red; }</td></tr><tr><td>类选择器</td><td>可以选出1个或者多个标签</td><td>可以根据需求选择</td><td>非常多</td><td>.nav { color: red; }</td></tr><tr><td>id选择器</td><td>一次只能选择器1个标签</td><td>只能使用一次</td><td>不推荐使用</td><td>#nav {color: red; }</td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择的太多，有部分不需要</td><td>不推荐使用</td><td>* {color: red; }</td></tr></tbody></table><ul><li>尽量少用通用选择器 <code>*</code> </li><li>尽量少用 ID 选择器</li><li>不使用无具体语义定义的标签选择器 div span</li></ul><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><p><img src="http://mdimg.95408.com/201912311421_984.png?null" alt=""></p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><ul><li>用来选择元素或元素组的<strong>子孙后代</strong></li><li>其写法就是把外层标签写在前面，内层标签写在后面，中间用<strong>空格</strong>分隔 </li></ul><pre><code class="css">/* 父级 子级{属性:属性值;属性:属性值;} */.abc h3 {    color:red;    font-size:16px;}&lt;div class=&quot;abc&quot;&gt;    &lt;h3&gt;&lt;/h3&gt;&lt;/div&gt;</code></pre><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><ul><li>只能选择某元素的<strong>子元素(亲儿子)</strong></li><li>父级标签写在前面，子级标签写在后面，中间跟一个 <code>&gt;</code> 进行连接</li></ul><pre><code class="css">.abc &gt; h3 {    color: red;    font-size: 14px;}&lt;div class=&quot;abc&quot;&gt;    &lt;h3&gt;aaa&lt;/h3&gt;   /* 只能选择此处的h3 */     &lt;div&gt;        &lt;h3&gt;bbb&lt;/h3&gt;   /* 不能选择非子代（孙子）的h3 */    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>必须满足：既有标签一的特点，也有标签二的特点</p><p>两个选择器之间<strong>不能有空格</strong>，如 h3.special，使用较少；</p><pre><code class="css">p.one选择的是：类名为 .one 的段落标签</code></pre><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>将一些样式相同的选择器，写在一起；</p><p>将各个选择器用 <code>,</code> 分隔；</p><pre><code class="css">.abc,#xyz {    color: red;}&lt;div class=&quot;abc&quot;&gt;&lt;/div&gt;&lt;div id=&quot;xyz&quot;&gt;&lt;/div&gt;</code></pre><h3 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h3><pre><code class="css">a:link/* 未访问的链接 */a:visited/* 已访问的链接 */a:hover/* 鼠标移动到链接上 */a:active/* 选定的链接 */</code></pre><p>顺序尽量不要颠倒  按照  lvha 的顺序；</p><p>一般写hover居多；</p><pre><code class="css">a {    /* a是标签选择器  所有的链接 */    font-weight: 700;    font-size: 16px;    color: gray;}a:hover {    /* :hover 是链接伪类选择器 鼠标经过 */    color: red;    /*  鼠标经过的时候，由原来的 灰色 变成了红色 */}</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择元素后代</td><td>是选择所有的子孙后代</td><td>较多</td><td>符号是<strong>空格</strong> .nav a</td></tr><tr><td>子代选择器</td><td>选择 最近一级元素</td><td>只选亲儿子</td><td>较少</td><td>符号是<strong>&gt;</strong>   .nav&gt;p</td></tr><tr><td>交集选择器</td><td>选择两个标签交集的部分</td><td>既是 又是</td><td>较少</td><td><strong>没有符号</strong>  p.one</td></tr><tr><td>并集选择器</td><td>选择某些相同样式的选择器</td><td>可以用于集体声明</td><td>较多</td><td>符号是<strong>逗号</strong> .nav, .header</td></tr><tr><td>链接伪类选择器</td><td>给链接更改状态</td><td></td><td>较多</td><td>重点记住 a{} 和 a:hover  实际开发的写法</td></tr></tbody></table><h2 id="CSS字体-font"><a href="#CSS字体-font" class="headerlink" title="CSS字体 font"></a>CSS字体 font</h2><p><img src="http://mdimg.95408.com/201912311404_478.png?null" alt=""></p><h3 id="font-size-字体大小"><a href="#font-size-字体大小" class="headerlink" title="font-size 字体大小"></a>font-size 字体大小</h3><pre><code class="css">p {    font-size: 20px;}</code></pre><h3 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family 字体"></a>font-family 字体</h3><ul><li>font-family属性用于设置哪一种字体；</li><li>各种字体之间必须使用英文状态下的逗号隔开；</li><li>中文字体、字体中有空格或特殊符号的，用 双引号 包含；</li><li>尽量写Unicode编码字体；</li></ul><pre><code class="css">p {    font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;}</code></pre><h3 id="CSS-Unicode字体"><a href="#CSS-Unicode字体" class="headerlink" title="CSS Unicode字体"></a>CSS Unicode字体</h3><p>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</p><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table><p>尽量只使用宋体和微软雅黑中文字体；</p><h3 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight 字体粗细"></a>font-weight 字体粗细</h3><table><thead><tr><th>属性值</th><th align="left">描述</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值（不加粗的）</td></tr><tr><td>bold</td><td align="left">定义粗体（加粗的）</td></tr><tr><td>100~900</td><td align="left">400 等同于 normal，而 700 等同于 bold</td></tr></tbody></table><p>我们平时更喜欢用数字来表示加粗和不加粗。</p><h3 id="font-style-字体风格"><a href="#font-style-字体风格" class="headerlink" title="font-style 字体风格"></a>font-style 字体风格</h3><p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值，浏览器会显示标准的字体样式  font-style: normal;</td></tr><tr><td>italic</td><td align="left">浏览器会显示斜体的字体样式。</td></tr></tbody></table><p>我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式；</p><h3 id="font-综合设置字体样式"><a href="#font-综合设置字体样式" class="headerlink" title="font 综合设置字体样式"></a>font 综合设置字体样式</h3><pre><code class="css">选择器 {    font: font-style font-weight font-size/line-height font-family;}</code></pre><ul><li>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li><li>其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</li></ul><h3 id="font总结"><a href="#font总结" class="headerlink" title="font总结"></a>font总结</h3><table><thead><tr><th align="left">属性</th><th align="left">表示</th><th align="left">注意点</th></tr></thead><tbody><tr><td align="left">font-size</td><td align="left">字号</td><td align="left">我们通常用的单位是px 像素，一定要跟上单位</td></tr><tr><td align="left">font-family</td><td align="left">字体</td><td align="left">实际工作中按照团队约定来写字体</td></tr><tr><td align="left">font-weight</td><td align="left">字体粗细</td><td align="left">记住加粗是 700 或者 bold  不加粗 是 normal 或者  400  记住数字不要跟单位</td></tr><tr><td align="left">font-style</td><td align="left">字体样式</td><td align="left">记住倾斜是 italic     不倾斜 是 normal  工作中我们最常用 normal</td></tr><tr><td align="left">font</td><td align="left">字体连写</td><td align="left">1. 字体连写是有顺序的  不能随意换位置 2. 其中字号 和 字体 必须同时出现</td></tr></tbody></table><pre><code class="css">body {    font-size: 16px;}.title {    /* 字体大小 */    font-size: 20px;    /*设置字体        */    font-family: Arial, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, &quot;黑体&quot;;    /*字体加粗    */    /*font-weight: bold; */    /*这个 700 一定不要跟单位  700 等价于 bold*/    font-weight: 700;    /*字体倾斜*/    font-style: italic;    /*综合性写法*/    /* font: font-style  font-weight  font-size/line-height  font-family;*/    font: italic 700 20px &quot;微软雅黑&quot;;}h1 {    /*让粗体的不加粗*/    /*font-weight: normal;  400 等价于 normal*/    font-weight: 400;}em {    /* 让倾斜的字体 不倾斜 */    font-style: normal;}</code></pre><h2 id="CSS文本外观属性"><a href="#CSS文本外观属性" class="headerlink" title="CSS文本外观属性"></a>CSS文本外观属性</h2><p><img src="http://mdimg.95408.com/201912311404_428.png?null" alt=""></p><h3 id="color-文本颜色"><a href="#color-文本颜色" class="headerlink" title="color 文本颜色"></a>color 文本颜色</h3><p>其取值方式有如下3种：</p><table><thead><tr><th align="left">表示表示</th><th align="left">属性值</th></tr></thead><tbody><tr><td align="left">预定义的颜色值</td><td align="left">red，green，blue，还有我们的御用色 pink</td></tr><tr><td align="left">十六进制</td><td align="left">#FF0000，#FF6600，#29D794</td></tr><tr><td align="left">RGB代码</td><td align="left">rgb(255, 0, 0)或rgb(100%, 0%, 0%)</td></tr></tbody></table><p>我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如  #f00 代表红色</p><h3 id="text-align-文本水平对齐"><a href="#text-align-文本水平对齐" class="headerlink" title="text-align 文本水平对齐"></a>text-align 文本水平对齐</h3><p>可用属性值如下：</p><table><thead><tr><th>属性</th><th align="center">解释</th></tr></thead><tbody><tr><td>left</td><td align="center">左对齐（默认值）</td></tr><tr><td>right</td><td align="center">右对齐</td></tr><tr><td>center</td><td align="center">居中对齐</td></tr></tbody></table><blockquote><p><strong>注意：是让盒子里面的内容水平居中， 而不是让盒子居中对齐；</strong></p></blockquote><h3 id="line-height-行间距"><a href="#line-height-行间距" class="headerlink" title="line-height 行间距"></a>line-height 行间距</h3><p>line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p><pre><code class="css">line-height: 24px;</code></pre><h3 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent 首行缩进"></a>text-indent 首行缩进</h3><pre><code class="css">p {    /*行间距*/    line-height: 25px;    /*首行缩进2个字  em  1个em 就是1个字的大小*/    text-indent: 2em;}</code></pre><h3 id="text-decoration-文本装饰"><a href="#text-decoration-文本装饰" class="headerlink" title="text-decoration 文本装饰"></a>text-decoration 文本装饰</h3><p>text-decoration   通常我们用于给链接修改装饰效果</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。 取消下划线（最常用）</td></tr><tr><td>underline</td><td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td></tr><tr><td>overline</td><td>定义文本上的一条线。（不用）</td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。（不常用）</td></tr></tbody></table><h3 id="CSS外观属性总结"><a href="#CSS外观属性总结" class="headerlink" title="CSS外观属性总结"></a>CSS外观属性总结</h3><table><thead><tr><th align="left">属性</th><th align="left">表示</th><th align="left">注意点</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">颜色</td><td align="left">我们通常用  十六进制   比如 而且是简写形式 #fff</td></tr><tr><td align="left">line-height</td><td align="left">行高</td><td align="left">控制行与行之间的距离</td></tr><tr><td align="left">text-align</td><td align="left">水平对齐</td><td align="left">可以设定文字水平的对齐方式</td></tr><tr><td align="left">text-indent</td><td align="left">首行缩进</td><td align="left">通常我们用于段落首行缩进2个字的距离   text-indent: 2em;</td></tr><tr><td align="left">text-decoration</td><td align="left">文本修饰</td><td align="left">记住 添加 下划线  underline  取消下划线  none</td></tr></tbody></table><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（二）表格、列表和表单</title>
      <link href="/2019/12/30/css/html+css%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A1%A8%E6%A0%BC%E3%80%81%E5%88%97%E8%A1%A8%E5%92%8C%E8%A1%A8%E5%8D%95/"/>
      <url>/2019/12/30/css/html+css%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A1%A8%E6%A0%BC%E3%80%81%E5%88%97%E8%A1%A8%E5%92%8C%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>表格、表单、列表</p></blockquote><p><img src="http://mdimg.95408.com/201912302312_919.png?null" alt="表格、表单、列表"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>表格可以让数据显示的非常的规整，可读性非常好；</li><li>不是用来布局，常见显示、展示表格式数据；</li><li>特别是后台展示数据的时候表格运用是否熟练就显得很重要；</li><li>表格不要纠结于外观，用CSS表达；</li></ul><h3 id="创建表格-table、tr、td"><a href="#创建表格-table、tr、td" class="headerlink" title="创建表格 table、tr、td"></a>创建表格 table、tr、td</h3><p><a href="https://www.w3school.com.cn/tags/tag_table.asp" target="_blank" rel="noopener">w3school</a></p><p>基本的三对HTML标签，分别为 <code>table</code> 、 <code>tr</code> 、 <code>td</code> ，他们是创建表格的基本标签，缺一不可；</p><pre><code class="html">&lt;!-- 一个表格 --&gt;&lt;table&gt;    &lt;tr&gt;     &lt;!-- 表格中的第一行 --&gt;        &lt;td&gt;第一行第一格 每个td就是一行中的每一格&lt;/td&gt;        &lt;td&gt;第一行第二格 每个td就是一行中的每一格&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;     &lt;!-- 表格中的第二行 --&gt;        &lt;td&gt;第二行第一格 每个td就是一行中的每一格&lt;/td&gt;        &lt;td&gt;第二行第二格 每个td就是一行中的每一格&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><ol><li><code>table</code> 用于定义一个 <code>表格</code> ；</li><li><code>tr</code> 标签用于定义表格中的 <code>行</code> ，必须嵌套在 table标签中；</li><li><code>td</code> （table data）用于定义表格中的 <code>单元格</code> ，必须嵌套在<tr></tr>标签中，用来存储数据；</li></ol><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>border</td><td>像素值</td><td>表格的边框</td></tr><tr><td>cellpadding</td><td>像素值 默认1</td><td>规定单元格<strong>边框</strong>与<strong>内容</strong>之间的空白</td></tr><tr><td>cellspacing</td><td>像素值 默认2</td><td>规定<strong>单元格</strong>与<strong>单元格之间</strong>的空白</td></tr><tr><td>align</td><td>left   center   right</td><td>不赞成使用。请使用样式代替。</td></tr><tr><td>width</td><td>像素值  百分比</td><td>规定表格的宽度</td></tr><tr><td>height</td><td>像素值  百分比</td><td>规定表格的高度</td></tr></tbody></table><p>三参为0：</p><p>我们经常有个说法，是三参为0，  平时开发的我们这三个参数 border、cellpadding、cellspacing 为 0；</p><p><img src="http://mdimg.95408.com/201912302331_813.png?null" alt=""></p><p>单元格与单元格之间的空白cellspacing：</p><p><img src="http://mdimg.95408.com/201912302334_428.png?null" alt=""></p><pre><code class="html">&lt;!-- 左：cellspacing=&quot;10&quot; --&gt;&lt;!-- 右：cellspacing=&quot;0&quot; --&gt;&lt;table width=&quot;500&quot; height=&quot;300&quot; border=&quot;1&quot; cellpadding=&quot;20&quot; cellspacing=&quot;0&quot; align=&quot;center&quot;&gt;    &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;性别&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;张三&lt;/td&gt;        &lt;td&gt;男&lt;/td&gt;        &lt;td&gt;55&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李四&lt;/td&gt;        &lt;td&gt;男&lt;/td&gt;        &lt;td&gt;52&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;王五&lt;/td&gt;        &lt;td&gt;男&lt;/td&gt;        &lt;td&gt;58&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;赵六&lt;/td&gt;        &lt;td&gt;男&lt;/td&gt;        &lt;td&gt;18&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h3 id="表头单元格-th"><a href="#表头单元格-th" class="headerlink" title="表头单元格 th"></a>表头单元格 th</h3><ul><li>表头单元格位于表格的第一行或第一列，并且文本加粗居中；</li><li>只需用表头标签 <code>th</code> 替代相应的单元格标签 <code>td</code> 即可；</li></ul><pre><code class="html">&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt; &lt;!-- 表头单元格th --&gt;        &lt;th&gt;性别&lt;/th&gt;         &lt;th&gt;电话&lt;/th&gt;     &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;张三&lt;/td&gt; &lt;!-- 普通单元格td --&gt;        &lt;td&gt;男&lt;/td&gt;         &lt;td&gt;28&lt;/td&gt;     &lt;/tr&gt;&lt;/table&gt;</code></pre><h3 id="表格标题-caption"><a href="#表格标题-caption" class="headerlink" title="表格标题 caption"></a>表格标题 caption</h3><pre><code class="html">&lt;table&gt;    &lt;caption&gt;我是表格标题：四大名人年龄表&lt;/caption&gt;    &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;        &lt;th&gt;性别&lt;/th&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><ol><li>caption 元素定义<strong>表格标题</strong>，通常这个标题会被居中且显示于表格之上；</li><li>caption 标签必须紧随 table 标签之后；</li><li>这个标签只存在 表格里面才有意义；</li></ol><h3 id="合并单元格-rowspan、colspan"><a href="#合并单元格-rowspan、colspan" class="headerlink" title="合并单元格 rowspan、colspan"></a>合并单元格 rowspan、colspan</h3><p><strong>合并单元格2种方式</strong></p><ul><li>跨行合并：rowspan=”合并单元格的个数”      </li><li>跨列合并：colspan=”合并单元格的个数”</li></ul><p><img src="http://mdimg.95408.com/201912302347_304.png?null" alt=""></p><p><strong>合并单元格顺序</strong></p><ul><li>先上、后下、先左、后右的顺序；</li><li><strong>顺序在前</strong>的 td 上写规则 <code>td rowspan=&quot;跨行合并td数量&quot;</code> 或者 <code>&lt;td colspan=&quot;跨列合并td数量&quot;&gt;</code> ；</li><li>删除<strong>顺序在后</strong>的 td ；</li></ul><p><strong>将普通表格合并</strong></p><p><img src="http://mdimg.95408.com/201912310001_303.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912310006_234.png?null" alt=""></p><pre><code class="html">&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;240&quot; align=&quot;center&quot; cellspacing=&quot;0&quot;&gt;    &lt;caption&gt; 个人简历 &lt;/caption&gt;    &lt;tr&gt;        &lt;td&gt;张三&lt;/td&gt;        &lt;td&gt;男&lt;/td&gt;        &lt;td&gt;18&lt;/td&gt;        &lt;!-- 将第二行tr的最后一格td合并 --&gt;        &lt;td rowspan=&quot;2&quot;&gt;照片&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;身高 180&lt;/td&gt;        &lt;td&gt;汉族&lt;/td&gt;        &lt;td&gt;已婚&lt;/td&gt;        &lt;!-- &lt;td&gt;照片&lt;/td&gt; --&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;个人作品&lt;/td&gt;        &lt;!-- 将第三行tr的第二、三、四个格td合并 --&gt;        &lt;td colspan=&quot;3&quot;&gt;个人作品&lt;/td&gt;        &lt;!-- &lt;td&gt;个人作品&lt;/td&gt; --&gt;        &lt;!-- &lt;td&gt;个人作品&lt;/td&gt; --&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;个人简历&lt;/td&gt;        &lt;!-- 将第四行tr的第二、三、四个格td合并 --&gt;        &lt;td colspan=&quot;3&quot;&gt;个人简历&lt;/td&gt;        &lt;!-- &lt;td&gt;个人简历&lt;/td&gt; --&gt;        &lt;!-- &lt;td&gt;个人简历&lt;/td&gt; --&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h3 id="表达结构-thead、tbody"><a href="#表达结构-thead、tbody" class="headerlink" title="表达结构 thead、tbody"></a>表达结构 thead、tbody</h3><ul><li>将表格分成三个部分：题头 <code>thead</code> 、正文 <code>tbody</code> 和脚注 <code>tfoot</code> 来标注， 这样更好的分清表格结构；</li><li>以上标签都是放到table标签中；</li></ul><pre><code class="html">&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; width=&quot;500&quot;&gt;    &lt;!-- 题头 thead --&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;姓名&lt;/th&gt;            &lt;th&gt;性别&lt;/th&gt;            &lt;th&gt;年龄&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;!-- 正文 tbody --&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;刘德华&lt;/td&gt;            &lt;td&gt;男&lt;/td&gt;            &lt;td&gt;55&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;!-- 脚注 tfoot --&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td&gt;信息地址&lt;/td&gt;            &lt;td colspan=&quot;2&quot;&gt;湖南长沙&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>表格是用来显示数据的，那么列表就是用来布局的；</p><p>列表整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高；</p><h3 id="无序列表-ul"><a href="#无序列表-ul" class="headerlink" title="无序列表 ul"></a>无序列表 ul</h3><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。</p><p> 1.ul 中只能嵌套 li，直接在ul签中输入其他标签或者文字的做法是不被允许的<br> 2.li 与 li 之间相当于一个容器，可以容纳所有元素<br> 3. 无序列样式属性让CSS来</p><pre><code class="html">&lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="有序列表-ol"><a href="#有序列表-ol" class="headerlink" title="有序列表 ol"></a>有序列表 ol</h3><p>有排列顺序的列表，其各个列表项按照一定的顺序排列定义；</p><pre><code class="html">&lt;ol&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;&lt;/ol&gt;</code></pre><h3 id="自定义列表-dl"><a href="#自定义列表-dl" class="headerlink" title="自定义列表 dl"></a>自定义列表 dl</h3><p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。</p><pre><code class="html">&lt;dl&gt;    &lt;dt&gt;帮助中心&lt;/dt&gt;    &lt;dd&gt;账户管理&lt;/dd&gt;    &lt;dd&gt;购物管理&lt;/dd&gt;    ...    &lt;dt&gt;服务支持&lt;/dt&gt;    &lt;dd&gt;售后政策&lt;/dd&gt;    &lt;dd&gt;自助服务&lt;/dd&gt;    ...&lt;/dl&gt;</code></pre><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p><img src="http://mdimg.95408.com/201912311226_319.png?null" alt=""></p><p>表单目的是为了收集用户信息。</p><p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p><blockquote><p>在HTML中，一个完整的表单通常由表单域、表单控件（也称为表单元素）、提示信息和3个部分构成。</p></blockquote><p>*<em>表单控件： *</em></p><p>包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p><p><strong>提示信息：</strong></p><p>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p><p><strong>表单域：</strong>  </p><p>他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p><h3 id="input-表单控件"><a href="#input-表单控件" class="headerlink" title="input 表单控件"></a>input 表单控件</h3><p><a href="https://www.w3school.com.cn/tags/tag_input.asp" target="_blank" rel="noopener">w3school</a></p><pre><code class="html">&lt;input type=&quot;属性值&quot; value=&quot;默认文本值&quot;&gt;</code></pre><ul><li>&lt;input /&gt; 标签为单标签</li><li>type属性设置不同的属性值用来指定不同的控件类型</li></ul><p><img src="http://mdimg.95408.com/201912310028_712.png?null" alt=""></p><h4 id="1-type-属性"><a href="#1-type-属性" class="headerlink" title="1.type 属性"></a>1.type 属性</h4><ul><li>这个属性通过改变值，可以决定了你属于那种input表单。</li><li>比如 type = ‘text’  就表示 文本框 可以做 用户名， 昵称等。</li><li>比如 type = ‘password’  就是表示密码框   用户输入的内容 是不可见的。</li></ul><pre><code class="html">用户名: &lt;input type=&quot;text&quot; /&gt;密  码：&lt;input type=&quot;password&quot; /&gt;</code></pre><h4 id="2-value属性-值"><a href="#2-value属性-值" class="headerlink" title="2.value属性   值"></a>2.value属性   值</h4><pre><code class="html">用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt;</code></pre><ul><li>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</li></ul><h4 id="3-name属性"><a href="#3-name属性" class="headerlink" title="3.name属性"></a>3.name属性</h4><pre><code class="html">用户名: &lt;input type=&quot;text&quot; name=“username” /&gt;</code></pre><p>name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</p><ul><li><p>name属性后面的值，是我们自己定义的。</p></li><li><p>radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以多个选其中的一个啦</p></li></ul><pre><code class="html">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; 女</code></pre><ul><li>name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</li></ul><h4 id="4-checked属性"><a href="#4-checked属性" class="headerlink" title="4.checked属性"></a>4.checked属性</h4><ul><li>表示默认选中状态，<strong>较常见于单选按钮和复选按钮</strong>。</li></ul><pre><code class="html">性 别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女</code></pre><p>上面这个，表示就默认选中了 男 这个单选按钮</p><h4 id="5-input-属性小结"><a href="#5-input-属性小结" class="headerlink" title="5.input 属性小结"></a>5.input 属性小结</h4><table><thead><tr><th>属性</th><th align="left">说明</th><th>作用</th></tr></thead><tbody><tr><td>type</td><td align="left">表单类型</td><td>用来指定不同的控件类型</td></tr><tr><td>value</td><td align="left">表单值</td><td>表单里面默认显示的文本</td></tr><tr><td>name</td><td align="left">表单名字</td><td>页面中的表单很多，name主要作用就是用于区别不同的表单。</td></tr><tr><td>checked</td><td align="left">默认选中</td><td>表示那个单选或者复选按钮一开始就被选中了</td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912310055_261.png?null" alt=""></p><pre><code class="html">&lt;!-- type text  是一个文本框 --&gt;用户名： &lt;input type=&quot;text&quot; value=&quot;请输入用户名&quot; name=&quot;username&quot; /&gt;&lt;!-- type password  是一个密码框 --&gt;密码： &lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;!-- type radio 单选框 --&gt;性别：男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot; /&gt;未知 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;&lt;!-- type checkbox 复选框 --&gt;爱好:睡觉 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked=&quot;checked&quot; /&gt;爬山 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; /&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; /&gt;&lt;!-- type button/submit/reset 按钮 需要value值 --&gt;&lt;input type=&quot;button&quot; value=&quot;获取验证码&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;&lt;!-- type image 图片提交按钮 里面必须包含 src 属性 --&gt;&lt;input type=&quot;image&quot; src=&quot;images/btn.png&quot; /&gt;&lt;!-- type file 文件域 上传文件 --&gt;上传头像: &lt;input type=&quot;file&quot; /&gt;</code></pre><h3 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h3><p>label标签主要目的是为了提高用户体验，为用户提高最优秀的服务。</p><p>label 标签为 input 元素定义标注（标签）。</p><p>用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p><p>绑定元素</p><ol><li>第一种用法就是用label直接包括input表单。</li></ol><pre><code class="html">&lt;label&gt;    &lt;!-- 用户名： --&gt;    &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt;&lt;/label&gt;</code></pre><p>   适合单个表单选择</p><ol start="2"><li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li></ol><pre><code class="html">&lt;label for=&quot;nc&quot;&gt;昵称：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;nc&quot; /&gt;d=&quot;sex&quot;&gt;</code></pre><blockquote><p>当我们鼠标点击 label标签里面的文字时， 光标会定位到指定的表单里面</p></blockquote><h3 id="textarea控件-文本域"><a href="#textarea控件-文本域" class="headerlink" title="textarea控件(文本域)"></a>textarea控件(文本域)</h3><pre><code class="html">&lt;textarea&gt;  &lt;!-- 文本内容 --&gt;&lt;/textarea&gt;</code></pre><p>通过textarea控件可以轻松地创建多行文本输入框.</p><p>cols=”每行中的字符数”、rows=”显示的行数”，实际开发不用</p><p><strong>文本框和文本域区别</strong></p><table><thead><tr><th align="left">表单</th><th align="center">名称</th><th align="center">区别</th><th align="right">默认值显示</th><th align="right">用于场景</th></tr></thead><tbody><tr><td align="left">input type=”text”</td><td align="center">文本框</td><td align="center">只能显示一行文本</td><td align="right">单标签，通过value显示默认值</td><td align="right">用户名、昵称、密码等</td></tr><tr><td align="left">textarea</td><td align="center">文本域</td><td align="center">可以显示多行文本</td><td align="right">双标签，默认值写到标签中间</td><td align="right">留言板</td></tr></tbody></table><h3 id="select下拉列表"><a href="#select下拉列表" class="headerlink" title="select下拉列表"></a>select下拉列表</h3><ul><li>如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表；</li><li>select 中至少包含一对 option ；</li><li>在option 中定义selected =” selected “时，当前项即为默认选中项；</li></ul><pre><code class="html">&lt;select&gt;    &lt;option selected=&quot; selected&quot;&gt;选项1&lt;/option&gt;    &lt;option&gt;选项2&lt;/option&gt;    &lt;option&gt;选项3&lt;/option&gt;    &lt;!-- ... --&gt;&lt;/select&gt;</code></pre><p><img src="http://mdimg.95408.com/201912310059_791.png?null" alt=""></p><pre><code class="html">籍贯：&lt;!-- 省份选择 --&gt;&lt;select&gt;    &lt;option&gt;请选择省份&lt;/option&gt;    &lt;!-- selected=&quot;selected&quot; 表示默认选中北京 --&gt;    &lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt;    &lt;option&gt;天津&lt;/option&gt;    &lt;option&gt;上海&lt;/option&gt;    &lt;option&gt;山东&lt;/option&gt;&lt;/select&gt;&lt;!-- 城市选择 --&gt;&lt;select&gt;    &lt;option&gt;请选择城市&lt;/option&gt;    &lt;option&gt;海淀区&lt;/option&gt;    &lt;option&gt;昌平区&lt;/option&gt;    &lt;option&gt;通州区&lt;/option&gt;    &lt;option&gt;雄安区&lt;/option&gt;&lt;/select&gt;</code></pre><h3 id="form-表单域"><a href="#form-表单域" class="headerlink" title="form 表单域"></a>form 表单域</h3><ul><li>收集的用户信息通过form表单域传递给服务器；</li><li>在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器；</li></ul><pre><code class="html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;    &lt;!-- 各种表单控件 --&gt;&lt;/form&gt;</code></pre><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th align="left">属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td align="left">url地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址。</td></tr><tr><td>method</td><td align="left">get/post</td><td>用于设置表单数据的提交方式，其取值为get或post。</td></tr><tr><td>name</td><td align="left">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单。</td></tr></tbody></table><p>将 <code>user</code> 表单通过 <code>post</code> 请求方式向页面 <code>admin/user.html</code> 文件发送数据：</p><pre><code class="html">&lt;form action=&quot;admin/user.html&quot; method=&quot;post&quot; name=&quot;user&quot;&gt;    用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br /&gt;    密码: &lt;input type=&quot;password&quot; name=&quot;pwd&quot; /&gt;&lt;br /&gt;    &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><h3 id="元素属性写法约定"><a href="#元素属性写法约定" class="headerlink" title="元素属性写法约定"></a>元素属性写法约定</h3><ul><li>元素属性值使用双引号语法</li><li>元素属性值可以写上的都写上</li></ul><pre><code class="html">&lt;!-- 推荐： --&gt;&lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; /&gt;&lt;!-- 不推荐： --&gt;&lt;input type=text /&gt; &lt;input type=&#39;text&#39; /&gt;&lt;input type=&quot;radio&quot; name=&quot;name&quot; checked /&gt;</code></pre><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>W3C :  <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a></p><p>MDN: <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></p><p>Todo: <a href="https://www.w3school.com.cn/html/html_forms.asp" target="_blank" rel="noopener">w3school HTML 表单</a></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html+css（一）html标签</title>
      <link href="/2019/12/30/css/html+css%EF%BC%88%E4%B8%80%EF%BC%89html%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/12/30/css/html+css%EF%BC%88%E4%B8%80%EF%BC%89html%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h3 id="html骨架"><a href="#html骨架" class="headerlink" title="html骨架"></a>html骨架</h3><table><thead><tr><th>标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td>html</td><td align="center">HTML标签</td><td align="left">页面中最大的标签，我们成为  根标签</td></tr><tr><td>head</td><td align="center">文档的头部</td><td align="left">注意在head标签中我们必须要设置的标签是title</td></tr><tr><td>titile</td><td align="center">文档的标题</td><td align="left">让页面拥有一个属于自己的网页标题</td></tr><tr><td>body</td><td align="center">文档的主体</td><td align="left">元素包含文档的所有内容，页面内容 基本都是放到body里面的</td></tr></tbody></table><p>约定：</p><p>HTML标签名、类名、标签属性和大部分属性值统一用小写；</p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    ……&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>带有“&lt; &gt;”符号的元素被称为HTML标签；</p><p>双标签</p><pre><code class="html">&lt;body&gt; 双标签 &lt;/body&gt;</code></pre><p>单标签</p><pre><code class="html">&lt;br /&gt;</code></pre><p>嵌套关系</p><pre><code class="html">&lt;head&gt;    &lt;title&gt; &lt;/title&gt;&lt;/head&gt;</code></pre><p>并列关系</p><pre><code class="html">&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;</code></pre><h3 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h3><p>告知浏览器文档使用哪种 HTML 或 XHTML 规范；</p><pre><code class="html">&lt;!DOCTYPE html&gt;</code></pre><h3 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h3><p>指定html 语言种类；en 英语、zh-CN 中文；</p><pre><code class="html">&lt;html lang=&quot;zh-CN&quot;&gt;</code></pre><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>告知 html 文件是以 UTF-8 编码保存的， 浏览器根据编码去解码对应的html内容；</p><pre><code class="html">&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h3 id="标题标签h"><a href="#标题标签h" class="headerlink" title="标题标签h"></a>标题标签h</h3><pre><code class="html">&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h4&gt;&lt;/h4&gt;&lt;h5&gt;&lt;/h5&gt;&lt;h6&gt;&lt;/h6&gt;</code></pre><h3 id="段落标签-p"><a href="#段落标签-p" class="headerlink" title="段落标签 p"></a>段落标签 p</h3><pre><code class="html">&lt;p&gt; 文本内容 &lt;/p&gt;</code></pre><h3 id="水平线标签-hr"><a href="#水平线标签-hr" class="headerlink" title="水平线标签 hr"></a>水平线标签 hr</h3><pre><code class="html">&lt;hr /&gt;     &lt;!-- 是一个单标签 --&gt;</code></pre><h3 id="换行标签-br"><a href="#换行标签-br" class="headerlink" title="换行标签 br"></a>换行标签 br</h3><pre><code class="html">&lt;br /&gt;</code></pre><h3 id="div-和-span"><a href="#div-和-span" class="headerlink" title="div 和 span"></a>div 和 span</h3><ul><li>div、span 是没有语义的，是我们网页布局主要的2个盒子；</li><li>div 就是  division  的缩写：分割、分区的意思，其实有很多div 来组合网页；</li></ul><pre><code class="html">&lt;div&gt; 没有语义的div &lt;/div&gt;&lt;span&gt; 没有语义的span &lt;/span&gt;</code></pre><h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><ul><li>b  只加粗，strong  除了加粗还有强调的意思，语义更强烈；</li><li>剩下同理；</li></ul><pre><code class="html">&lt;b&gt;&lt;/b&gt; 粗体&lt;strong&gt;&lt;/strong&gt; 粗体&lt;i&gt;&lt;/i&gt; 斜体&lt;em&gt;&lt;/em&gt; 斜体&lt;s&gt;&lt;/s&gt; 删除线&lt;del&gt;&lt;/del&gt; 删除线&lt;u&gt;&lt;/u&gt; 下划线&lt;ins&gt;&lt;/ins&gt; 下划线</code></pre><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><ol><li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>采取  键值对 的格式   key=”value”  的格式  </li></ol><pre><code class="html">&lt;img src=&quot;src就是img标签的一个属性&quot; /&gt;</code></pre><h3 id="图像标签-img"><a href="#图像标签-img" class="headerlink" title="图像标签 img"></a>图像标签 img</h3><pre><code class="html">&lt;img src=&quot;tupian.jpg&quot; alt=&quot;图片不能正常显示就显示alt&quot; /&gt;&lt;!-- 可以加标题、宽度、高度、边框等： --&gt;&lt;img src=&quot;timg.gif&quot; title=&quot;标题文字&quot; width=&quot;600&quot; height=&quot;600&quot; border=&quot;10&quot; /&gt;</code></pre><h3 id="链接-a"><a href="#链接-a" class="headerlink" title="链接 a"></a>链接 a</h3><pre><code class="html">&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口弹出方式 _self _blank&quot;&gt;文本或图像&lt;/a&gt;&lt;a href=&quot;http://www.a.com&quot; target=&quot;_blank&quot;&gt;文本或图像&lt;/a&gt;&lt;a href=&quot;demo.html&quot;&gt;文字或图片&lt;/a&gt;</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行（约定）；</p><pre><code class="html">&lt;!-- 这是div内容的注释文字 --&gt;&lt;div&gt;...&lt;/div&gt;</code></pre><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><ul><li>相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的；</li><li><code>../</code> 上级目录、 <code>../../</code> 上上级目录；</li></ul><pre><code class="html">&lt;!-- 同级路径：本文件同一目录下的图片 --&gt;&lt;img src=&quot;timg.gif&quot; /&gt;&lt;!-- 下级路径：本文件同一目录下images中的图片 --&gt;&lt;img src=&quot;images/timg.jpg&quot; /&gt;&lt;!-- 上级路径：本文件上一级目录下images中的图片 --&gt;&lt;img src=&quot;../images/timg.gif&quot; /&gt;</code></pre><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><pre><code class="html">&lt;!-- 我们不提倡使用这种方法 --&gt;&lt;img src=&quot;C:\Users\yuan\Desktop\img\img.jpg&quot; /&gt;&lt;!-- 绝对的网络地址 还是可以用的 --&gt;&lt;img src=&quot;http://www.a.cn/b/c/img.jpg&quot; /&gt;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="锚点定位"><a href="#锚点定位" class="headerlink" title="锚点定位"></a>锚点定位</h3><pre><code class="html">&lt;!-- 使用相应的id名标注跳转目标的位置 --&gt;&lt;h3 id=&quot;two&quot;&gt;第2集大片&lt;/h3&gt;&lt;!-- 创建链接 --&gt;&lt;a href=&quot;#two&quot;&gt;点击查看第2集&lt;/a&gt;</code></pre><h3 id="base标签"><a href="#base标签" class="headerlink" title="base标签"></a>base标签</h3><p>base 可以设置整体链接的打开状态；base 写到 <code>head</code> 标签内；</p><pre><code class="html">&lt;head&gt;    &lt;base target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/body&gt;</code></pre><h3 id="预格式化文本标签"><a href="#预格式化文本标签" class="headerlink" title="预格式化文本标签"></a>预格式化文本标签</h3><p>被包围在 <code>pre</code> 标签 元素中的文本通常会保留空格和换行符；</p><pre><code class="html">&lt;pre&gt;       标题    锄禾日当午，    汗滴禾下土。    谁知盘中餐，    粒粒皆辛苦。&lt;/pre&gt;</code></pre><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><pre><code class="html">&amp;nbsp;   &lt;!-- 空格 --&gt;&amp;lt;     &lt;!-- 小于号 --&gt;&amp;gt;     &lt;!-- 大于号 --&gt;&lt;!-- 以 `&amp;` 开头, 以分号 `;` 结尾； --&gt;</code></pre><p><img src="http://mdimg.95408.com/201912302302_548.png?null" alt=""></p><pre><code class="html">&lt;!-- HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符 --&gt;&lt;!-- 浏览器会将它们作为标签解析 --&gt;&lt;!-- 若要正确显示，在 HTML 源代码中使用字符实体； --&gt;&lt;!-- 推荐： --&gt;&lt;a href=&quot;#&quot;&gt;more &amp;gt;&amp;gt;&lt;/a&gt;&lt;!-- 不推荐： --&gt;&lt;a href=&quot;#&quot;&gt;more &gt;&gt; &lt;/a&gt;</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html+css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap(二)轮播图carousel</title>
      <link href="/2019/12/30/bootstrap/Bootstrap(%E4%BA%8C)%E8%BD%AE%E6%92%AD%E5%9B%BEcarousel/"/>
      <url>/2019/12/30/bootstrap/Bootstrap(%E4%BA%8C)%E8%BD%AE%E6%92%AD%E5%9B%BEcarousel/</url>
      
        <content type="html"><![CDATA[<h3 id="Carousel-轮播图"><a href="#Carousel-轮播图" class="headerlink" title="Carousel 轮播图"></a>Carousel 轮播图</h3><p><a href="http://bootstrap.html.cn/javascript/#carousel" target="_blank" rel="noopener">carousel文档</a></p><ul><li>必须初始化激活元素：<code>.active</code>类需要被添加，否则轮播图将不可见；</li><li>要对最外层的容器（<code>.carousel</code>）使用一个<code>id</code>，控制 carousel（旋转木马）正常工作；</li></ul><pre><code class="html">&lt;!-- id=&quot;huandengpian&quot; 后面的应该一一对应 才能调用js --&gt;&lt;div id=&quot;huandengpian&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;    &lt;!-- 小点点指示器 --&gt;    &lt;ol class=&quot;carousel-indicators&quot;&gt;        &lt;li data-target=&quot;#huandengpian&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;        &lt;li data-target=&quot;#huandengpian&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;        &lt;li data-target=&quot;#huandengpian&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;    &lt;/ol&gt;    &lt;!-- 包裹所有幻灯片内容 --&gt;    &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;        &lt;!-- 单个图片 必须有一个 active --&gt;        &lt;div class=&quot;item active&quot;&gt;            &lt;img src=&quot;img/tb01.jpg&quot; alt=&quot;...&quot;&gt;            &lt;!-- 幻灯片添加说明文字 可以包括html格式 --&gt;            &lt;div class=&quot;carousel-caption&quot;&gt;                &lt;h3&gt;caption标题&lt;/h3&gt;                &lt;p&gt;图片 520*280 px&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;            &lt;img src=&quot;img/tb02.jpg&quot; alt=&quot;...&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;            &lt;img src=&quot;img/tb03.jpg&quot; alt=&quot;...&quot;&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;!-- 左右控制器 --&gt;    &lt;a class=&quot;left carousel-control&quot; href=&quot;#huandengpian&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;        &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;sr-only&quot;&gt;左箭头说明文字&lt;/span&gt;    &lt;/a&gt;    &lt;a class=&quot;right carousel-control&quot; href=&quot;#huandengpian&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;        &lt;span class=&quot;glyphicon glyphicon-forward&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;        &lt;span class=&quot;sr-only&quot;&gt;右箭头说明文字&lt;/span&gt;    &lt;/a&gt;    &lt;!-- 幻灯片结束 --&gt;&lt;/div&gt;</code></pre><ul><li><p>非全宽的幻灯片，可以包含在<code>container</code>容器中或者修改长宽；</p></li><li><p><code>item</code> 修改图片大小；</p></li><li><p>使用<code>row</code>可去除左右各15px的padding；</p></li></ul><pre><code class="html">&lt;div class=&quot;container container-carousel&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        ……    &lt;/div&gt;    &lt;/div&gt;&lt;style&gt;    .container-carousel {        width: 480px;    }    #huandengpian .item {        width: 480px;        height: 260px;    }    .glyphicon {        top: 50%;    }&lt;/style&gt;</code></pre><p><img src="http://mdimg.95408.com/201912302135_67.png?null" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> bootstrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap(一)导航栏navbar</title>
      <link href="/2019/12/30/bootstrap/Bootstrap(%E4%B8%80)%E5%AF%BC%E8%88%AA%E6%A0%8Fnavbar%20/"/>
      <url>/2019/12/30/bootstrap/Bootstrap(%E4%B8%80)%E5%AF%BC%E8%88%AA%E6%A0%8Fnavbar%20/</url>
      
        <content type="html"><![CDATA[<h3 id="导航栏-navbar"><a href="#导航栏-navbar" class="headerlink" title="导航栏 navbar"></a>导航栏 navbar</h3><ul><li>依赖 JavaScript 插件：窗口变窄，只显示logo和汉堡菜单；</li><li>使用 <code>&lt;nav&gt;</code> 元素，或者<code>&lt;div role=&quot;navigation&quot;&gt;</code> 让辅助设备知道是一个导航；</li><li><code>.navbar-brand</code> 已经被设置了 padding 和高度 height；</li><li>表单放置于 <code>.navbar-form</code> 之内可以呈现很好的垂直对齐，并在较窄的视口（viewport）中呈现折叠状态；</li><li>不包含在 <code>&lt;form&gt;</code> 中的 <code>&lt;button&gt;</code> 元素，加上 <code>.navbar-btn</code> 后，可以让它在导航条里垂直居中；</li><li>文本包裹在 <code>&lt;p class=&quot;navbar-text&quot;&gt;&lt;/p&gt;</code>中；</li></ul><table><thead><tr><th>0</th><th>class</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>nav class=”navbar navbar-default”</td><td>导航条</td></tr><tr><td>2</td><td>div class=”container-fluid” 或 “container”</td><td>版心</td></tr><tr><td>3</td><td>div class=”navbar-header”</td><td>包裹logo和汉堡菜单</td></tr><tr><td>4</td><td>a class=”navbar-brand”</td><td>包裹标志文字或者img</td></tr><tr><td>5</td><td>div class=”collapse navbar-collapse”</td><td>包裹菜单ul&gt;li&gt;a链接</td></tr><tr><td>6</td><td>form class=”navbar-form”</td><td>包裹表单</td></tr><tr><td>7</td><td>button class=”navbar-btn”</td><td>包裹按钮</td></tr><tr><td>8</td><td>ul class=”navbar-right”</td><td>菜单向左、向右排列</td></tr><tr><td>9</td><td>a class=”navbar-link”</td><td>链接显示默认颜色和反色设置</td></tr><tr><td>10</td><td>p class=”navbar-text”</td><td>p标签内有正确的行距和颜色</td></tr><tr><td>11</td><td>nav class=”avbar-fixed-top”</td><td>让导航条固定在顶部</td></tr><tr><td>12</td><td>nav class=”navbar-fixed-bottom”</td><td>让导航条固定在底部</td></tr><tr><td>13</td><td>nav class=”navbar-static-top</td><td>静止在顶部</td></tr><tr><td>14</td><td>nav class=”navbar-inverse”</td><td>反色的导航条</td></tr></tbody></table><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><pre><code class="html">&lt;div class=&quot;navbar navbar-default&quot;&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;!-- 标志头部 --&gt;        &lt;div class=&quot;navbar-header&quot;&gt;            &lt;!-- 品牌logo文字或图片 --&gt;            &lt;div class=&quot;navbar-brand&quot;&gt;Logo&lt;/div&gt;        &lt;/div&gt;        &lt;!-- 菜单选项 --&gt;        &lt;div class=&quot;collapse navbar-collapse&quot;&gt;            &lt;!-- 菜单链接 --&gt;            &lt;ul class=&quot;nav navbar-nav&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="html">&lt;!-- navbar 导航条 --&gt;&lt;!-- navbar-default 默认导航条 --&gt;&lt;nav class=&quot;navbar navbar-default&quot;&gt;    &lt;!-- container 按版心居中 --&gt;    &lt;!-- container-fluid 100%版心 --&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;!-- navbar-header 将logo部分分组 更好的移动展示 --&gt;        &lt;div class=&quot;navbar-header&quot;&gt;            &lt;!-- 汉堡菜单显示 --&gt;            &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;                &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;            &lt;/button&gt;            &lt;!-- logo --&gt;            &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;                &lt;!-- logo a标签中直接写文字或者加img --&gt;                &lt;img src=&quot;./img/logo.png&quot; alt=&quot;&quot; class=&quot;center-block&quot;&gt;            &lt;/a&gt;        &lt;/div&gt;        &lt;!-- 可折叠部分 链接 表单 按钮等 --&gt;        &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;            &lt;!-- 菜单链接 --&gt;            &lt;ul class=&quot;nav navbar-nav&quot;&gt;                &lt;!-- 单个链接 --&gt;                &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                &lt;!-- 下拉菜单 --&gt;                &lt;li class=&quot;dropdown&quot;&gt;                    &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;下拉菜单 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt;                    &lt;ul class=&quot;dropdown-menu&quot;&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;下拉菜单1&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;下拉菜单2&lt;/a&gt;&lt;/li&gt;                        &lt;!-- 分隔线 --&gt;                        &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;下拉菜单3&lt;/a&gt;&lt;/li&gt;                    &lt;/ul&gt;                &lt;/li&gt;            &lt;/ul&gt;            &lt;!-- 表单 --&gt;            &lt;form class=&quot;navbar-form navbar-left&quot;&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt;                &lt;/div&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;提交&lt;/button&gt;            &lt;/form&gt;            &lt;!-- 按钮 --&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-primary navbar-btn&quot;&gt;登陆&lt;/button&gt;            &lt;!-- 右侧菜单链接 --&gt;            &lt;!-- hidden-sm 在小屏时隐藏，其他屏按官方的：大中屏正常显示 超小屏蔽显示汉堡菜单 --&gt;            &lt;ul class=&quot;nav navbar-nav navbar-right hidden-sm&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;!-- 可折叠部分结束 --&gt;    &lt;/div&gt;    &lt;!-- container结束 --&gt;&lt;/nav&gt;</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>navbar-brand 有加 -15px 的 padding，去除 container 盒子的paddding；</li><li>navbar-brand 有加四周各15px 的 margin ；</li><li>navbar-brand 中加 img，img 会有 左右各 10px 的 margin；</li></ul><p><img src="http://mdimg.95408.com/201912302204_576.png" alt=""></p><pre><code class="css">/* 自定义 *//* 标志img大小 */.navbar img {    width: 70px;    height: 70px;    margin: 0;}/* navbar-brand */.navbar-brand {    width: 90px;    height: 70px;    padding: 0;}/* 修改导航栏高度 */.navbar-nav&gt;li&gt;a {    font-size: 18px;    padding-top: 25px;    height: 70px;}/* 表单 按钮 汉堡区 */.navbar-form, .navbar-btn, .navbar-toggle {    margin-top: 18px;}</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> bootstrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS移动布局（四）响应式bootstrap</title>
      <link href="/2019/12/27/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E5%93%8D%E5%BA%94%E5%BC%8Fbootstrap/"/>
      <url>/2019/12/27/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E5%93%8D%E5%BA%94%E5%BC%8Fbootstrap/</url>
      
        <content type="html"><![CDATA[<h2 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h2><p>使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。</p><p><strong>响应式布局容器</strong></p><ul><li><p>响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果；</p></li><li><p>在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</p></li><li><p>超小屏幕（手机，小于 768px）：设置宽度为 100%</p></li><li><p>小屏幕（平板，大于等于 768px）：设置宽度为 750px</p></li><li><p>中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</p></li><li><p>大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px </p></li></ul><p><img src="http://mdimg.95408.com/web_2019122718.gif" alt=""></p><pre><code class="html">&lt;style&gt;    .container {        height: 150px;        background-color: pink;        margin: 0 auto;    }    /* 1. 超小屏幕下  小于 768  布局容器的宽度为 100% */    @media screen and (max-width: 767px) {        .container {            width: 100%;        }    }    /* 2. 小屏幕下  大于等于768  布局容器改为 750px */    @media screen and (min-width: 768px) {        .container {            width: 750px;        }    }    /* 3. 中等屏幕下 大于等于 992px   布局容器修改为 970px */    @media screen and (min-width: 992px) {        .container {            width: 970px;        }    }    /* 4. 大屏幕下 大于等于1200 布局容器修改为 1170 */    @media screen and (min-width: 1200px) {        .container {            width: 1170px;        }    }&lt;/style&gt;&lt;body&gt;    &lt;!-- 响应式开发里面，首先需要一个布局容器 --&gt;    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><p>Bootstrap 是基于HTML、CSS 和 JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><pre><code class="bash">// 在网站上下载https://v3.bootcss.com/getting-started/// npm下载$ npm install bootstrap@3</code></pre><p><a href="lhttp://www.bootcss.com/">中文网</a>、  <a href="lhttp://getbootstrap.com/">官网</a></p><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><p>引入 bootstrap.min.css 文件：</p><pre><code class="html">    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;!-- Bootstrap 引入 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./bootstrap/css/bootstrap.min.css&quot;&gt;</code></pre><p>针对 IE 9以下可加上：</p><pre><code class="html">&lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;    &lt;!--[if lt IE 9]&gt;      &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;      &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</code></pre><p>使用 bootstrap 的 js 插件，需要在 <code>&lt;/body&gt;</code>之前加上：</p><pre><code class="html">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="布局容器-container"><a href="#布局容器-container" class="headerlink" title="布局容器 container"></a>布局容器 container</h3><ul><li>所有的类放在 container 容器中，container 容器中的内容会随着屏幕宽度的变化面变化；</li><li>大屏 ( &gt;=1200px)时，container 宽度为1170px；</li><li>中屏( &gt;=992px)时，container 宽度为970px；</li><li>小屏( &gt;=768px)时，container 宽度为750px；</li><li>超小屏时，container 宽度为100%；</li></ul><blockquote><p>  如图：屏幕处理中屏时，container的宽度变成了970px，无需额外样式：</p></blockquote><p><img src="http://mdimg.95408.com/201912272340_717.png?null" alt=""></p><pre><code class="html">&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>.container</p><ul><li>响应式布局的容器  固定宽度</li><li>大屏 ( &gt;=1200px)  宽度定为 1170px</li><li>中屏 ( &gt;=992px)   宽度定为  970px</li><li>小屏 ( &gt;=768px)   宽度定为  750px</li><li>超小屏  (100%) </li></ul><p>.container-fluid</p><ul><li>流式布局容器 百分百宽度</li><li>占据全部视口（viewport）的容器。</li></ul><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p><strong>一</strong></p><ul><li>container 容器自动划分为12等分；</li><li>当有4个元素时：<ul><li>上：2 + 6 + 2 + 2，共计12份，占满一行；</li><li>中：2 + 6 + 1 +1，共计10份，最后留空；</li><li>下：2 + 6 + 4 + 2，共计14份，多的2份下移；</li></ul></li></ul><p><img src="http://mdimg.95408.com/201912280004_525.png?null" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    上：    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-2&quot;&gt;div 2份&lt;/div&gt;        &lt;div class=&quot;col-lg-6&quot;&gt;div 6份&lt;/div&gt;        &lt;div class=&quot;col-lg-2&quot;&gt;div 2份&lt;/div&gt;        &lt;div class=&quot;col-lg-2&quot;&gt;div 2份&lt;/div&gt;    &lt;/div&gt;    中：    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-2&quot;&gt;div 2份&lt;/div&gt;        &lt;div class=&quot;col-lg-6&quot;&gt;div 6份&lt;/div&gt;        &lt;div class=&quot;col-lg-1&quot;&gt;div 1份&lt;/div&gt;        &lt;div class=&quot;col-lg-1&quot;&gt;div 1份&lt;/div&gt;    &lt;/div&gt;    下：    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-2&quot;&gt;div 2份&lt;/div&gt;        &lt;div class=&quot;col-lg-6&quot;&gt;div 6份&lt;/div&gt;        &lt;div class=&quot;col-lg-4&quot;&gt;div 4份&lt;/div&gt;        &lt;div class=&quot;col-lg-2&quot;&gt;div 2份&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>二</strong></p><ul><li>不同屏幕尺寸的响应：<ul><li>col-lg-* 、 col-md-* 、 col-sm-* 、 col-xs-*</li></ul></li><li>当有4个元素时：<ul><li>col-lg-3：大屏时，每个元素占3份，共计12份；</li><li>col-md-4：中屏时，每个元素占4份，前3个占满一行，第4个下移；</li><li>col-sm-6：小屏时，每个元素占6份，前2个占满一行，后2个下移；</li><li>col-xs-12：超小屏，每个元素占12份，每个元素占1行；</li></ul></li></ul><p><img src="http://mdimg.95408.com/web_2019122711.gif" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;div2&lt;/div&gt;    &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;div3&lt;/div&gt;    &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;div1&lt;/div&gt;    &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;div4&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>行（row） 可以去除父容器作用15px的边距</li><li>xs-extra small：超小； sm-small：小；  md-medium：中等； lg-large：大；</li><li>每一列默认有左右15像素的 padding</li></ul><h3 id="栅格嵌套"><a href="#栅格嵌套" class="headerlink" title="栅格嵌套"></a>栅格嵌套</h3><ul><li>container容器中3个元素div1、div2、div3各4份，占满一行；</li><li>将第一个div1中再嵌套2个div1:A 和 div2:B；</li><li>div1 也会默认分成12份，各占6份即可；</li></ul><p><img src="http://mdimg.95408.com/201912280016_58.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .row div {        height: 100px;        border: 1px solid red;    }&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-4&quot;&gt;            &lt;!-- 我们列嵌套最好加1个行 row --&gt;            &lt;!-- 可以取消父元素的padding值 而且高度自动和父级一样高 --&gt;            &lt;div class=&quot;row&quot;&gt;                &lt;div class=&quot;col-lg-6&quot;&gt;div1:A&lt;/div&gt;                &lt;div class=&quot;col-lg-6&quot;&gt;div1:B&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;col-lg-4&quot;&gt;div2&lt;/div&gt;        &lt;div class=&quot;col-lg-4&quot;&gt;div3&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="列偏移-offset"><a href="#列偏移-offset" class="headerlink" title="列偏移 offset"></a>列偏移 offset</h3><ul><li>使用 .col-md-offset-* 类可以将列向右侧偏移；</li><li>上：<ul><li>共有 2 个 div，各占 3 份，剩余 6 份；</li><li>div2 往右偏移 6 份 <code>col-lg-offset-6</code> ；</li><li>形成 div1 靠左、div2 靠右的效果；</li></ul></li><li>下：<ul><li>共有 1 个 div，占 6 份，剩余 6 份；</li><li>div1 往右偏移 3 份 <code>col-lg-offset-3</code> ；</li><li>形成 div1 右边留空 3份，左边 3份，形成居中效果；</li></ul></li></ul><p><img src="http://mdimg.95408.com/201912280027_605.png?null" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    上：    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-3&quot;&gt;div1:3份&lt;/div&gt;        &lt;div class=&quot;col-lg-3 col-lg-offset-6&quot;&gt;div2:3份&lt;/div&gt;    &lt;/div&gt;    下：    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-8 col-lg-offset-2&quot;&gt;div3:8份&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="列排序-push-pull"><a href="#列排序-push-pull" class="headerlink" title="列排序 push pull"></a>列排序 push pull</h3><p>通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。</p><p><img src="http://mdimg.95408.com/201912280039_492.png?null" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-4&quot;&gt;div1:4份:原本在左&lt;/div&gt;        &lt;div class=&quot;col-lg-8 &quot;&gt;div2:8份:原本在右&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-lg-4 col-lg-push-8&quot;&gt;div1:4份:push到了右边&lt;/div&gt;        &lt;div class=&quot;col-lg-8 col-lg-pull-4&quot;&gt;div2:8份:pull到了左边&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="隐藏-hidden"><a href="#隐藏-hidden" class="headerlink" title="隐藏 hidden"></a>隐藏 hidden</h3><ul><li>在 lg、md 时，4个元素各占3份；</li><li>当屏幕缩小到 sm、xs 时，div2 隐藏；</li></ul><p><img src="http://mdimg.95408.com/web_2019122712.gif" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-xs-3&quot;&gt;div1:3份&lt;/div&gt;        &lt;div class=&quot;col-xs-3 hidden-sm hidden-xs&quot;&gt;div2:3份 在sm xs时隐藏&lt;/div&gt;        &lt;div class=&quot;col-xs-3&quot;&gt;div2:3份&lt;/div&gt;        &lt;div class=&quot;col-xs-3&quot;&gt;div2:3份&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="展示-visible"><a href="#展示-visible" class="headerlink" title="展示 visible"></a>展示 visible</h3><ul><li>在 lg、md 时，4个元素各占3份；</li><li>当屏幕放大到 lg 时，div2 显示；</li></ul><p><img src="http://mdimg.95408.com/web_2019122714.gif" alt=""></p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-xs-3&quot;&gt;div1:3份&lt;/div&gt;        &lt;div class=&quot;col-xs-3 visible-lg&quot;&gt;div2:3份 在lg时显示&lt;/div&gt;        &lt;div class=&quot;col-xs-3&quot;&gt;div2:3份&lt;/div&gt;        &lt;div class=&quot;col-xs-3&quot;&gt;div2:3份&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS移动布局（三）rem布局和媒体查询</title>
      <link href="/2019/12/27/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%89%EF%BC%89rem%E5%B8%83%E5%B1%80%E5%92%8C%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/12/27/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%89%EF%BC%89rem%E5%B8%83%E5%B1%80%E5%92%8C%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="rem-基础"><a href="#rem-基础" class="headerlink" title="rem 基础"></a>rem 基础</h2><ul><li>em：相对于父元素的字体大小；</li><li>rem： (root em) 相对于html元素的字体大小；</li><li>rem优势：父元素文字大小可能不一致， 但只有一个html，可以控制整个页面的元素大小；</li></ul><blockquote><p>  html 字体这 10px，div 为 20rem = 200px，span为 10rem = 100px：</p></blockquote><p><img src="http://mdimg.95408.com/201912271258_392.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    html {        font-size: 10px;    }    div {        width: 20rem;        height: 20rem;        border: 1px solid red;    }    span {        display: block;        width: 10rem;        height: 10rem;        background-color: aquamarine;    }&lt;/style&gt;&lt;div&gt;    &lt;span&gt;1&lt;/span&gt;&lt;/div&gt;</code></pre><h2 id="media-媒体查询"><a href="#media-媒体查询" class="headerlink" title="@media 媒体查询"></a>@media 媒体查询</h2><ul><li>媒体查询（Media Query）是CSS3新语法；</li><li>使用 @media查询，可以针对不同的媒体类型定义不同的样式；<ul><li>@media开头</li><li>mediatype  媒体类型</li><li>and  not  only 关键字 </li><li>media feature 媒体特性（小括号包含）</li></ul></li></ul><h3 id="mediatype-媒体类型"><a href="#mediatype-媒体类型" class="headerlink" title="mediatype  媒体类型"></a>mediatype  媒体类型</h3><ul><li>all   用于所有设备</li><li>print   用于打印机和打印预览</li><li>scree   用于电脑屏幕、平板、智能手机</li></ul><h3 id="and-not-only-关键字"><a href="#and-not-only-关键字" class="headerlink" title="and  not  only 关键字"></a>and  not  only 关键字</h3><ul><li>and：可以将多个媒体特性连接到一起，相当于“且”的意思；</li><li>not：排除某个媒体类型，相当于“非”的意思，可以省略；</li><li>only：指定某个特定的媒体类型，可以省略；</li></ul><h3 id="media-feature-媒体特性"><a href="#media-feature-媒体特性" class="headerlink" title="media feature 媒体特性"></a>media feature 媒体特性</h3><ul><li>width   输出设备中 <strong>可见区域</strong> 宽度；</li><li>min-width   输出设备中 <strong>最小</strong> 宽度；</li><li>max-width   输出设备中 <strong>最大</strong> 宽度；</li></ul><h3 id="例：根据屏幕宽度-改变颜色"><a href="#例：根据屏幕宽度-改变颜色" class="headerlink" title="例：根据屏幕宽度 改变颜色"></a>例：根据屏幕宽度 改变颜色</h3><blockquote><p>  根据不同屏幕宽度，改变body的颜色：</p></blockquote><p><img src="http://mdimg.95408.com/web_2019122702.gif" alt=""></p><pre><code class="css">/* max-width 最大宽度539 = 小于等于539时 显示的颜色 */@media screen and (max-width: 539px) {    body {        background-color: #333;    }}/* min-width 最小宽度540 = 大于等于540时 显示的颜色 */@media screen and (min-width: 540px) {    body {        background-color: #666;    }}/* min-width 最小宽度970 = 大于等于970时 显示的颜色 *//* 后面的查询会覆盖前面的，当超过970时显示 */@media screen and (min-width: 970px) {    body {        background-color: #fff;    }}</code></pre><h3 id="例：媒体查询-rem效果"><a href="#例：媒体查询-rem效果" class="headerlink" title="例：媒体查询 + rem效果"></a>例：媒体查询 + rem效果</h3><ul><li>在不同屏幕大小下，html 中的 字体大小 不同；</li><li>div 和 字体 使用 <code>rem</code> 单位；</li><li>实现：不同屏幕大小下，div 和 字体大小发生变化；</li></ul><p><img src="http://mdimg.95408.com/web_2019122703.gif" alt=""></p><pre><code class="html">&lt;style&gt;    * {        margin: 0;        padding: 0;    }    /* 当html写固定时，div大小就固定了 */    /* html {    font-size: 50px;    } */    /* 通过媒体查询，随着屏幕变化，改变html的值 */    /* 小于等于319px时 */    @media screen and (max-width: 319px) {        html {            font-size: 20px;        }    }    /* 大于等于320px时 */    @media screen and (min-width: 320px) {        html {            font-size: 50px;        }    }          /* 大于等于640px时 */    @media screen and (min-width: 640px) {        html {            font-size: 80px;        }    }    div {        /* 宽度：html字体 1rem */        height: 1rem;        /* 字体大小：html字体 0.5rem */        font-size: 0.5rem;        color: #fff;        line-height: 1rem;        text-align: center;        background-color: green;    }&lt;/style&gt;&lt;div&gt;Bamboo&lt;/div&gt;</code></pre><h3 id="例：媒体查询-引入资源"><a href="#例：媒体查询-引入资源" class="headerlink" title="例：媒体查询 引入资源"></a>例：媒体查询 引入资源</h3><ul><li>引入资源：针对于不同的屏幕尺寸 调用不同的css文件；</li><li>屏幕大于等于 640px ，div 一行显示2个；</li><li>屏幕小于 640px时，div 一行显示1个；</li></ul><p><img src="http://mdimg.95408.com/web_2019122704.gif" alt=""></p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;style320.css&quot; media=&quot;screen and (min-width: 320px)&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style640.css&quot; media=&quot;screen and (min-width: 640px)&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;</code></pre><p>css资源文件：</p><pre><code class="css">/* style320.css */div {    width: 100%;    height: 100px;}div:nth-child(1) {    background-color: pink;}div:nth-child(2) {    background-color: purple;}/* style640.css */div {    float: left;    width: 50%;    height: 100px;}div:nth-child(1) {    background-color: pink;}div:nth-child(2) {    background-color: purple;}</code></pre><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><ul><li>Less（LeanerStyle Sheets）是一门 CSS扩展语言；</li><li>Less是一门 CSS 预处理语言，它扩展了CSS的动态特性；</li><li>常见的CSS预处理器：Sass、Less、Stylus；</li><li>Less中文网址：<a href="http://lesscss.cn/" target="_blank" rel="noopener">lesscss.cn</a>；</li></ul><p><strong>安装：</strong></p><pre><code class="bash">npm install -g less</code></pre><h3 id="Less-变量"><a href="#Less-变量" class="headerlink" title="Less 变量"></a>Less 变量</h3><pre><code class="less">@变量名:值;@color: pink;</code></pre><ul><li>变量名区分大小写；</li><li>@color  和  @Color 是两个不同的变量</li></ul><pre><code class="less">// 定义一个粉色的变量@color: pink; // 定义了一个 字体为14像素的变量@font14: 14px;div {    color: @color;    font-size: @font14;}a {    font-size: @font14;}</code></pre><h3 id="VS-插件-Easy-LESS"><a href="#VS-插件-Easy-LESS" class="headerlink" title="VS 插件 Easy LESS"></a>VS 插件 Easy LESS</h3><ul><li>Easy LESS 插件用来把 less 文件编译为 css 文件；</li><li>只要保存一下 Less 文件，会自动生成 CSS 文件；</li></ul><h3 id="Less-嵌套"><a href="#Less-嵌套" class="headerlink" title="Less 嵌套"></a>Less 嵌套</h3><ul><li>嵌套：子元素样式嵌套在父元素中；</li><li>交集、伪类、伪元素选择器，利用 <code>&amp;</code> 进行连接；</li></ul><pre><code class="less">// nav的子元素logo的样式嵌套在nav元素当中// 伪元素/伪类前面加 &amp; .nav {    .logo {        color: green;    }    &amp;::before {        content: &quot;&quot;;    }}a{  font-size: 12px;  &amp;:hover{      color:red;  }}</code></pre><h3 id="Less-运算"><a href="#Less-运算" class="headerlink" title="Less 运算"></a>Less 运算</h3><ul><li>任何数字、颜色或者变量都可以参与运算；</li><li>Less提供了加（+）、减（-）、乘（*）、除（/）算术运算；</li><li>运算符中间左右有个空格隔开 1px + 5；</li><li>两个值之间只有一个值有单位，则运算结果就取该单位；</li><li>两个值都有单位，取第一个值的单位 ；</li></ul><pre><code class="less">/* Less 里面写 */@witdh: 10px + 5;div {    border: @witdh solid red;}/* 生成的css */div {  border: 15px solid red;}</code></pre><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><pre><code class="less">/* 定义一个类 */.roundedCorners(@radius: 5px) {  -moz-border-radius: @radius;  -webkit-border-radius: @radius;  border-radius: @radius;}/* 定义的类应用到另个一个类中 */＃header {  .roundedCorners;}#footer {  .roundedCorners(10px);}</code></pre><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><blockquote><p>  将样式放到多个文件中，最后通过<code>@import</code>的方式合并;</p><p>  <code>@import url(&#39;_buttom.less&#39;);</code></p></blockquote><pre><code class="less">// main.less@import url(&#39;_buttom.less&#39;);body{  width: 1024px;}// _buttom.less.btn{  color: red;}// 生成css.btn{  color: red;}body{  width: 1024px;}</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>内置函数</p><ul><li>lighten：将一个颜色变亮<ul><li><code>lighten(#000, 10%);    // #1a1a1a</code></li></ul></li><li>darken：将一个颜色变暗<ul><li><code>darken(#000, 10%);    // #e6e6e6</code></li></ul></li></ul><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS移动布局（二）flex布局（图示）</title>
      <link href="/2019/12/26/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E4%BA%8C%EF%BC%89flex%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%BE%E7%A4%BA%EF%BC%89/"/>
      <url>/2019/12/26/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E4%BA%8C%EF%BC%89flex%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%BE%E7%A4%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><h3 id="速查"><a href="#速查" class="headerlink" title="速查"></a>速查</h3><p><strong>父项常见属性</strong></p><ul><li>flex-direction：设置主轴的方向   <ul><li>row； row-reverse； column； column-reverse； </li></ul></li><li>justify-content：设置主轴上的子元素排列方式   <ul><li>fles-start； flex-end； center； space-around； space-between； </li></ul></li><li>flex-wrap：设置子元素是否换行  <ul><li>nowrap； wrap； </li></ul></li><li>align-items：设置侧轴上的子元素排列方式（单行）<ul><li>flex-start； flex-end； center； stretch； </li></ul></li><li>align-content：设置侧轴上的子元素的排列方式（多行）<ul><li>flex-start； flex-end； center； space-around； space-between； stretch； </li></ul></li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><p><strong>子项常见属性</strong></p><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="flex-弹性布局"><a href="#flex-弹性布局" class="headerlink" title="flex 弹性布局"></a>flex 弹性布局</h3><ul><li>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局；</li><li>又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局；</li><li>通过给父盒子添加 <code>flex</code> 属性，来控制子盒子的位置和排列方式；</li></ul><blockquote><p>小试牛刀：</p></blockquote><p><img src="http://mdimg.95408.com/web_2019122602.gif" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* flex布局 */        display: flex;        /* 平分剩余空间 */        justify-content: space-around;        width: 80%;        height: 400px;        border: 2px solid red;        margin: 0 auto;    }    div span {        width: 200px;        height: 200px;        border: 1px solid blue;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;        &lt;span&gt;1&lt;/span&gt;        &lt;span&gt;2&lt;/span&gt;        &lt;span&gt;3&lt;/span&gt;    &lt;/div&gt;</code></pre><h2 id="父项常见属性"><a href="#父项常见属性" class="headerlink" title="父项常见属性"></a>父项常见属性</h2><ul><li>flex-direction：设置主轴的方向</li><li>justify-content：设置主轴上的子元素排列方式</li><li>flex-wrap：设置子元素是否换行  </li><li>align-content：设置侧轴上的子元素的排列方式（多行）</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="flex-direction主轴方向"><a href="#flex-direction主轴方向" class="headerlink" title="flex-direction主轴方向"></a>flex-direction主轴方向</h3><ul><li>row   默认值，从左到右</li><li>row-reverse   从右到左</li><li>column   从上到下</li><li>column-reverse   从下到上</li></ul><blockquote><p>以 X 轴为主轴（左）及以 Y 轴为主轴（右）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262137_368.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 左图：以x轴为主轴： */    /* 为默认值，可以不写 */    flex-direction: row;    /* 右图：以Y轴为主轴： */    flex-direction: column;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}</code></pre><h3 id="justify-content-主轴子元素排列"><a href="#justify-content-主轴子元素排列" class="headerlink" title="justify-content 主轴子元素排列"></a>justify-content 主轴子元素排列</h3><ul><li>fles-start   默认值，从头部开始；如果x轴是主轴则从左到右</li><li>flex-end   从尾部开始</li><li>center   在<strong>主轴居中对齐</strong>；如果x轴是主轴则水平居中</li><li>space-around   平分剩余空间</li><li>space-between   <strong>先两边靠边，再平分剩余空间</strong></li></ul><blockquote><p>当主轴为 X 轴（默认）时，主轴上 子元素 的排列方式：</p></blockquote><p><img src="http://mdimg.95408.com/201912262150_216.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 从左往右排列 */    justify-content: flex-start;    /* 从右往左排列 左上图 */    justify-content: flex-end;    /* 居中排列 右上图 */    justify-content: center;    /* 平分剩余空间 左下图 */    justify-content: space-around;    /* 先两边靠齐，再平分剩余空间 右下图 */    justify-content: space-between;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}</code></pre><blockquote><p>X 轴为主轴时（左）和 Y 轴为主轴时 <code>flex-direction: column;</code> 对比（其他排序方式类似）:</p></blockquote><p><img src="http://mdimg.95408.com/201912262202_745.png?null" alt=""></p><h3 id="flex-wrap-是否换行"><a href="#flex-wrap-是否换行" class="headerlink" title="flex-wrap 是否换行"></a>flex-wrap 是否换行</h3><ul><li>nowrap   默认值，不换行</li><li>wrap   换行</li></ul><blockquote><p>当主轴为 X 轴（默认）时，子元素 压缩不换行（左）及换行（右）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262155_924.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 不换行 默认值 可不写  左图 */    flex-wrap: nowrap;    /* 换行  右图 */    flex-wrap: wrap;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}</code></pre><blockquote><p>当设置 Y 轴为主轴时 <code>flex-direction: column;</code> :</p></blockquote><p><img src="http://mdimg.95408.com/201912262159_917.png?null" alt=""></p><h3 id="align-items-侧轴子元素排列（单行-）"><a href="#align-items-侧轴子元素排列（单行-）" class="headerlink" title="align-items 侧轴子元素排列（单行 ）"></a>align-items 侧轴子元素排列（单行 ）</h3><ul><li>flex-start   默认值，从头部开始</li><li>flex-end   从尾部开始</li><li>center   居中显示</li><li>stretch   拉伸</li></ul><blockquote><p>当主轴为 X 轴（默认）时，子元素 在侧轴上 的排列方式（单行 ）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262210_634.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912262211_79.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 从头部开始 上右图*/    align-items: flex-start;    /* 从尾部开始 上右图*/    align-items: flex-end;    /* 居中 下左图*/    align-items: center;    /* 拉伸 下右图*/    align-items: stretch;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    /* 拉伸stretch时，高度不要写 */    height: 100px;    border: 1px solid blue;}</code></pre><h3 id="align-content-侧轴子元素排列（多行）"><a href="#align-content-侧轴子元素排列（多行）" class="headerlink" title="align-content  侧轴子元素排列（多行）"></a>align-content  侧轴子元素排列（多行）</h3><ul><li>flex-start   默认值，在侧轴的头部开始排列</li><li>flex-end   尾部开始</li><li>center   在侧轴中间显示</li><li>space-around   在侧轴平分剩余空间</li><li>space-between   在侧轴先靠两边，再平分剩余空间</li><li>stretch   高度平分父元素高度</li></ul><blockquote><p>当主轴为 X 轴（默认）时，子元素 在侧轴上 的排列方式（多行 ）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262216_131.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912262218_39.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912262219_508.png?null" alt=""></p><pre><code class="css">div {    display: flex;    flex-wrap: wrap;    /* 从头开始 */    align-content: flex-start;    /* 从尾开始 */    align-content: flex-end;    /* 居中 */    align-content: center;    /* 平分剩余空间 */    align-content: space-around;    /* 两侧靠边，再平分剩余空间 */    align-content: space-between;    /* 平分父元素高度 */    align-content: stretch;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    /* 拉伸stretch时，高度不要写 */    height: 100px;    border: 1px solid blue;}</code></pre><h3 id="align-content-和-align-items-区别"><a href="#align-content-和-align-items-区别" class="headerlink" title="align-content 和 align-items 区别"></a>align-content 和 align-items 区别</h3><ul><li>align-items  适用于单行， 只有上对齐、下对齐、居中和 拉伸</li><li>align-content 适应于换行（多行）（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 </li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><ul><li>是 flex-direction 和 flex-wrap 属性的复合属性</li><li>如：同时设置为 X 轴为主轴 + 换行：</li></ul><pre><code class="css">flex-flow:row wrap;</code></pre><h2 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a>子项常见属性</h2><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</p><blockquote><p>父盒子800px，span1和span3各固定100px，span2分配剩余的空间：</p></blockquote><p><img src="http://mdimg.95408.com/201912262231_433.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        display: flex;        width: 800px;        height: 100px;        border: 2px solid red;        margin: 0 auto;    }    /* span1固定宽度 */    div span:nth-child(1) {        width: 100px;        height: 100px;        background-color: aquamarine;    }    /* span2分配除了span1和span3之外的所有空间 */    div span:nth-child(2) {        flex: 1;        background-color: #ccc;    }    /* span3固定宽度 */    div span:nth-child(3) {        width: 100px;        height: 100px;        background-color: aquamarine;    }&lt;/style&gt;&lt;div&gt;    &lt;span&gt;1&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;</code></pre><blockquote><p>span1、span2 和 span3 平均分配父盒子所有剩余空间（各占1份）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262236_351.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 800px;    height: 100px;    border: 2px solid red;    margin: 0 auto;}div span {    flex: 1;    border: 1px solid blue;}</code></pre><blockquote><p>span1、span2 各分配1份，span3 分配 2 份：</p></blockquote><p><img src="http://mdimg.95408.com/201912262239_353.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 800px;    height: 100px;    border: 2px solid red;    margin: 0 auto;}div span {    flex: 1;    border: 1px solid blue;}div span:nth-child(3) {    flex: 2;    border: 1px solid blue;}</code></pre><h3 id="align-self-子项自己在侧轴排列"><a href="#align-self-子项自己在侧轴排列" class="headerlink" title="align-self 子项自己在侧轴排列"></a>align-self 子项自己在侧轴排列</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</p><blockquote><p>将 span2 与总体相异：独自底对齐（其他默认对齐方式）；</p></blockquote><p><img src="http://mdimg.95408.com/201912262245_389.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 400px;    height: 300px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    height: 100px;    border: 1px solid blue;}div span:nth-child(2) {    align-self: flex-end;}</code></pre><h3 id="order-定义项目排序"><a href="#order-定义项目排序" class="headerlink" title="order 定义项目排序"></a>order 定义项目排序</h3><p>数值越小，排列越靠前，默认为0。</p><blockquote><p>所有 span 默认都是 0 ，将 span3 改成 -1，就排到第一了：</p></blockquote><p><img src="http://mdimg.95408.com/201912262248_317.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 400px;    height: 300px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    height: 100px;    border: 1px solid blue;}div span:nth-child(3) {    order: -1;}</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS移动布局（一）基础、流式布局</title>
      <link href="/2019/12/26/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>/2019/12/26/css3/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口 viewport"></a>视口 viewport</h2><h3 id="理想视口-ideal-viewport"><a href="#理想视口-ideal-viewport" class="headerlink" title="理想视口 ideal viewport"></a>理想视口 ideal viewport</h3><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口。</p><ul><li>布局视口 layout viewport</li><li>视觉视口 visual viewport</li><li>理想视口 ideal viewport<ul><li>meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽；</li><li>我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口；</li></ul></li></ul><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;</code></pre><p><img src="http://mdimg.95408.com/201912261921_804.png?null" alt=""></p><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h3 id="物理像素-amp-物理像素比"><a href="#物理像素-amp-物理像素比" class="headerlink" title="物理像素&amp;物理像素比"></a>物理像素&amp;物理像素比</h3><p>1、iphone 6/7/8 的物理像素宽度：750px，但我们制作一个375px宽度的盒子，就填充满了；</p><p>2、那是因为iphone的<strong>物理像素比</strong>为2，即1px能显示2个物理像素；</p><p><img src="http://mdimg.95408.com/201912261940_282.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    - {        margin: 0;        padding: 0;    }    div {        width: 375px;        height: 375px;        background-color: pink;    }&lt;/style&gt;&lt;div&gt;div&lt;/div&gt;</code></pre><h3 id="二倍图-图片"><a href="#二倍图-图片" class="headerlink" title="二倍图 图片"></a>二倍图 图片</h3><p>1、我们制作一个50px的图标，因为手机的常用物理像素比为 2，那么在iphone上就会放大变成100px，图片会变模糊；</p><p>2、那我们直接使用一张100px的图片，缩小至50px；</p><p>3、当在移动端放大2倍时，还是正常清晰度；</p><p><img src="http://mdimg.95408.com/201912261953_668.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    img:nth-child(2) {        width: 50px;        height: 50px;    }&lt;/style&gt;&lt;!-- 模糊的 --&gt;&lt;img src=&quot;images/apple50.jpg&quot; alt=&quot;&quot;&gt;&lt;!-- 采取2倍图 --&gt;&lt;img src=&quot;images/apple100.jpg&quot; alt=&quot;&quot;&gt;</code></pre><h3 id="二倍图-背景-background-size"><a href="#二倍图-背景-background-size" class="headerlink" title="二倍图 背景 background-size"></a>二倍图 背景 background-size</h3><pre><code class="css">background-size: 背景图片宽度 背景图片高度;* 单位： 长度|百分比|cover|contain； - cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域； - contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域；</code></pre><p>同上例，图片能用二倍图，CSS3 中我们也可以使用 <code>background-size</code> 缩放背景图：</p><p><img src="http://mdimg.95408.com/201912262038_528.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .px50 {        width: 50px;        height: 50px;        background: url(images/apple50.jpg) no-repeat;    }    .px100 {        width: 50px;        height: 50px;        background: url(images/apple100.jpg) no-repeat;        background-size: 50px 50px;    }&lt;/style&gt;&lt;div class=&quot;px50&quot;&gt;&lt;/div&gt;&lt;div class=&quot;px100&quot;&gt;&lt;/div&gt;</code></pre><h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><h3 id="移动端-PC端"><a href="#移动端-PC端" class="headerlink" title="移动端+PC端"></a>移动端+PC端</h3><p>PC端和移动端为两套网站，pc端是pc端的样式，移动端在写一套，专门针对移动端适配的一套网站；</p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配；</p><h2 id="移动端技术"><a href="#移动端技术" class="headerlink" title="移动端技术"></a>移动端技术</h2><h3 id="移动端公共样式"><a href="#移动端公共样式" class="headerlink" title="移动端公共样式"></a>移动端公共样式</h3><p>移动端 CSS 初始化推荐使用 <code>normalize.css</code> </p><pre><code class="html">官网地址： http://necolas.github.io/normalize.css/</code></pre><p><a href="http://mdimg.95408.com/web_normalize.css" target="_blank" rel="noopener">本地备份</a></p><h3 id="CSS3盒子模型box-sizing"><a href="#CSS3盒子模型box-sizing" class="headerlink" title="CSS3盒子模型box-sizing"></a>CSS3盒子模型box-sizing</h3><p>CSS3盒子模型， padding 和 border 不会撑大盒子；</p><pre><code class="css">box-sizing: border-box;</code></pre><p><img src="http://mdimg.95408.com/201912262045_716.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div:nth-child(1) {        /* 传统盒子模型 = width + border + padding */        width: 200px;        height: 200px;        background-color: pink;        padding: 10px;        border: 10px solid red;    }    div:nth-child(2) {        /* box-sizing: border-box; 有了这句话就让盒子变成CSS3盒子模型 */        /* padding 和 border 不会再撑大盒子了 */        box-sizing: border-box;        width: 200px;        height: 200px;        padding: 10px;        border: 10px solid blue;    }&lt;/style&gt;</code></pre><h3 id="移动端特殊样式"><a href="#移动端特殊样式" class="headerlink" title="移动端特殊样式"></a>移动端特殊样式</h3><pre><code class="css">/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除清除  设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a {    -webkit-touch-callout: none;}</code></pre><h2 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h2><h3 id="移动端单独制作"><a href="#移动端单独制作" class="headerlink" title="移动端单独制作"></a>移动端单独制作</h3><ul><li>流式布局（百分比布局）</li><li>flex 弹性布局（强烈推荐）</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul><h3 id="响应式-1"><a href="#响应式-1" class="headerlink" title="响应式"></a>响应式</h3><ul><li>媒体查询</li><li>bootstarp</li></ul><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5+Css3（一）基础</title>
      <link href="/2019/12/23/css3/HTML5+Css3%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/23/css3/HTML5+Css3%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML新增"><a href="#HTML新增" class="headerlink" title="HTML新增"></a>HTML新增</h2><h2 id="1-1、语义化标签"><a href="#1-1、语义化标签" class="headerlink" title="1.1、语义化标签"></a>1.1、语义化标签</h2><ul><li><code>header</code> —  头部标签</li><li><code>nav</code> —  导航标签</li><li><code>article</code> —   内容标签</li><li><code>section</code> —   块级标签</li><li><code>aside</code> —   侧边栏标签</li><li><code>footer</code> —   尾部标签</li></ul><blockquote><p>在 <code>IE9</code> 浏览器中，需要把语义化标签都转换为块级元素语义化标签；</p><p>在移动端支持比较友好；</p></blockquote><h2 id="1-2、多媒体音频标签"><a href="#1-2、多媒体音频标签" class="headerlink" title="1.2、多媒体音频标签"></a>1.2、多媒体音频标签</h2><h3 id="1-2-1、audio"><a href="#1-2-1、audio" class="headerlink" title="1.2.1、audio"></a>1.2.1、audio</h3><p><img src="http://mdimg.95408.com/201912191818_942.png" alt="audio 的参数"></p><blockquote><p>注意：在 chrome 浏览器中已经禁用了 autoplay 属性</p></blockquote><h3 id="1-2-2、video"><a href="#1-2-2、video" class="headerlink" title="1.2.2、video"></a>1.2.2、video</h3><pre><code class="html">&lt;body&gt;    &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;    &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;    &lt;!-- 多个视频格式支持不同浏览器 --&gt;    &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;        &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;        &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;    &lt;/video&gt;&lt;/body&gt;</code></pre><blockquote><p>谷歌浏览器禁用了自动播放功能，解决办法：需要添加 <strong>muted</strong> 属性</p></blockquote><p><img src="http://mdimg.95408.com/201912191820_561.png?null" alt="video 参数"></p><h2 id="1-3、input-标签"><a href="#1-3、input-标签" class="headerlink" title="1.3、input 标签"></a>1.3、input 标签</h2><p>tel只能输入电话；search能直接删除搜索数据；</p><p><img src="http://mdimg.95408.com/201912191824_8.png?null" alt="新增 input 标签"></p><h2 id="1-4、表单属性"><a href="#1-4、表单属性" class="headerlink" title="1.4、表单属性"></a>1.4、表单属性</h2><p>placeholder：表单中增加一行提示文本，获得焦点时消失；</p><p><img src="http://mdimg.95408.com/201912191826_338.png?null" alt="新增表单属性"></p><h2 id="Css3-新增"><a href="#Css3-新增" class="headerlink" title="Css3 新增"></a>Css3 新增</h2><h2 id="2-1、属性选择器"><a href="#2-1、属性选择器" class="headerlink" title="2.1、属性选择器"></a>2.1、属性选择器</h2><p><img src="http://mdimg.95408.com/201912191830_587.png?null" alt=""></p><p>1）</p><pre><code class="css">button {    /* 选择所有的button元素 */}button[disabled] {    /* 选择标签中带有disabled属性的button元素 */}</code></pre><p>2）</p><pre><code class="css">input[type=search] {    /* 选择type属性=search的input元素 */}span[class^=black] {    /* 选择class属性 以black开头的 span元素 */}span[class$=black] {    /* 选择class属性 以black结尾的 span元素 */}span[class*=black] {    /* 选择class属性 包含black的 span元素 */}</code></pre><h2 id="2-2、结构伪类选择器"><a href="#2-2、结构伪类选择器" class="headerlink" title="2.2、结构伪类选择器"></a>2.2、结构伪类选择器</h2><p><img src="http://mdimg.95408.com/201912191838_395.png" alt="结构伪类选择器属性列表"></p><h3 id="2-2-1、first-child-last-child"><a href="#2-2-1、first-child-last-child" class="headerlink" title="2.2.1、first-child / last-child"></a>2.2.1、first-child / last-child</h3><pre><code class="css">ul li:first-child {    /* 选择第一个li元素 */}ul li:last-child {    /* 选择最后一个li元素 */}ul li:nth-child(3) {    /* 选择第3个li元素 */}</code></pre><h3 id="2-2-2、nth-child"><a href="#2-2-2、nth-child" class="headerlink" title="2.2.2、nth-child( )"></a>2.2.2、nth-child( )</h3><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td>ul li:nth-child(<strong>even</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>odd</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>2n</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>2n+1</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>5n</strong>) { }</td><td>第5、10、15个</td></tr><tr><td>ul li:nth-child(<strong>3n</strong>) { }</td><td>第3、6、9个</td></tr><tr><td>ul li:nth-child(<strong>n+5</strong>) { }</td><td>从第5个到最后</td></tr><tr><td>ul li:nth-child(<strong>-n+5</strong>) { }</td><td>前面5个</td></tr></tbody></table><blockquote><p>有时需要将2排各5个div中的最右边2个去除 <code>margin-right</code> 时，可以用 <code>ul li:nth-child(5)</code> 来选择第 5、10个div元素。</p></blockquote><h3 id="2-2-3、nth-child-和-nt-of-type-的区别"><a href="#2-2-3、nth-child-和-nt-of-type-的区别" class="headerlink" title="2.2.3、nth-child 和 nt-of-type 的区别"></a>2.2.3、nth-child 和 nt-of-type 的区别</h3><ul><li>ul中只有li元素时，两都选择相同；</li><li>ul中第一个是p元素，后面是li元素时：<ul><li>nth-child 选择父元素里面的第几个子元素，只要是子元素即可，不管是什么类型；</li><li>nth-of-type 是选择父元素的某一种子元素的第几个；</li></ul></li></ul><pre><code class="css">&lt;body&gt;&lt;ul&gt;&lt;p&gt;p&lt;/p&gt;&lt;li&gt;li 1&lt;/li&gt;&lt;li&gt;li 2&lt;/li&gt;&lt;li&gt;li 3&lt;/li&gt;&lt;li&gt;li 4&lt;/li&gt;&lt;li&gt;li 5&lt;/li&gt;&lt;li&gt;li 6&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;style&gt;ul :nth-child(1) {    background-color: red;    /* 选择p */}ul li:nth-child(3) {    background-color: blue;    /* 选择li 2 */    /* 虽然选择的是li的第3个，但是从第一个子元素p就开始计算 */}ul li:nth-of-type(3) {    background-color: green;    /* 选择li 3 */}ul li:nth-of-type(1) {    background-color: hotpink;    /* 选择li 1 */}&lt;/style&gt;</code></pre><h2 id="2-3、伪元素选择器"><a href="#2-3、伪元素选择器" class="headerlink" title="2.3、伪元素选择器"></a>2.3、伪元素选择器</h2><p><img src="http://mdimg.95408.com/201912191916_205.png?null" alt="伪类选择器"></p><h3 id="2-3-1、注意事项"><a href="#2-3-1、注意事项" class="headerlink" title="2.3.1、注意事项"></a>2.3.1、注意事项</h3><ul><li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li><li><code>before</code> 在内容前面， <code>after</code> 在内容后面</li><li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li><li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li><li>伪元素和标签选择器一样，权重为 1</li></ul><h3 id="2-3-2、增加字体图标"><a href="#2-3-2、增加字体图标" class="headerlink" title="2.3.2、增加字体图标"></a>2.3.2、增加字体图标</h3><pre><code class="css">p {    width: 220px;    height: 22px;    border: 1px solid lightseagreen;    margin: 60px;    position: relative;}p::after {    content: &#39;\ea50&#39;;    font-family: &#39;icomoon&#39;;    position: absolute;    top: -1px;    right: 10px;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5+Css3（二）CSS3动画、2D、3D</title>
      <link href="/2019/12/23/css3/HTML5+Css3%EF%BC%88%E4%BA%8C%EF%BC%89CSS3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/"/>
      <url>/2019/12/23/css3/HTML5+Css3%EF%BC%88%E4%BA%8C%EF%BC%89CSS3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/</url>
      
        <content type="html"><![CDATA[<h2 id="2D转换-transform"><a href="#2D转换-transform" class="headerlink" title="2D转换 transform"></a>2D转换 transform</h2><p>2D 转换是改变标签在二维平面上的位置和形状</p><ul><li>移动： <code>translate</code> </li><li>旋转： <code>rotate</code> </li><li>缩放： <code>scale</code> </li></ul><h3 id="translate-移动"><a href="#translate-移动" class="headerlink" title="translate 移动"></a>translate 移动</h3><ul><li><code>translate</code> 最大的优点就是不影响其他元素的位置</li><li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li></ul><pre><code class="css">transform: translate(x, y) transform: translateX(n) transfrom: translateY(n)</code></pre><ul><li>行内标签没有效果</li></ul><pre><code class="css">div {    background-color: lightseagreen;    width: 200px;    height: 100px;    /* 水平垂直移动 100px */    /* transform: translate(100px, 100px); */    /* 水平移动 100px */    /* transform: translate(100px, 0) */    /* 垂直移动 100px */    /* transform: translate(0, 100px) */    /* 水平移动 100px */    /* transform: translateX(100px); */    /* 垂直移动 100px */    transform: translateY(100px)}</code></pre><h3 id="例：让盒子水平垂直居中"><a href="#例：让盒子水平垂直居中" class="headerlink" title="例：让盒子水平垂直居中"></a>例：让盒子水平垂直居中</h3><pre><code class="html">&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;style&gt;    div {        position: relative;        width: 500px;        height: 500px;        background-color: red;    }    p {        position: absolute;        top: 50%;        left: 50%;        /* 原来的办法：计算返回原元素的一半 */        /* margin-top: -100px; */        /* margin-left: -100px; */        /* translate(-50%, -50%)  盒子往上走自己高度的一半 */        transform: translate(-50%, -50%);        width: 200px;        height: 200px;        background-color: burlywood;    }&lt;/style&gt;</code></pre><h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><pre><code class="css">/* 单位是：deg */transform: rotate(度数如180deg)</code></pre><ul><li><code>rotate</code> 里面跟度数，单位是 <code>deg</code> </li><li>角度为正时，顺时针，角度为负时，逆时针</li><li>默认旋转的中心点是元素的中心点</li></ul><pre><code class="html">&lt;style&gt;    div {        width: 200px;        height: 100px;        background-color: red;    }    div:hover {        transform: rotate(90deg);        /* 鼠标移动时顺时针转90度 */    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h3 id="例：图标360度旋转"><a href="#例：图标360度旋转" class="headerlink" title="例：图标360度旋转"></a>例：图标360度旋转</h3><p><img src="http://mdimg.95408.com/web_2019121903.gif" alt="图标360度旋转"></p><pre><code class="html">&lt;style&gt;    img {        width: 200px;        height: 200px;        background-color: pink;        border: pink solid 1px;        border-radius: 50%;        transition: all 0.3s;    }    img:hover {        transform: rotate(180deg);    }&lt;/style&gt;&lt;body&gt;    &lt;img src=&quot;media/pic.jpg&quot; alt=&quot;&quot;&gt;&lt;/body&gt;</code></pre><h3 id="例：制作上下-gt-符号"><a href="#例：制作上下-gt-符号" class="headerlink" title="例：制作上下  &gt; 符号"></a>例：制作上下  &gt; 符号</h3><p><img src="http://mdimg.95408.com/web_2019121902.gif" alt="上下  &gt; 符号"></p><pre><code class="html">&lt;style&gt;    div {        position: relative;        width: 249px;        height: 35px;        border: 1px solid #333;    }    div::after {        content: &quot;&quot;;        position: absolute;        top: 10px;        right: 10px;        /* 创建一个只有两边边框的方形 */        width: 10px;        height: 10px;        border-right: 1px solid #333;        border-bottom: 1px solid #333;        /* 将方形旋转45度 */        transform: rotate(45deg);        transition: all .2s;    }    /* 是鼠标经过div时，::after变动效果 */    div:hover::after {        transform: rotate(225deg);        top: 15px;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="旋转中心点-transform-origin"><a href="#旋转中心点-transform-origin" class="headerlink" title="旋转中心点 transform-origin"></a>旋转中心点 transform-origin</h3><pre><code class="css">transform-origin: x y;div {    width: 200px;    height: 200px;    background-color: pink;    margin: 100px auto;    transition: all 1s;    /* 1.可以跟方位名词 */    /* transform-origin: left bottom; */    /* 2. 默认的是 50%  50%  等价于 center  center */    /* 3. 可以是px 像素 */    transform-origin: 50px 50px;}</code></pre><ul><li>注意后面的参数 x 和 y 用空格隔开</li><li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code> </li><li>还可以给 x y 设置像素或者方位名词( <code>top</code> 、 <code>bottom</code> 、 <code>left</code> 、 <code>right</code> 、 <code>center</code> )</li></ul><h3 id="例：图片从左下角旋转上升"><a href="#例：图片从左下角旋转上升" class="headerlink" title="例：图片从左下角旋转上升"></a>例：图片从左下角旋转上升</h3><p><img src="http://mdimg.95408.com/2019121901.gif" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* 隐藏div外的after中的内容 */        overflow: hidden;        position: relative;        width: 300px;        height: 200px;        border: 1px solid #333;        margin: 10px;        float: left;    }    img {        position: absolute;        top: 0;        left: 0;        width: 300px;        height: 200px;        /* 以左 下 角为基点，旋转180度，看不看的状态 */        transform: rotate(100deg);        transform-origin: left bottom;        transition: all .2s;    }    div:hover img {        /* 鼠标移动，图片旋转到div内 */        transform: rotate(0deg);    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><pre><code class="css">transform: scale(x, y) div:hover {    /* 注意，数字是倍数的含义，所以不需要加单位 */    /* transform: scale(2, 2) */    /* 实现等比缩放，同时修改宽与高 */    /* transform: scale(2) */    /* 小于 1 就等于缩放*/    transform: scale(0.5, 0.5)}</code></pre><ul><li>x 与 y 之间使用逗号进行分隔</li><li><code>transform: scale(1, 1)</code> : 宽高都放大一倍，相当于没有放大</li><li><code>transform: scale(2, 2)</code> : 宽和高都放大了二倍</li><li><code>transform: scale(2)</code> : 如果只写了一个参数，第二个参数就和第一个参数一致</li><li><code>transform:scale(0.5, 0.5)</code> : 缩小</li><li>优势：可以设置转换中心点缩放，默认以中心点缩放，而且<strong>不影响其他盒子</strong></li></ul><h3 id="例：图片放大"><a href="#例：图片放大" class="headerlink" title="例：图片放大"></a>例：图片放大</h3><p><img src="http://mdimg.95408.com/web_2019121905.gif" alt="图片放大"></p><h3 id="例：分类按钮放大"><a href="#例：分类按钮放大" class="headerlink" title="例：分类按钮放大"></a>例：分类按钮放大</h3><p><img src="http://mdimg.95408.com/web_2019121906.gif" alt="分类按钮放大"></p><h3 id="2D-转换综合写法-及-顺序"><a href="#2D-转换综合写法-及-顺序" class="headerlink" title="2D 转换综合写法 及 顺序"></a>2D 转换综合写法 及 顺序</h3><ul><li>顺序会影响到转换的效果；</li><li>同时有位置或者其他属性的时候，要将<strong>位移放到最前面</strong> ；</li></ul><pre><code class="css">div:hover {    transform: translate(200px, 0) rotate(360deg) scale(1.2)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（四）数组二</title>
      <link href="/2019/12/23/js/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E7%BB%84%E4%BA%8C/"/>
      <url>/2019/12/23/js/JavaScript%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E7%BB%84%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h2><h3 id="1、for循环遍历数组"><a href="#1、for循环遍历数组" class="headerlink" title="1、for循环遍历数组"></a>1、for循环遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (var i = 0; i &lt; fruits.length; i++) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="2、for-in-遍历数组"><a href="#2、for-in-遍历数组" class="headerlink" title="2、for in 遍历数组"></a>2、for in 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (i in fruits) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="3、forEach-遍历数组"><a href="#3、forEach-遍历数组" class="headerlink" title="3、forEach() 遍历数组"></a>3、forEach() 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});// Banana// Orange// Apple// Mango  fruits.forEach(v =&gt; {    console.log(v);});// Banana// Orange// Apple// Mango  </code></pre><p>数组元素和元素索引</p><pre><code class="js">var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    console.log(&#39;数组元素&#39; + value);    console.log(&#39;数组元素索引号&#39; + index);})// 数组元素1// 数组元素索引号0// 数组元素2// 数组元素索引号1// 数组元素3// 数组元素索引号2</code></pre><p>求数组的和</p><pre><code class="js">var sum = 0;var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    sum += value;})console.log(sum); // 6</code></pre><h2 id="二、数组迭代"><a href="#二、数组迭代" class="headerlink" title="二、数组迭代"></a>二、数组迭代</h2><h3 id="1、filter-筛选数组"><a href="#1、filter-筛选数组" class="headerlink" title="1、filter() 筛选数组"></a>1、filter() 筛选数组</h3><p>返回一个新数组，接受 3 个参数：项目值、项目索引、数组本身</p><p>返回大于50的元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value) {    return value &gt;= 50;})console.log(newArr); // [66, 88]</code></pre><p>返回偶数元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr2 = arr.filter(function(value) {    return value % 2 === 0;})console.log(newArr2); // [12, 66, 4, 88]</code></pre><h3 id="2、some-查找满足条件的元素是否存在"><a href="#2、some-查找满足条件的元素是否存在" class="headerlink" title="2、some() 查找满足条件的元素是否存在"></a>2、some() 查找满足条件的元素是否存在</h3><p>filter() 查找满足条件的元素 返回一个 <code>新数组</code> </p><p>some() 查找满足条件的元素是否存在 返回一个 <code>布尔值</code> </p><p>接受 3 个参数： <code>项目值</code> 、 <code>项目索引</code> 、 <code>数组本身</code> </p><p>sonme() 如果查找到第一个满足条件的元素就终止循环，效率更高</p><pre><code class="js">var arr = [10, 30, 4];var flag = arr.some(function(value) {    return value &lt; 3;});console.log(flag); // falsevar arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;];var flag1 = arr1.some(function(value) {    return value == &#39;pink&#39;;});console.log(flag1); // true</code></pre><h3 id="3、forEach-和-some-的区别"><a href="#3、forEach-和-some-的区别" class="headerlink" title="3、forEach() 和 some() 的区别"></a>3、forEach() 和 some() 的区别</h3><p>如果查询数组中唯一的元素, 用some方法更合适</p><p>在 some 里面 遇到 return true 就是终止遍历 迭代效率更高</p><p>在forEach 里面 return 不会终止迭代</p><pre><code class="js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];arr.some(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在 some 里面 return true 就终止遍历 迭代效率更高        return true;    }    console.log(11);    // 11    // 找到了该元素});var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];// 1. forEach迭代 遍历arr.forEach(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在forEach 里面 return 不会终止迭代        return true;    }    console.log(11);})// 11// 找到了该元素// 11// 11</code></pre><h3 id="4、indexOf"><a href="#4、indexOf" class="headerlink" title="4、indexOf()"></a>4、indexOf()</h3><p>在数组中搜索元素值并返回其位置</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); // 0</code></pre><h3 id="5、lastIndexOf"><a href="#5、lastIndexOf" class="headerlink" title="5、lastIndexOf()"></a>5、lastIndexOf()</h3><p>在数组中搜索元素值并返回其位置，从数组结尾开始搜索</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); // 2</code></pre><h3 id="6、find"><a href="#6、find" class="headerlink" title="6、find()"></a>6、find()</h3><p>返回通过测试函数的第一个数组元素的值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.find(function(value) {    return value &gt; 18;})console.log(first); // 25 第一个比18大的值</code></pre><h3 id="7、findIndex"><a href="#7、findIndex" class="headerlink" title="7、findIndex()"></a>7、findIndex()</h3><p>返回通过测试函数的第一个数组元素的索引</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(function(value) {    return value &gt; 18;})console.log(first); // 3 第一个比18大的值的索引号是3</code></pre><h3 id="8、map"><a href="#8、map" class="headerlink" title="8、map()"></a>8、map()</h3><p>对每个数组元素执行函数来创建新数组，不会更改原始数组。</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.map(function(value) {    return value * 2;})console.log(first); // [2, 4, 6] 将每个数组值乘以2</code></pre><h3 id="9、reduce-reduceRight"><a href="#9、reduce-reduceRight" class="headerlink" title="9、reduce() reduceRight()"></a>9、reduce() reduceRight()</h3><p>在每个数组元素上运行函数，以生成（减少它）单个值</p><p>reduceRight() 方法在数组中从左到右工作</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.reduce(function(total, value) {    return total + value;})console.log(first); // 6 总和为6</code></pre><h3 id="10、every"><a href="#10、every" class="headerlink" title="10、every()"></a>10、every()</h3><p>检查所有数组值是否通过测试，返回布尔值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.every(function(value) {    return value &gt; 18;})console.log(first); // false(并非所有元素都大于18)</code></pre><h2 id="三、数组排序"><a href="#三、数组排序" class="headerlink" title="三、数组排序"></a>三、数组排序</h2><h3 id="1、reverse-反转数组"><a href="#1、reverse-反转数组" class="headerlink" title="1、reverse() 反转数组"></a>1、reverse() 反转数组</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // Mango,Apple,Orange,Banana</code></pre><h3 id="2、sort-以字母方式排序"><a href="#2、sort-以字母方式排序" class="headerlink" title="2、sort() 以字母方式排序"></a>2、sort() 以字母方式排序</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // Apple,Banana,Mango,Orange</code></pre><h3 id="3、sort-以数字方式排序"><a href="#3、sort-以数字方式排序" class="headerlink" title="3、sort() 以数字方式排序"></a>3、sort() 以数字方式排序</h3><p>如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b}); // 1,5,10,25,40,100</code></pre><p>通过一个比值函数，对数组进行降序排序。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a}); // 100,40,25,10,5,1</code></pre><h3 id="4、sort-随机排序"><a href="#4、sort-随机排序" class="headerlink" title="4、sort() 随机排序"></a>4、sort() 随机排序</h3><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return 0.5 - Math.random()});// 40,10,5,100,1,25  随机生成排序// 5,40,100,25,1,10</code></pre><h3 id="5、sort-查找最高-最低数组值"><a href="#5、sort-查找最高-最低数组值" class="headerlink" title="5、sort() 查找最高/最低数组值"></a>5、sort() 查找最高/最低数组值</h3><p>升序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b});// 现在 points[0] 包含最低值// 而 points[points.length-1] 包含最高值</code></pre><p>降序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a});// 现在 points[0] 包含最高值// 而 points[points.length-1] 包含最低值</code></pre><h3 id="6、Math-max-apply-查找最高数组值"><a href="#6、Math-max-apply-查找最高数组值" class="headerlink" title="6、Math.max.apply() 查找最高数组值"></a>6、Math.max.apply() 查找最高数组值</h3><p>apply() 第二个参数须是数组，与 <code>Math.max</code> 相结合使用。</p><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> .</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.max.apply(Math, points)var a = Math.max.apply(null, points) // null 也可以console.log(a); // 100</code></pre><h3 id="7、Math-min-apply-查找最低数组值"><a href="#7、Math-min-apply-查找最低数组值" class="headerlink" title="7、Math.min.apply() 查找最低数组值"></a>7、Math.min.apply() 查找最低数组值</h3><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> 。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.min.apply(Math, points)console.log(a); // 1</code></pre><p><img src="http://mdimg.95408.com/20191213144049.png" alt="20191213144049"></p><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（三）数组一</title>
      <link href="/2019/12/23/js/JavaScript%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%80/"/>
      <url>/2019/12/23/js/JavaScript%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组是一种特殊的变量，它能够一次存放一个以上的值。</li><li>数组是一种特殊类型的对象，在 JavaScript 中对数组使用 typeof 运算符会返回 “object”。JavaScript 数组最好以数组来描述。</li><li>数组使用数字来访问其“元素”，对象使用名称来访问其“成员”。数组和对象的区别：数组使用数字索引、象使用命名索引。数组是特殊类型的对象，具有数字索引。<ul><li><code>var person = [&quot;Bill&quot;, &quot;Gates&quot;, 62];</code> 使用： <code>person[0]</code> </li><li><code>var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:46};</code> 使用： <code>person.firstName</code> </li></ul></li><li>如果希望元素名为字符串（文本）则应该使用对象、如果希望元素名为数字则应该使用数组。</li><li>可以在数组保存对象、函数、甚至是数组；<ul><li><code>myArray[0] = Date.now;  myArray[1] = myFunction;  myArray[2] = myCars;</code> </li></ul></li></ul><h3 id="1、定义数组"><a href="#1、定义数组" class="headerlink" title="1、定义数组"></a>1、定义数组</h3><pre><code class="js">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 以逗号隔开；// 最后不要加逗号；// var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);// 尽量不要使用 new Array() ，执行效率更低；</code></pre><h3 id="2、-识别数组"><a href="#2、-识别数组" class="headerlink" title="2、 识别数组"></a>2、 识别数组</h3><pre><code class="js">typeof cars; // 返回 object// typeof 运算符返回 &quot;object&quot;，因为 JavaScript 数组属于对象。Array.isArray(cars); // 返回 true</code></pre><h3 id="3、访问数组元素"><a href="#3、访问数组元素" class="headerlink" title="3、访问数组元素"></a>3、访问数组元素</h3><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);console.log(cars[0]); // Saab</code></pre><h3 id="4、遍历数据"><a href="#4、遍历数据" class="headerlink" title="4、遍历数据"></a>4、遍历数据</h3><p>把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项；</p><pre><code class="js">var arr = [&#39;red&#39;,&#39;green&#39;, &#39;blue&#39;];for (var i = 0; i &lt; arr.length; i++) {    console.log(arrStus[i]);}// red// green// blue</code></pre><h3 id="5、改变数组元素"><a href="#5、改变数组元素" class="headerlink" title="5、改变数组元素"></a>5、改变数组元素</h3><p>通过使用它们的索引号来访问、更改数组元素</p><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);cars[0] = &#39;abc&#39;console.log(cars[0]); // abc</code></pre><h3 id="6、访问完整数组"><a href="#6、访问完整数组" class="headerlink" title="6、访问完整数组"></a>6、访问完整数组</h3><pre><code class="js">var cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars; &lt;p id = &quot;demo&quot; &gt; &lt; /p&gt;//&lt;p id=&quot;demo&quot;&gt;Audi,BMW,porsche&lt;/p&gt;</code></pre><h2 id="数组属性方法"><a href="#数组属性方法" class="headerlink" title="数组属性方法"></a>数组属性方法</h2><h3 id="1、length-属性"><a href="#1、length-属性" class="headerlink" title="1、length 属性"></a>1、length 属性</h3><p>返回数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.length; // 4</code></pre><h3 id="2、length-访问最后一个元素"><a href="#2、length-访问最后一个元素" class="headerlink" title="2、length 访问最后一个元素"></a>2、length 访问最后一个元素</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var first = fruits[0]; // 访问第一个元素var last = fruits[fruits.length - 1]; // Mango// str.length 为长度4，减1表示是索引3（索引从0开始）</code></pre><h3 id="3、push-、length添加元素"><a href="#3、push-、length添加元素" class="headerlink" title="3、push()、length添加元素"></a>3、push()、length添加元素</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// str.length是数组长度，比索引大1（索引从0开始）// 等于在原来最大索引+1的位置添加元素</code></pre><h3 id="4、添加元素时的空位"><a href="#4、添加元素时的空位" class="headerlink" title="4、添加元素时的空位"></a>4、添加元素时的空位</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[6] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// Banana// Orange// Apple// Mango// undefined 添加最高索引的元素可在数组中创建未定义的“洞”：// undefined// Lemon</code></pre><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="1、toString-转为字符串"><a href="#1、toString-转为字符串" class="headerlink" title="1、toString() 转为字符串"></a>1、toString() 转为字符串</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.toString()); // Banana,Orange,Apple,Mangoconsole.log(fruits); // 也可以直接调用// 所有 JavaScript 对象都拥有 toString() 方法。</code></pre><h3 id="2、join-转字符串"><a href="#2、join-转字符串" class="headerlink" title="2、join() 转字符串"></a>2、join() 转字符串</h3><p>类似 toString()，但是您还可以规定分隔符</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.join(&#39;*&#39;)); // Banana*Orange*Apple*Mango</code></pre><h3 id="3、pop-删除最后元素"><a href="#3、pop-删除最后元素" class="headerlink" title="3、pop() 删除最后元素"></a>3、pop() 删除最后元素</h3><p>1、pop() 删除最后元素，返回被删除元素</p><p>2、push() 在最后增加元素，返回数组长度</p><p>3、shift() 删除开始元素，返回被删除元素</p><p>4、unshift() 在开始增加元素，返回数组长度</p><p>返回被删除的值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop()// console.log(fruits.pop()); // Mango// console.log(fruits); // Banana,Orange,Apple</code></pre><h3 id="4、push-在最后增加元素"><a href="#4、push-在最后增加元素" class="headerlink" title="4、push() 在最后增加元素"></a>4、push() 在最后增加元素</h3><p>返回新数组的长度值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var f = fruits.push(&#39;Kiwi&#39;);// console.log(f); // 5// console.log(fruits); // Banana Orange Apple Mango Kiwi</code></pre><h3 id="5、shift-删除第一个元素"><a href="#5、shift-删除第一个元素" class="headerlink" title="5、shift() 删除第一个元素"></a>5、shift() 删除第一个元素</h3><p>返回被“位移出”的字符串</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 返回 &quot;Banana&quot;</code></pre><h3 id="6、unshift-在最前面增加元素"><a href="#6、unshift-在最前面增加元素" class="headerlink" title="6、unshift() 在最前面增加元素"></a>6、unshift() 在最前面增加元素</h3><p>返回新数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 返回 5</code></pre><h3 id="7、delete-删除元素"><a href="#7、delete-删除元素" class="headerlink" title="7、delete 删除元素"></a>7、delete 删除元素</h3><p>使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // 把 fruits 中的首个元素改为 undefined</code></pre><h3 id="8、splice-向数组添加新项"><a href="#8、splice-向数组添加新项" class="headerlink" title="8、splice() 向数组添加新项"></a>8、splice() 向数组添加新项</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi,Apple,Mango</code></pre><p>第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>第二个参数（0）定义应删除多少元素。</p><p>其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>splice() 方法返回一个包含已删除项的数组：</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi// 已删除项： Apple,Mango</code></pre><h3 id="8、splice-删除元素"><a href="#8、splice-删除元素" class="headerlink" title="8、splice() 删除元素"></a>8、splice() 删除元素</h3><p>第一个参数（0）定义新元素应该被添加（接入）的位置。</p><p>第二个参数（1）定义应该删除多个元素。</p><p>其余参数被省略。没有新元素将被添加。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 Banana// 原数组： Banana,Orange,Apple,Mango// 新数组： Orange,Apple,Mangofruits.splice(1, 2); // Banana,Mango</code></pre><h3 id="9、concat-合并、连接数组"><a href="#9、concat-合并、连接数组" class="headerlink" title="9、concat() 合并、连接数组"></a>9、concat() 合并、连接数组</h3><p>concat() 方法不会更改现有数组。它总是返回一个新数组。</p><p>concat() 方法可以使用任意数量的数组参数：</p><p>concat() 方法也可以将值作为参数：</p><pre><code class="js">var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var arr2 = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var arr3 = [&quot;Robin&quot;, &quot;Morgan&quot;];arr1.concat(arr2); // 将arr1 与 arr2 连接在一起arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起arr1.concat([&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]); // 也可以将值作为参数</code></pre><h3 id="10、slice-裁剪新数组"><a href="#10、slice-裁剪新数组" class="headerlink" title="10、slice() 裁剪新数组"></a>10、slice() 裁剪新数组</h3><p>slice() 方法创建新数组。它不会从源数组中删除任何元素。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.slice(1); // Orange,Lemon,Apple,Mangofruits.slice(3); // Apple,Mango</code></pre><p>slice() 可接受两个参数，从开始参数选取元素，直到结束参数（不包括）为止。</p><p>第2个参数可省略，表示从第1个参数往后所有的元素；</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // Orange,Lemon</code></pre><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github</title>
      <link href="/2019/12/23/tools/git%E5%92%8Cgithub/"/>
      <url>/2019/12/23/tools/git%E5%92%8Cgithub/</url>
      
        <content type="html"><![CDATA[<h1 id="git-本地仓库"><a href="#git-本地仓库" class="headerlink" title="git 本地仓库"></a>git 本地仓库</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>Git 使用前配置</strong></p><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名： <code>git config --global user.name 提交人姓名</code> </li><li>配置提交人姓名： <code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息： <code>git config --list</code> </li></ol><p><strong>提交步骤</strong></p><ol><li><code>git init</code> 初始化git仓库</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件/提交到暂存区</li><li><code>git commit -m 提交信息</code> 向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><p><strong>撤销</strong></p><ul><li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code> </li><li>将文件从暂存区中删除： <code>git rm --cached 文件</code> </li><li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录： <code>git rest --hard commitID</code> （ID号可以通过 <code>git log</code> 查看） </li></ul><p><strong>分支命令</strong></p><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 来源分支</code> 合并分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><p><strong>暂时保存更改</strong></p><ul><li>存储临时改动： <code>git stash</code> </li><li>恢复改动： <code>git stash pop</code> </li></ul><h2 id="创建-git-init"><a href="#创建-git-init" class="headerlink" title="创建 git init"></a>创建 git init</h2><p>进入到一个目标管理文件夹，输入 <code>init</code> 命令创建完成；</p><pre><code class="git">$ git init  // 初始化工作区，创建.git的隐藏文件夹</code></pre><h2 id="保存-git-add-commit"><a href="#保存-git-add-commit" class="headerlink" title="保存 git add / commit"></a>保存 git add / commit</h2><p>保存一个文件的版本：</p><pre><code class="git">$ git add code1.py   // 保存到暂存区$ git commit -m &#39;这是第一个版本&#39;   // 保存到本地文件库</code></pre><p>再保存一个文件的另一个版本：</p><pre><code class="git">$ git add code1.py$ git commit -m &#39;这是第二个版本&#39;</code></pre><p>将工作区所有文件保存到暂存区：</p><pre><code class="git">$ git add .</code></pre><h2 id="查看版本-git-log"><a href="#查看版本-git-log" class="headerlink" title="查看版本 git log"></a>查看版本 git log</h2><p>查看文件多个版本：</p><pre><code class="git">$ git logcommit 699977fa2a89db2dabc8bf9c1d2e17f23dc4a73f (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 15:02:37 2019 +0800    &#39;这是第二个版本。&#39;commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>以简短形式显示：</p><pre><code class="git">$ git log --pretty=oneline</code></pre><p>ps.win窗口使用命令行<strong>不能显示中文字符</strong>：</p><p>使用 <code>Git Bash</code> 窗口，右键设置–文本设置为 <code>zh_ch UTF-8</code> 退出重新进入即可。</p><h2 id="回退-git-reset"><a href="#回退-git-reset" class="headerlink" title="回退 git reset"></a>回退 git reset</h2><p>回到第一个版本：</p><p>HEAD^ 前一个版本；HEAD^^ 前两个版本；HEAD<del>1 前一个版本；HEAD</del>100 前100个版本；</p><pre><code class="git">$ git reset --hard HEAD^commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154 (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>通过版本号回到第二个版本：</p><pre><code class="git">$ git reset --hard 6999HEAD is now at 699977f &#39;这是第二个版本。&#39;</code></pre><p>如果退回到第一版本记录后，即出终端就找不到第二版本的版本号时，我们可以使用 <code>git reflog</code> 查看操作记录，得到最前面的版本号；如下， <code>699977f</code> 就是第二个版本的版本号。</p><pre><code class="git">$ git reflog699977f (HEAD -&gt; master) HEAD@{0}: reset: moving to 6999325e516 HEAD@{1}: reset: moving to HEAD^699977f (HEAD -&gt; master) HEAD@{2}: commit: &#39;这是第二个版本。&#39;325e516 HEAD@{3}: commit (initial): &#39;这是第一个版本。&#39;</code></pre><h2 id="工作区-暂存区"><a href="#工作区-暂存区" class="headerlink" title="工作区 暂存区"></a>工作区 暂存区</h2><p>保存文件的 git_test 是工作区；</p><p>git_test 文件夹下的 .git 文件夹是版本库；其中包含暂存区；</p><p>git add 将文件添加到暂存区； git commit 把暂存区所有内容提交到当前分支，创建版本记录；</p><pre><code class="git">$ git add XXX$ git commit -m 保存到本地文件库要增加的说明文字</code></pre><p>查看未处理提交的文件状态：</p><pre><code class="git">$ git status</code></pre><h2 id="撤销修改-git-checkout"><a href="#撤销修改-git-checkout" class="headerlink" title="撤销修改 git checkout"></a>撤销修改 git checkout</h2><p>文件没有保存到暂存区时，取消修改：</p><pre><code class="git">git checkout -- code2.txt</code></pre><p>文件通过git add code2.txt 保存到了暂存区，取消修改：</p><pre><code class="git">git reset HEAD code2.txt  # 先取消暂存git checkout -- code2.txt # 和上一步一样，取消修改</code></pre><p>如果已经提交到了版本库（git commit -m ‘版本4’），就通过版本回退</p><pre><code class="git">$ git reset --hard HEAD^</code></pre><h2 id="查看不同-git-diff"><a href="#查看不同-git-diff" class="headerlink" title="查看不同 git diff"></a>查看不同 git diff</h2><p>查看工作区与之前版本的不同：</p><pre><code class="git">$ git diff HEAD -- code1.py</code></pre><p>查看上个版本和上上个版本的不同：</p><pre><code class="git">$ git diff Head HEAD^ -- code1.py</code></pre><h2 id="删除文件-git-rm"><a href="#删除文件-git-rm" class="headerlink" title="删除文件 git rm"></a>删除文件 git rm</h2><pre><code class="git">git add code2.txt  # 文件提交到了暂存区rm code2.txt  # 工作区删除文件git rm code2.txt # 将删除提交到暂存区git commit -m &#39;删除后提交的版本&#39;  # 将删除后提交一个版本# 删除后恢复与撤销修改相同</code></pre><h2 id="切换分支-git-branch"><a href="#切换分支-git-branch" class="headerlink" title="切换分支 git branch"></a>切换分支 git branch</h2><p>查看当前所有分支：git branch</p><pre><code class="git">$ git branch* master</code></pre><p>创建分支：git branch dev</p><pre><code class="git">// 创建新分支后：$ git branch* master  // 当前分支  dev  // 新创建的分支</code></pre><p>切换分支：git checkout dev</p><pre><code class="git">// 切换分支后：$ git branch  master* dev  // 当前分支为dev</code></pre><p>创建并切换分支：git checkout -b dev</p><pre><code class="git">$ git checkout -b dev$ git branch* dev  master</code></pre><p>切换回master分支：git checkout master</p><pre><code class="git">$ git checkout master$ git branch  dev* master</code></pre><p>在dev分支上做修改并提交后，可以切换到master分支，并使用以下方式合并dev分支；</p><h2 id="合并分支-git-merge"><a href="#合并分支-git-merge" class="headerlink" title="合并分支 git merge"></a>合并分支 git merge</h2><p>回到主分支master上，合并dev分支：git merge dev</p><pre><code class="git">$ git merge dev</code></pre><h2 id="删除分支-git-branch"><a href="#删除分支-git-branch" class="headerlink" title="删除分支 git branch"></a>删除分支 git branch</h2><p>分支上所有内容都合并到主分支时，可以删除分支：git branch -d dev</p><pre><code class="git">$ git branch -d dev// 如果没有合并子分支上的内容，并需要强制合并，改成大写 -D</code></pre><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>当切换到dev分支修改code.txt并提交add、commit；</p><p>又切换回master分支修改code.txt并提交add、commit；</p><p>将dev分支合并到master时（git merge dev），会出现冲突；</p><p>（现在在master分支当中），手动修改code.txt冲突文件，并再次add、commit提交；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>当在dev分支修改一个文件，并提交commit；</p><p>又在master分支增加一个新文件，并提交commit；</p><p>此时，在两个不同分支下有两个不同的提交；</p><p>此时合并时，git会提示输入一个分支注释文字，并自动创建一个新的分支；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="禁用快速合并-–no-ff"><a href="#禁用快速合并-–no-ff" class="headerlink" title="禁用快速合并 –no-ff"></a>禁用快速合并 –no-ff</h2><p>在dev分支上做了修改并提交一个分支为“dev分支”；</p><p>切换回master分支，将dev分支合并：</p><pre><code class="git">$ git merge dev</code></pre><p>无冲突时，git会使用快速合并 <code>Fast forward</code> ，如果我们要保存分支信息时，需要禁止快速合并；</p><pre><code class="git">$ git merge --no-ff -m &#39;禁用fast forward版本&#39; dev</code></pre><p>此时，原来dev创建的“dev分支”会保留下来，</p><p>并会创建一个新的分支：“禁用fast forward版本”；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p><strong>禁用快速合并的情况</strong></p><p>当我们在dev分支进行工作时，需要临时进入一个临时分支进行bug处理；</p><p>可以先将当前分支存储起来：</p><pre><code class="git">git stash</code></pre><p>此时我们使用 <code>git status</code> 查看，变成了干净的工作区；</p><p>切换回master分支：git checkout master</p><p>创建一个临时分支：bug-001；</p><p>修改bug完成，提交commit一个“修改bug-001版本”；</p><p>切换回master分支；</p><p>此时如果直接合并分支，就没有修改bug-001版本的记录；</p><p>我们就采用禁用快速合并的处理方式；</p><p>合并临时分支：bug-001；</p><pre><code class="git">git merge --no-ff -m &quot;修复bug后的版本&quot; bug-001</code></pre><h2 id="存储工作现场-git-stash-暂时保存更改"><a href="#存储工作现场-git-stash-暂时保存更改" class="headerlink" title="存储工作现场 git stash 暂时保存更改"></a>存储工作现场 git stash 暂时保存更改</h2><p>当我们在dev分支上工作时，需要临时进入master分支上做修改，</p><p>只需在分支上临时保存，再进入master分支操作保存。</p><p>返回dev分支上重新开始工作。</p><pre><code class="git">git stash  // 当前在dev分支，暂存文件$ git statusOn branch dev  // 当前在dev分支nothing to commit, working tree clean  // 暂存文件后，分支变干净了</code></pre><p>回到master分支，进行bug修改，保存：</p><pre><code class="git">git checkout master</code></pre><p>查看存储的工作记录：</p><pre><code class="git">git stash list</code></pre><p>在master分支上完成操作后，返回到dev分支上，恢复工作记录：</p><pre><code class="git">git checkout dev   // 返回dev分支git stash pop   // 恢复工作记录</code></pre><h1 id="github-远程仓库"><a href="#github-远程仓库" class="headerlink" title="github 远程仓库"></a>github 远程仓库</h1><p><img src="http://mdimg.95408.com/201912171203_333.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="1、-A-将新项目-push-至-github"><a href="#1、-A-将新项目-push-至-github" class="headerlink" title="1、  A 将新项目 push 至 github"></a>1、  A 将新项目 push 至 github</h2><p>(1)、A 将地址文件夹1215_git中的项目修改完成，保存到本地仓库；</p><p>(2)、A 在 github.com 上创建一个新项目：1215_git；并得到了项目远程地址： <code>https://github.com/yuanshengorg/1215_git.git</code> 。</p><p>(3)、A 将本地项目 push 至远程仓库：master 表示本地仓库的分支；</p><pre><code class="git">$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>将远程地址改为简短别名：</p><pre><code class="git">$ git remote add origin https://github.com/yuanshengorg/1215_git.gitorigin 表示将远程地址改为的别名</code></pre><p>通过别名推送到远程仓库：</p><pre><code class="git">$ git push origin master</code></pre><p>在第一次推送时，加上 -u 记录：</p><pre><code class="git">$ git push -u origin master</code></pre><p>下一次推送可以更简单：</p><pre><code class="git">$ git push</code></pre><h2 id="2、-B-将项目-clone-到-本地"><a href="#2、-B-将项目-clone-到-本地" class="headerlink" title="2、 B 将项目 clone 到 本地"></a>2、 B 将项目 clone 到 本地</h2><p>在网站上获取 Clone 地址：</p><p><img src="http://mdimg.95408.com/201912171139_943.png?imageView2/2/w/1200/h/1200" alt=""></p><p>克隆远端数据仓库到本地： <code>git clone 仓库地址</code> </p><pre><code class="git">git clone https://github.com/yuanshengorg/1215_git.git</code></pre><h2 id="3、-B-将项目修改后-push-至-github"><a href="#3、-B-将项目修改后-push-至-github" class="headerlink" title="3、 B 将项目修改后 push 至 github"></a>3、 B 将项目修改后 push 至 github</h2><p>B 将项目克隆到本地后，直接在本地修改，add 至暂存区，commit 至本地仓库；</p><p>完成修改，上传到 A 创建的项目远程仓库：</p><pre><code class="git">$ git push origin master   // A 创建的远程地址别名 B 也可以使用或者：$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>B 如果想摄推送内容至 A 的仓库，需要 A 设置一下：邀请 B 为团队成员。</p><p><img src="http://mdimg.95408.com/201912171157_660.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="4、-A-拉取远程仓库中最新的版本"><a href="#4、-A-拉取远程仓库中最新的版本" class="headerlink" title="4、 A 拉取远程仓库中最新的版本"></a>4、 A 拉取远程仓库中最新的版本</h2><p>拉取远程仓库中最新的版本： <code>git pull 远程仓库地址 分支名称</code> </p><pre><code class="git">$ git pull origin master或者：$ git pull https://github.com/yuanshengorg/1215_git.git master</code></pre><p>git clone 是完全克隆；</p><p>git pull 是本地已有项目，只拉取远程仓库中更新的内容；</p><h2 id="SSH-推送"><a href="#SSH-推送" class="headerlink" title="SSH 推送"></a>SSH 推送</h2><p><img src="http://mdimg.95408.com/201912171137_313.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code class="git">$ ssh-keygen</code></pre><p>会在本地（/c/Users/用户名/.ssh/）生成：id_rsa 文件和 id_rsa.pub 文件；</p><p>将 <code>id_rsa.pub</code> 文件打开复制内容设置到 github.com 网站上，即可。</p><p>github.com ——右上角个人中心——settings——SSH and GPG keys——SSH keys，新增保存即可。</p><p><img src="http://mdimg.95408.com/201912171135_162.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="跨团队合作："><a href="#跨团队合作：" class="headerlink" title="跨团队合作："></a>跨团队合作：</h2><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h2 id="忽略清单文件创建："><a href="#忽略清单文件创建：" class="headerlink" title="忽略清单文件创建："></a>忽略清单文件创建：</h2><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>git忽略清单文件名称：<strong>.gitignore</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo创建博客</title>
      <link href="/2019/12/23/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/23/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912180011_408.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="node-js-和-npm"><a href="#node-js-和-npm" class="headerlink" title="node.js 和 npm"></a>node.js 和 npm</h3><p>Hexo是基于nodejs的静态博客，首先需要安装nodejs，并且需要nodejs中的重要工具： <code>npm</code> ；</p><p>查看 nodejs 版本： <code>node -V</code> ；</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>有了nodejs，其他就简单了！安装hexo： <code>npm install -g hexo</code> ；</p><p>查看 hexo 版本： <code>hexo -v</code> ；</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>你也可以安装一个必备的代码管理工具： <code>git</code> ；这样我们就可以使用 <code>git bash</code> 这个工具了；</p><p>查看 git 版本： <code>git version</code> ；</p><h2 id="创建-hexo"><a href="#创建-hexo" class="headerlink" title="创建 hexo"></a>创建 hexo</h2><p>我们在本地创建一个文件夹 <code>d\hexo</code> 做为博客的目录；</p><p>只需3步，完成博客的搭建：</p><p>1、在 <code>d\hexo</code> 目录下，执行以下命令，创建 hexo 完成；</p><pre><code class="git">hexo init</code></pre><p>2、开始书写文章：</p><pre><code class="git">hexo new &#39;我的第一篇hexo博客文章&#39;</code></pre><p>3、运行本地博客服务器：</p><pre><code class="git">$ hexo s    INFO  Start processing    INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>此时，我们在浏览器当中输入： <code>http://local:4000</code> 即可查看网站。</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>使用以下命令创建文章，我们就可以通过 <code>D:\hexo\source\_posts</code> 查看创建的文件，开始创作即可。</p><pre><code class="git">$ hexo new [layout] &lt;title&gt;</code></pre><p>或者直接将md文章放入到 <code>D:\hexo\source\_posts</code> 目录下；</p><h2 id="文章预定义参数"><a href="#文章预定义参数" class="headerlink" title="文章预定义参数"></a>文章预定义参数</h2><p>我们在md文章形状，使用yaml定义标题、分类、标签、日期等等，可以自己增减。</p><pre><code class="yaml">---title: 文章标题date： 日期categories: 分类tags: 标签---</code></pre><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">官方文档：更多预先定义的参数</a></p><p>如果是有子分类：</p><pre><code class="yaml">categories: [父分类， 子分类]</code></pre><p>如果是有多个标签：</p><pre><code class="yaml">tags: [标签1， 标签2]</code></pre><h2 id="搭建到-github"><a href="#搭建到-github" class="headerlink" title="搭建到 github"></a>搭建到 github</h2><p>1、创建 github 账号，并创建 ssh （参考：<a href="https://yuanshengorg.github.io/2019/12/17/tools/git%E5%92%8Cgithub/#SSH-%E6%8E%A8%E9%80%81" target="_blank" rel="noopener">git和github：SSH</a>）； </p><p>2、在自己的账号下，新建一个repo： <code>New repository</code> （github右上角 + 号——New repository）；</p><p>3、项目名称（Repository name）为： <code>你的名称.github.io</code> ，如 <code>yuansheng.github.io</code> ；</p><p><img src="http://mdimg.95408.com/201912172352_728.png?imageView2/2/w/1200/h/1200" alt=""></p><p>4、回到本地文件夹： <code>d/hexo</code> ，修改文件： <code>_config.yml</code> ：</p><pre><code class="git">deploy:  type: git  repo: https://github.com/yuansheng/yuansheng.github.io.git  branch: master</code></pre><p>repo 请修改为你创建的地址。</p><p>5、安装工具：hexo-deployer-git</p><pre><code class="git">npm install hexo-deployer-git --save</code></pre><p>6、回到命令行工具运行：</p><pre><code class="git">hexo clean // 清除之前生成的文件hexo generate   // 生成新的静态文件hexo depoly   // 部署网站</code></pre><p>执行 <code>hexo depoly</code> 时，第一次可能会需要注册 github.com 的账号及密码；</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>输入 <code>yuansheng.github.io</code> ，即你设置的项目文件名，即可访问网站；</p><p>你也可以绑定自己的域名，如 <code>www.yuanblogname.com</code> ；</p><h2 id="增-改文章"><a href="#增-改文章" class="headerlink" title="增/改文章"></a>增/改文章</h2><p>上面的三个命令 <code>hexo clean / generate / depoly</code> 可简写为：</p><pre><code class="git">hexo cleanhexo ghexo d</code></pre><p>以后每次在文件夹中增加、修改了 md 文章后，执行这三个命令即可；</p><p>所有在本地电脑上修改的文档，远程博客也就修改了。</p><h2 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo官方文档：指令</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档：中文</a></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo折腾记录更新</title>
      <link href="/2019/12/23/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/12/23/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新中 …</p></blockquote><hr><h2 id="不能出现双大括号"><a href="#不能出现双大括号" class="headerlink" title="不能出现双大括号"></a>不能出现双大括号</h2><blockquote><p>20191223</p></blockquote><p>不能生成markdown格式：</p><pre><code class="git">D:\hexo&gt;hexo s (line number probably different from source)</code></pre><p>原因：不在在非代码块之外显示 <code>双花括号</code> ：</p><pre><code class="js">{{}}</code></pre><hr><h2 id="增加域名，备份git仓库"><a href="#增加域名，备份git仓库" class="headerlink" title="增加域名，备份git仓库"></a>增加域名，备份git仓库</h2><blockquote><p>20191218</p></blockquote><ul><li>绑定独立域名： <code>halfbamboo.com</code> ；</li><li>文件备份到 <code>git</code> 仓库；</li></ul><hr><h2 id="修改主题及压缩css-js"><a href="#修改主题及压缩css-js" class="headerlink" title="修改主题及压缩css/js"></a>修改主题及压缩css/js</h2><blockquote><p>20191218</p></blockquote><ul><li>修改博客主题的CSS样式；</li><li>增加 pulyfile.js 压缩 html/css/js；（放弃）</li><li>增加 hexo-neat 插件压缩 css/js；（html未能压缩）</li></ul><p><img src="http://mdimg.95408.com/201912182118_637.png?imageView2/2/w/1200/h/1200" alt="修改后的3-hexo主题"></p><hr><h2 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h2><blockquote><p>20191217</p></blockquote><ul><li>本地创建hexo博客： <code>d:/hexo</code> ；</li><li>更换主题： <code>hexo-theme-3-hexo</code> ；</li><li>上传至 ` github.com；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法CSS表现测试</title>
      <link href="/2019/12/23/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/23/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p><strong>代码：</strong> <code>``</code></p><p><code>$ npm install hexo-cli -g</code> </p><pre><code class="shell">$ npm install hexo-cli -g</code></pre><p><strong>列表：</strong> <code>1.</code> </p><ol><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ol><p><strong>列表：</strong> <code>-</code> </p><ul><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ul><p><strong>链接：</strong> <code>[]()</code> </p><p><a href="http://www.halfbamboo.com" target="_blank" rel="noopener">半根竹子的官方网站</a></p><p><strong>块引用：</strong> <code>&gt;</code> </p><blockquote><p>回归20年，背靠 <code>祖国</code> 、面向世界的澳门特区迎来一次次发展机遇；脚踏实地、开拓进取的澳门创业者站上更为广阔的发展舞台。</p></blockquote><p><strong>水平分割线：</strong> <code>------</code> </p><hr><p><strong>代码块：</strong> </p><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);}); // 注释</code></pre><p><strong>图片：</strong></p><p><img src="http://mdimg.95408.com/20191218121717.png" alt="图片说明文字"></p><p><strong>表格：</strong></p><table><thead><tr><th>标题1</th><th>标题2</th><th>标题2</th></tr></thead><tbody><tr><td>一</td><td>二</td><td>三</td></tr><tr><td>html, html, html</td><td>python, python, python</td><td>js, js, js</td></tr><tr><td>css, css, css</td><td>Django, Django, Django</td><td>node, node, node</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 vs code 命令快捷键</title>
      <link href="/2019/12/23/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/"/>
      <url>/2019/12/23/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、光标移动到行尾-行首"><a href="#1、光标移动到行尾-行首" class="headerlink" title="1、光标移动到行尾/行首"></a>1、光标移动到行尾/行首</h3><p>当软件自动补全时，我们常常会需要将光标移动到行尾，可以使用 <code>end</code> 键，或者自定义一个更方便的键，比如：<code>Ctrl + ;</code> 。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>END</td><td>cursorEnd   光标移动到行尾</td><td>/</td></tr><tr><td>HOME</td><td>cursorHome   光标移动到行首</td><td><strong>Ctrl + Shift + ;</strong></td></tr><tr><td>无</td><td>cursorLineEnd   光标移动到行尾</td><td><strong>Ctrl + ;</strong></td></tr><tr><td>无</td><td>cursorLineStart   光标移动到行首</td><td>/</td></tr></tbody></table><h3 id="2、选择当前单词"><a href="#2、选择当前单词" class="headerlink" title="2、选择当前单词"></a>2、选择当前单词</h3><p>连续按展开选择，第一次选中当前单词，第二次选择当前行；继续选择当前块；只按一次的话，就是选择当前单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Shift + Alt + Right</td><td>展开选择</td><td><strong>Alt + I</strong></td></tr><tr><td>Shift + Alt + Left</td><td>收起选择</td><td><strong>Alt + O</strong></td></tr></tbody></table><h3 id="3、光标移动到下-上一个单词（取消）"><a href="#3、光标移动到下-上一个单词（取消）" class="headerlink" title="3、光标移动到下/上一个单词（取消）"></a>3、光标移动到下/上一个单词（取消）</h3><p>我们需要将光标跳转到下一个单词或者上一个单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Ctrl + Right</td><td>cursorWordEndRight   光标移动到右边单词结尾</td><td>/</td></tr><tr><td>Ctrl + Left</td><td>cursorWordStartLeft   光标移动到左边单词开关</td><td>/</td></tr></tbody></table><h3 id="4、不使用方向键上下移动"><a href="#4、不使用方向键上下移动" class="headerlink" title="4、不使用方向键上下移动"></a>4、不使用方向键上下移动</h3><p>我们要将光标上下移动时，使用上、下按键也是不方便，所以 vim 中使用了 <code>h j k l</code> ；</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>DOWN</td><td>cursorDown   向下移动光标</td><td><strong>Alt + J</strong></td></tr><tr><td>UP</td><td>cursorUp   向上移动光标</td><td><strong>Alt + K</strong></td></tr><tr><td>LEFT</td><td>cursorLeft   向左移动光标</td><td><strong>Alt + L</strong></td></tr><tr><td>RIGTH</td><td>cursorRight   向右移动光标</td><td><strong>Alt + ;</strong></td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912251933_357.png?null" alt="自定义vs快捷键"></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="/2019/12/23/vue/Vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/23/vue/Vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h2 id="Vue-模板语法"><a href="#Vue-模板语法" class="headerlink" title="Vue 模板语法"></a>Vue 模板语法</h2><ul><li>原生js拼接字符串</li><li>前端模板引擎（art-template）缺：没有专门提供事件机制</li><li>Vue模板语法</li></ul><p>差值表达式<br>指令<br>事件绑定<br>属性绑定<br>样式绑定<br>分支循环结构</p><h3 id="差值表达式-v-cloak"><a href="#差值表达式-v-cloak" class="headerlink" title="差值表达式 v-cloak"></a>差值表达式 v-cloak</h3><p><strong>什么是指令？</strong></p><p>指令的本质就是自定义属性；以 <code>v-</code> 开头；</p><p><strong>闪动</strong>：html页面被刷新时，会先显示 <code>大括号</code> ，再显示数据；</p><p><strong>v-clack</strong>：先通过样式隐藏内容，然后在内存中进行值的替换，替换完成之后再显示最终的结果；</p><pre><code class="html">&lt;style&gt;    [v-cloak] {        display: none;    }&lt;/style&gt;&lt;body&gt;    &lt;div v-cloak&gt; {{msg}} &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="更多指令："><a href="#更多指令：" class="headerlink" title="更多指令："></a>更多指令：</h4><blockquote><p>官网：<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">vuejs.org</a></p></blockquote><p><strong>数据绑定指令：</strong></p><p>v-text、v-html、v-pre</p><h4 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h4><p>没有闪动问题；</p><pre><code class="html">&lt;div v-text=&#39;msg&#39;&gt;&lt;/div&gt;</code></pre><h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>永不用在用户提交的内容上，只适合本网站内部数据；</p><pre><code class="html">&lt;div v-html=&#39;msg1&#39;&gt;&lt;/div&gt;</code></pre><h4 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h4><p>显示原始信息，路过Vue编译过程</p><pre><code class="html">// 直接显示出{{msg}}这个字符串，而不是msg数据的内容&lt;div v-pre&gt;    {{msg}}&lt;/div&gt;</code></pre><h4 id="数据响应式-和-v-once"><a href="#数据响应式-和-v-once" class="headerlink" title="数据响应式 和 v-once"></a>数据响应式 和 v-once</h4><p>数据响应式：数据的变化导致页面内容的变化；</p><p>数据绑定：将数据填充到标签中；</p><p>v-once：只编译一次，显示内容之后不再有响应式的功能；</p><h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h4><p>如果显示的信息后续不需要再修改，可以使用v-once；可以提高性能；</p><pre><code class="html">&lt;div v-once&gt;    {{info}} // info数据只编译一次，不能再改&lt;/div&gt;</code></pre><h4 id="v-model-双向数据绑定"><a href="#v-model-双向数据绑定" class="headerlink" title="v-model 双向数据绑定"></a>v-model 双向数据绑定</h4><p>数据改变，页面内容改变；</p><p>页面内容改变，数据改变；</p><pre><code class="html">&lt;div&gt;{{msg}}&lt;/div&gt;&lt;input type=&#39;text&#39; v-model=&#39;msg&#39; /&gt;</code></pre><h3 id="MVVM-设计思想"><a href="#MVVM-设计思想" class="headerlink" title="MVVM 设计思想"></a>MVVM 设计思想</h3><p>M    ——model</p><p>V    ——view</p><p>VM    ——view-model</p><p>页面input改变数据，通过<strong>事件监听</strong>DOM Listeners改变数据库Model；</p><p>数据通过<strong>数据绑定</strong>Data Bindings传递到View；</p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="v-on-处理事件"><a href="#v-on-处理事件" class="headerlink" title="v-on 处理事件"></a>v-on 处理事件</h4><pre><code class="html">v-on:click=&#39;num++&#39;@click=&#39;num++&#39;</code></pre><p>点击加1：</p><pre><code class="html">&lt;div id=&#39;app&#39;&gt;    &lt;div&gt;{{num}}&lt;/div&gt; // num=1    &lt;button v-on:click=&#39;num++&#39;&gt;点击加1&lt;/button&gt;&lt;/div&gt;</code></pre><h4 id="事件函数调用"><a href="#事件函数调用" class="headerlink" title="事件函数调用"></a>事件函数调用</h4><p>事件绑定-参数传递</p><p>如果事件直接绑定函数名称，默认会传递事件对象作为事件函数的第一个参数；</p><p>如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，名称为：event；</p><pre><code class="html">&lt;div id=&#39;app&#39;&gt;    &lt;div&gt;{{num}}&lt;/div&gt; // num=1    &lt;button @:click=&#39;handle&#39;&gt;点击加1&lt;/button&gt;    &lt;button @:click=&#39;handle(11, 22, $envnt)&#39;&gt;点击加1&lt;/button&gt;    // 可以传参数，事件对象放在最后一个&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: &#39;#app&#39;,        data: {            num: 0        },        methods: {            handle: function(a, b.event) {                //this是Vue的实例对象                console.log(this === vm);                console.log(a, b);                console.log(event.target.innerHTML)                this.num++;            }        }    })&lt;/script&gt;</code></pre><h4 id="事件修饰符-stop-prevent"><a href="#事件修饰符-stop-prevent" class="headerlink" title="事件修饰符 stop prevent"></a>事件修饰符 stop prevent</h4><h4 id="stop阻止冒泡"><a href="#stop阻止冒泡" class="headerlink" title=".stop阻止冒泡"></a>.stop阻止冒泡</h4><pre><code class="html">&lt;a v-on:click.stop=&#39;handle&#39;&gt;跳转&lt;/a&gt;</code></pre><h4 id="prevent-阻止默认行为"><a href="#prevent-阻止默认行为" class="headerlink" title=".prevent 阻止默认行为"></a>.prevent 阻止默认行为</h4><pre><code class="html">&lt;a v-on:click.prvevnet=&#39;handle&#39;&gt;跳转&lt;/a&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（7）博客项目</title>
      <link href="/2019/12/07/node/Untitled/"/>
      <url>/2019/12/07/node/Untitled/</url>
      
        <content type="html"><![CDATA[<h3 id="加密-bcrypt"><a href="#加密-bcrypt" class="headerlink" title="加密 bcrypt"></a>加密 bcrypt</h3><pre><code class="js">python 2. Xnpm install - g node - gypnpm install--global--production windows - build - tools重启命令行工具npm install bcrypt</code></pre><p><strong>加密：</strong></p><pre><code class="js">    // 生成随机字符串    const salt = await bcrypt.genSalt(10);    // 将原密码加密    const password = await bcrypt.hash(req.body.password, salt);    // 将req.body中的password替换成加密后的密码password    req.body.password = password;    // res.send(req.body.password) // 生成加密后的密码    // 将用户信息添加到数据库    await User.create(req.body);    // 添加成功后，重定向到用户页/admin/user    res.redirect(&#39;/admin/user&#39;);</code></pre><p><strong>验证：</strong></p><pre><code class="js">    // 查询用户集合中此email数据是否存在    let user = await User.findOne({        email    });    // 如果查询到了用户,再对比密码    if (user) {        // 对比密码        // compare(传递来的明文密码，数据为的加密密码)的对比        // 返回布尔值        let isValid = await bcrypt.compare(password, user.password)        if (isValid) {            // 登陆成功            // 重定向到列表页            res.redirect(&#39;/admin/user&#39;);        } else {            // 密码错误不成功            res.status(400).render(&#39;admin/error&#39;, {                msg: &#39;密码错误&#39;            });        }</code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><pre><code class="js">npm install express - session</code></pre><h3 id="登陆验证-joi"><a href="#登陆验证-joi" class="headerlink" title="登陆验证 joi"></a>登陆验证 joi</h3><pre><code class="js">npm install joi</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（6）Express框架</title>
      <link href="/2019/12/06/node/Node.js%EF%BC%886%EF%BC%89Express%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/12/06/node/Node.js%EF%BC%886%EF%BC%89Express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Express-框架"><a href="#Express-框架" class="headerlink" title="Express 框架"></a>Express 框架</h2><p>Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。</p><p><strong>下载</strong>：</p><pre><code class="js">npm install express</code></pre><p><strong>特性</strong>：</p><ul><li>提供了方便简洁的路由定义方式</li><li>对获取HTTP请求参数进行了简化处理</li><li>对模板引擎支持程度高，方便渲染动态HTML页面</li><li>提供了中间件机制有效控制HTTP请求</li><li>有大量第三方中间件对功能进行扩展</li></ul><h3 id="原生Node-js与Express对比"><a href="#原生Node-js与Express对比" class="headerlink" title="原生Node.js与Express对比"></a>原生Node.js与Express对比</h3><p><strong>路由：</strong></p><pre><code class="js"> app.on(&#39;request&#39;, (req, res) =&gt; {     // 获取客户端的请求路径     let {         pathname     } = url.parse(req.url);     // 对请求路径进行判断 不同的路径地址响应不同的内容     if (pathname == &#39;/&#39; || pathname == &#39;index&#39;) {         res.end(&#39;欢迎来到首页&#39;);     } else if (pathname == &#39;/list&#39;) {         res.end(&#39;欢迎来到列表页页&#39;);     } else if (pathname == &#39;/about&#39;) {         res.end(&#39;欢迎来到关于我们页面&#39;)     } else {         res.end(&#39;抱歉, 您访问的页面出游了&#39;);     } }); // Express // 当客户端以get方式访问/时 app.get(&#39;/&#39;, (req, res) =&gt; {     // 对客户端做出响应     res.send(&#39;Hello Express&#39;); }); // 当客户端以post方式访问/add路由时 app.post(&#39;/add&#39;, (req, res) =&gt; {     res.send(&#39;使用post方式请求了/add路由&#39;); });</code></pre><p><strong>获取请求参数：</strong></p><pre><code class="js"> app.on(&#39;request&#39;, (req, res) =&gt; {     // 获取GET参数     let {         query     } = url.parse(req.url, true);     // 获取POST参数     let postData = &#39;&#39;;     req.on(&#39;data&#39;, (chunk) =&gt; {         postData += chunk;     });     req.on(&#39;end&#39;, () =&gt; {         console.log(querystring.parse(postData)         })); }); // Express app.get(&#39;/&#39;, (req, res) =&gt; {     // 获取GET参数     console.log(req.query); }); app.post(&#39;/&#39;, (req, res) =&gt; {     // 获取POST参数     console.log(req.body); })</code></pre><h3 id="Express基本使用"><a href="#Express基本使用" class="headerlink" title="Express基本使用"></a>Express基本使用</h3><pre><code class="js"> // 引入Express框架 const express = require(&#39;express&#39;); // 使用框架创建web服务器 const app = express(); // 当客户端以get方式访问/路由时 app.get(&#39;/&#39;, (req, res) =&gt; {     // 对客户端做出响应 send方法会根据内容的类型自动设置请求头     res.send(&#39;Hello Express&#39;); // &lt;h2&gt;Hello Express&lt;/h2&gt; {say: &#39;hello&#39;} }); // 程序监听3000端口 app.listen(3000);</code></pre><p>不再使用res.end，而是使用res.send方法：</p><ul><li>send方法会自动检测响应内容的类型</li><li>自动设置http状态码</li><li>自动设置响应内容类型及编码</li></ul><pre><code class="js">// 引入express框架const express = require(&#39;express&#39;);// 创建网站服务器const app = express();app.get(&#39;/&#39;, (req, res) =&gt; {    res.send(&#39;Hello Express&#39;);})// 监听端口app.listen(3000);console.log(&#39;网站服务器启动成功：localhost:3000&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912231402_279.png?null" alt="Hello Express"></p><h2 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h2><p>中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。</p><p>比如：通过中间件，确认用户是否登陆，登陆后跳转到个人页；</p><p>比如：路由、GET、POST；</p><p><img src="http://mdimg.95408.com/201912231405_838.png?null" alt="中间件"></p><p>中间件主要由两部分构成，中间件方法以及请求处理函数。</p><p>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。</p><pre><code class="js">app.get(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理get请求app.post(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理post请求</code></pre><h3 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h3><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><p>默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。</p><p>可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><pre><code class="js">app.get(&#39;/&#39;, (req, res, next) =&gt; {    req.name = &#39;lisi&#39;;    next();});app.get(&#39;/&#39;, (req, res) =&gt; {    res.send(req.name);})// 输出：lisi</code></pre><h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><p>app.use 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p><p>app.use 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p><pre><code class="js">// 接收所有请求的中间件app.use((req, res, next) =&gt; {    console.log(&#39;请求走了app.use&#39;);    next();})// 客户访问/list请求app.use(&#39;/list&#39;, (req, res, next) =&gt; {    console.log(&#39;请求走了app.use/list&#39;);    next();})// 请求走了app.use// 请求走了app.use / list// /admin请求app.get(&#39;/amin&#39;, (req, res) =&gt; {    res.send(&#39;ok&#39;)})// 请求走了app.use</code></pre><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><p><strong>路由保护</strong></p><p>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p><pre><code class="js">// 设置一个变量，如果为false表示没有登陆// 如果登陆，使用next，请求继续向下执行app.use(&#39;/admin&#39;, (req, res, next) =&gt; {    let isLogin = true;    if (isLogin) {        // 如果用户登陆，请求继续向下执行        next();    } else {        res.send(&#39;您还没有登陆&#39;)    }})// isLogin为true时，才能进入app.get(&#39;/admin&#39;, (req, res) =&gt; {    res.send(&#39;您已登陆，可以访问后台&#39;)})</code></pre><p><strong>网站维护公告</strong></p><p>在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p><pre><code class="js">// 在最开始调用，并且不加next方法// 就不能往后执行app.use((req, res, next) =&gt; {    res.send(&#39;网站维护，禁止访问&#39;);})// 其他页面统统不能访问app.get(&#39;/admin&#39;, (req, res) =&gt; {    res.send(&#39;后台&#39;);})app.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;首页&#39;);})</code></pre><p><strong>自定义404页面</strong></p><pre><code class="js">app.get(&#39;/admin&#39;, (req, res) =&gt; {    res.send(&#39;后台&#39;);})app.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;首页&#39;);})// 前面所有的都存在，执行404app.use((req, res, next) =&gt; {    // 为客户端响应404状态码及提示信息    res.status(404).send(&#39;404页面&#39;);})</code></pre><p><img src="http://mdimg.95408.com/201912231447_808.png?null" alt="404页面"></p><h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><pre><code class="js">app.get(&#39;/index&#39;, (req, res) =&gt; {    // 创建一个错误实例：throw抛出错误    throw new Error(&#39;程序发生了XX错误&#39;);    // 如果取消throw错误，正常执行    // 就不会执行错误处理中间件    // res.send(&#39;正常执行&#39;);})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.status(500).send(err.message);})</code></pre><p><img src="http://mdimg.95408.com/201912231458_653.png?null" alt="错误处理中间件"></p><pre><code class="js">app.get(&#39;/index&#39;, (req, res, next) =&gt; {    fs.readFile(&#39;./file-not-exist.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {        if (err != null) {            // 错误，通过app.get()中的next传递            next(err);        } else {            // 正常执行，输出值            res.send(result);        }    });})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.status(500).send(err.message);});// 输出：ENOENT: no such file or directory, open &#39;D:\doc\1221express\no-file.txt&#39;</code></pre><h3 id="异步函数-捕获错误"><a href="#异步函数-捕获错误" class="headerlink" title="异步函数 捕获错误"></a>异步函数 捕获错误</h3><p>在node.js中，异步API的错误信息都是通过回调函数获取的；<strong>异步函数</strong>执行如果发生错误要如何捕获错误呢？</p><p>try catch 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。</p><pre><code class="js"> app.get(&quot;/&quot;, async (req, res, next) =&gt; {     try {         await User.find({             name: &#39;张三&#39;         })     } catch (ex) {         next(ex);     } });</code></pre><p>读取一个不存在的文件：</p><pre><code class="js">// 引入express框架const express = require(&#39;express&#39;);const fs = require(&#39;fs&#39;);const promisify = require(&#39;util&#39;).promisify;// 创建网站服务器const app = express();app.get(&#39;/index&#39;, async (req, res, next) =&gt; {    try {        await readFile(&#39;./not-file.js&#39;);    } catch (ex) {        next(ex);    }})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.status(500).send(err.message);});// 输出：readFile is not defined// 监听端口app.listen(3000);console.log(&#39;网站服务器启动成功：localhost:3000&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912231631_341.png?null" alt=""></p><h2 id="Express框架请求处理"><a href="#Express框架请求处理" class="headerlink" title="Express框架请求处理"></a>Express框架请求处理</h2><h3 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h3><pre><code class="js">// 引入express框架const express = require(&#39;express&#39;);// 创建网站服务器const app = express();// 创建路由对象const home = express.Router();// 为路由对象匹配请求路径app.use(&#39;/home&#39;, home);// 创建二级路由home.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;欢迎来到博客首页/home/index&#39;)})// 监听端口app.listen(3000);console.log(&#39;网站服务器启动成功：localhost:3000&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912231647_415.png?null" alt=""></p><p>创建一个route路由目录，将不同的路由分文件存放：</p><pre><code class="js">route 目录admin.jshome.jsapp.js// ---------------------------------------// ./route/admin.jsconst express = require(&#39;express&#39;);const admin = express.Router();admin.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;博客后台首页/admin/index&#39;);})module.exports = admin;// ---------------------------------------// ./route/home.jsconst express = require(&#39;express&#39;);const home = express.Router();home.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;博客前台首页/home/index&#39;)});module.exports = home;// ---------------------------------------// ./app.jsconst express = require(&#39;express&#39;);const app = express();const home = require(&#39;./route/home&#39;);const admin = require(&#39;./route/admin&#39;);app.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;index&#39;)})app.use(&#39;./home&#39;, home);app.use(&#39;./admin&#39;, admin);app.listen(3000);console.log(&#39;localhost:3000&#39;);// 访问：// http://localhost:3000/home/index :  博客前台首页/home/index// http://localhost:3000/admin/index : 博客前台首页/home/index</code></pre><h3 id="获取GET参数"><a href="#获取GET参数" class="headerlink" title="获取GET参数"></a>获取GET参数</h3><p>Express框架中使用<strong>req.query</strong>即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><pre><code class="js">const express = require(&#39;express&#39;);const app = express();app.get(&#39;/index&#39;, (req, res) =&gt; {    // 获取get请求参数    res.send(req.query);})app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231734_419.png?null" alt=""></p><h3 id="获取POST参数"><a href="#获取POST参数" class="headerlink" title="获取POST参数"></a>获取POST参数</h3><p>Express中接收post请求参数需要借助第三方包 body-parser。</p><p>Express官方模块；安装：</p><pre><code class="js">npm install body - parser</code></pre><p>使用：</p><pre><code class="js">// ./post.html&lt;body&gt;    &lt;form action = &quot;http://localhost:3000/add&quot; method = &quot;POST&quot; &gt;        &lt;input type = &quot;text&quot; name = &quot;username&quot; &gt;        &lt;input type = &quot;password&quot; name = &quot;password&quot; &gt;        &lt;input type = &quot;submit&quot; &gt;    &lt;/form&gt; &lt;/body&gt;// ./app.jsconst express = require(&#39;express&#39;);const bodyParser = require(&#39;body-parser&#39;);const app = express();// 拦截所有请求// extended: false 方法内部使用querystring模块处理请求参数的格式// extended: true 方法内部使用第三方模块qs处理请求参数的格式app.use(bodyParser.urlencoded({    extended: false}));app.post(&#39;/add&#39;, (req, res) =&gt; {    // 接收post请求参数    res.send(req.body);})app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231753_382.png?null" alt="获取POST参数"></p><h3 id="params路由参数"><a href="#params路由参数" class="headerlink" title="params路由参数"></a>params路由参数</h3><pre><code class="js">const express = require(&#39;express&#39;);// const bodyParser = require(&#39;body-parser&#39;);const app = express();app.get(&#39;/index/:id/:name&#39;, (req, res) =&gt; {    //接收post参数    res.send(req.params);})// 请求：http://localhost:3000/index/188/zhangsan// 响应：{&quot;id&quot;:&quot;188&quot;,&quot;name&quot;:&quot;李四&quot;}app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231808_219.png?null" alt=""></p><h2 id="静态资源static"><a href="#静态资源static" class="headerlink" title="静态资源static"></a>静态资源static</h2><p>通过Express内置的<strong>express.static</strong>可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。</p><pre><code class="js">app.use(express.static(&#39;public&#39;));</code></pre><p>将项目根目录下的public目录的文件，做为静态资源：</p><pre><code class="js">const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();// 实现静态资源访问功能app.use(express.static(path.join(__dirname, &#39;public&#39;)));app.listen(3000);</code></pre><p>此时，我们直接访问： <code>http://localhost:3000/css/base.css</code> ；</p><p>如果要要前缀 <code>files</code> 的话 <code>http://localhost:3000/files/css/base.css</code> ：</p><pre><code class="js">// 实现静态资源访问功能app.use(&#39;/files&#39;, express.static(path.join(__dirname, &#39;public&#39;)));app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231819_717.png?null" alt=""></p><p><strong>注意</strong>：</p><p>html、art模板文件中的静态资源相对路径，是相对于请求路径的；</p><p>模板文件中，外链资源要写绝对路径，就是以 <code>/</code> 开关；</p><pre><code class="js">&lt;link rel = &quot;stylesheet&quot; href = &quot;/admin/css/base.css&quot;&gt;</code></pre><p>子模板的相对路径，是相对当前文件；</p><p>引入的模板文件，由模板引擎解析，写相对路径；</p><pre><code class="js">{{ include './common/header' }}</code></pre><h2 id="模板引擎express-art-template"><a href="#模板引擎express-art-template" class="headerlink" title="模板引擎express-art-template"></a>模板引擎express-art-template</h2><p>安装</p><pre><code class="js">npm install art-template express-art-template</code></pre><p>为了使 <code>art-template</code> 模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了 <code>express-art-template</code> 。</p><pre><code class="js">// views 目录//    /views/index.art 模板文件// app.js// ---------------------------------------// ./app.jsconst express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();// engine(模板后缀，模板引擎)app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;));// 设置模板文件路径app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));// 设置模板文件默认后缀app.set(&#39;view engine&#39;, &#39;art&#39;);// 客户端访问/index路由app.get(&#39;/index&#39;, (req, res) =&gt; {    // render(&#39;index&#39;)这里的index就是    // 引用的./views目录下的模板文件    // res.render将拼接的模板响应给客户端    res.render(&#39;index&#39;, {        msg: &#39;我是msg的值&#39;,        name: &#39;张三&#39;,        age: &#39;18&#39;    })})app.listen(3000);// ---------------------------------------// ./views/index.art&lt;body &gt;     {{msg}}     {{name}}     {{age}} &lt;/body&gt;</code></pre><p><img src="http://mdimg.95408.com/201912232016_357.png?null" alt=""></p><h2 id="locals对象"><a href="#locals对象" class="headerlink" title="locals对象"></a>locals对象</h2><p>当有一些公共数据在每个页面都需要加载，而不希望在每个app.get()中查询，可以定义到 <code>locals</code> 中；</p><pre><code class="js">// views 模板目录//        /views/index.art//        /views/list.art// app.js// ---------------------------------------// app.jsconst express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;));app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));app.set(&#39;view engine&#39;, &#39;art&#39;);app.locals.users = [{    name: &#39;张三&#39;,    age: 20}, {    name: &#39;李四&#39;,    age: 30}]app.get(&#39;/index&#39;, (req, res) =&gt; {    res.render(&#39;index&#39;, {        msg: &#39;首页msg的值&#39;    })})app.get(&#39;/list&#39;, (req, res) =&gt; {    res.render(&#39;list&#39;, {        msg: &#39;列表页msg的值&#39;    })})app.listen(3000);// ---------------------------------------// /views/index.art&lt;body &gt;     {{msg}} // 首页msg的值    &lt;ul&gt;         {{each users}}             &lt;li &gt;                 {{ $value.name}} // 张三 20   李四 30                {{$value.age}}             &lt;/li&gt;         {{/each}}     &lt;/ul&gt; &lt;/body&gt;// ---------------------------------------// /views/list.art&lt;body &gt;     {{msg}} //列表页msg的值    &lt;ul &gt;        {{each users}}             &lt;li &gt;                {{$value.name}} // 张三 20   李四 30                {{$value.age}}             &lt;/li&gt;        {{/each}}    &lt;/ul&gt; &lt;/body&gt;</code></pre><p><img src="http://mdimg.95408.com/201912232035_11.png?null" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（5）art-Template模板引擎</title>
      <link href="/2019/12/05/node/Node.js%EF%BC%885%EF%BC%89art-Template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2019/12/05/node/Node.js%EF%BC%885%EF%BC%89art-Template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>让开发者以更加友好的方式拼接字符串，使项目代码更加清晰、更加易于维护。</p><p><img src="http://mdimg.95408.com/201912231155_737.png?null" alt="使用模板引擎的写法"></p><h3 id="art-template模板引擎"><a href="#art-template模板引擎" class="headerlink" title="art-template模板引擎"></a>art-template模板引擎</h3><p>安装：</p><pre><code class="js">npm install art - template</code></pre><p>使用：</p><pre><code class="js">// 导入模板引擎模块const template = require(&#39;art-template&#39;);// 将特定模板与特定数据进行拼接const html = template(&#39;./views/index.art&#39;, {    data: {        name: &#39;张三&#39;,        age: 20    }});// 使用：./views/index.art&lt;div &gt;    &lt;    span &gt; {        {            data.name        }    } &lt; /span&gt; &lt;    span &gt; {        {            data.age        }    } &lt; /span&gt; &lt;    /div&gt;</code></pre><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code class="js"> &lt;!-- 标准语法 --&gt; &lt; h2 &gt; {         {             value         }     } &lt; /h2&gt; &lt;     h2 &gt; {         {             a ? b : c         }     } &lt; /h2&gt; &lt;     h2 &gt; {         {             a + b         }     } &lt; /h2&gt;     &lt;     !--原始语法 --&gt;     &lt;     h2 &gt; &lt; %= value % &gt; &lt; /h2&gt; &lt;     h2 &gt; &lt; %= a ? b : c % &gt; &lt; /h2&gt; &lt;     h2 &gt; &lt; %= a + b % &gt; &lt; /h2&gt;</code></pre><h3 id="原文输出"><a href="#原文输出" class="headerlink" title="原文输出"></a>原文输出</h3><p>如果数据中携带HTML标签，默认模板引擎不会解析标签，会将其转义后输出。</p><pre><code class="js">&lt;!-- 标准语法 --&gt;&lt;h2 &gt; {        {            @ value        }    } &lt; /h2&gt; &lt;    !--原始语法 --&gt;    &lt;    h2 &gt; &lt; % -value % &gt; &lt; /h2&gt;</code></pre><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><pre><code class="js"> &lt;!-- 标准语法 --&gt;  {     {         if 条件     } }...{     {         /if}} {             {                 if v1             }         }...{             {                 else if v2             }         }...{             {                 /if}} &lt;                 !--原始语法 --&gt;                     &lt;                     %                     if (value) {                         % &gt; ... &lt; %                     } % &gt;                     &lt;                     %                 if (v1) {                     % &gt; ... &lt; %                 } else if (v2) {                     % &gt; ... &lt; %                 } % &gt;</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code class="js">&lt;!-- 标准语法 --&gt;{    {        each target    }} {    {        $index    }} {    {        $value    }} {    {        /each}} &lt;        !--原始语法 --&gt;            &lt;            %            for (var i = 0; i &lt; target.length; i++) {                % &gt;                &lt;                %= i % &gt; &lt; %= target[i] % &gt;                    &lt;                    %            } % &gt;</code></pre><h3 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h3><p>使用子模板可以将网站公共区块(头部、底部)抽离到单独的文件中。</p><pre><code class="js">  &lt;!-- 标准语法 --&gt;  {      {          include &#39;./header.art&#39;      }  } &lt;  !--原始语法 --&gt;      &lt;      % include(&#39;./header.art&#39;) % &gt;</code></pre><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>使用模板继承可以将网站HTML骨架抽离到单独的文件中，其他页面模板可以继承骨架文件。</p><pre><code class="js">// layout.art文件 &lt;html &gt;    &lt;    head &gt;    &lt;    meta charset = &quot;utf-8&quot; &gt;    &lt;    title &gt; HTML骨架模板 &lt; /title&gt; {        {            block &#39;head&#39;        }    } {        {            /block}} &lt;            /head&gt; &lt;            body &gt; {                    {                        block &#39;content&#39;                    }                } {                    {                        /block}} &lt;                        /body&gt; &lt;                        /html&gt;                        // index.art 文件                        {                            {                                extend &#39;./layout.art&#39;                            }                        } {                            {                                block &#39;head&#39;                            }                        } &lt; link rel = &quot;stylesheet&quot;                        href = &quot;custom.css&quot; &gt; {                            {                                /block}} {                                    {                                        block &#39;content&#39;                                    }                                } &lt; p &gt; This is just an awesome page. &lt; /p&gt; {{/block                            }                        }```### 模板配置1.  向模板中导入变量 template.defaults.imports.变量名 = 变量值;2.  设置模板根目录 template.defaults.root = 模板目录3.  设置模板默认后缀 template.defaults.extname = '.art'``` jsconst template = require('art-template');const path = require('path');const dateFormat = require('dateformat');// 设置模板的根目录template.defaults.root = path.join(__dirname, 'views');// 导入模板变量template.defaults.imports.dateFormat = dateFormat;// 配置模板的默认后缀template.defaults.extname = '.html';const html = template('06.art', {    time: new Date()});console.log(template('07', {}));console.log(html);```## 路由、静态资源模块### router路由模块1.  获取路由对象2.  调用路由对象提供的方法创建路由3.  启用路由，使路由生效``` jsconst getRouter = require('router')const router = getRouter();router.get('/add', (req, res) => {    res.end('Hello World!')})server.on('request', (req, res) => {    router(req, res)})```### serve-static静态资源访问实现静态资源访问服务1.  引入serve-static模块获取创建静态资源服务功能的方法2.  调用方法创建静态资源服务并指定静态资源服务目录3.  启用静态资源服务功能``` jsconst serveStatic = require('serve-static')const serve = serveStatic('public')server.on('request', () => {    serve(req, res)})server.listen(3000)```## 案例``` htmlstudents 学生信息管理项目model 模型connect.js 连接数据库user.js user 集合规则导出public 公共资源css css资源route 路由index.js 路由信息views 模板index.art 详情页list.art 列表页app.js 主文件```![学生档案管理](http://mdimg.95408.com/201912231233_615.png?null)### model/connect.js``` jsconst mongoose = require('mongoose');// 连接数据库mongoose.connect('mongodb://localhost/playground', {        useNewUrlParser: true    })    .then(() => console.log('数据库连接成功'))    .catch(() => console.log('数据库连接失败'))```### model/user.js``` jsconst mongoose = require('mongoose');// 创建学生集合规则const studentsSchema = new mongoose.Schema({    name: {        type: String,        required: true,        minlength: 2,        maxlength: 10    },    age: {        type: Number,        min: 10,        max: 25    },    sex: {        type: String    },    email: String,    hobbies: [String],    collage: String,    enterDate: {        type: Date,        default: Date.now    }});// 创建学生信息集合const Student = mongoose.model('Student', studentsSchema);// 将学生信息集合进行导出module.exports = Student;```### route/index.js``` jsconst mongoose = require('mongoose');// 创建学生集合规则const studentsSchema = new mongoose.Schema({    name: {        type: String,        required: true,        minlength: 2,        maxlength: 10    },    age: {        type: Number,        min: 10,        max: 25    },    sex: {        type: String    },    email: String,    hobbies: [String],    collage: String,    enterDate: {        type: Date,        default: Date.now    }});// 创建学生信息集合const Student = mongoose.model('Student', studentsSchema);// 将学生信息集合进行导出module.exports = Student;```### views/index.art``` jsconst mongoose = require('mongoose');// 创建学生集合规则const studentsSchema = new mongoose.Schema({    name: {        type: String,        required: true,        minlength: 2,        maxlength: 10    },    age: {        type: Number,        min: 10,        max: 25    },    sex: {        type: String    },    email: String,    hobbies: [String],    collage: String,    enterDate: {        type: Date,        default: Date.now    }});// 创建学生信息集合const Student = mongoose.model('Student', studentsSchema);// 将学生信息集合进行导出module.exports = Student;```### views/list.art``` js< !DOCTYPE html >    <    html lang = "en" >    <    head >    <    meta charset = "UTF-8" >    <    title > 学员信息 < /title> <    link rel = "stylesheet"href = "./css/list.css" >    <    /head> <    body >    <    table >    <    caption > 学员信息 < /caption> <    tr >    <    th > 姓名 < /th> <    th > 年龄 < /th> <    th > 性别 < /th> <    th > 邮箱地址 < /th> <    th > 爱好 < /th> <    th > 所属学院 < /th> <    th > 入学时间 < /th> <    /tr> {        {            each students        }    } <    tr >    <    th > {        {            $value.name        }    } < /th> <    th > {        {            $value.age        }    } < /th> <    th > {        {            $value.sex == '0' ? '男' : '女'        }    } < /th> <    th > {        {            $value.email        }    } < /th> <    th > {        {            each $value.hobbies        }    } <    span > {        {            $value        }    } < /span> {        {            /each}} &lt;            /th&gt; &lt;            th &gt; {                    {                        $value.collage                    }                } &lt; /th&gt; &lt;                th &gt; {                    {                        dateformat($value.enterDate, &#39;yyyy-mm-dd&#39;)                    }                } &lt; /th&gt; &lt;                /tr&gt; {                    {                        /each}}                        &lt;                        /table&gt; &lt;                        /body&gt; &lt;                        /html&gt;</code></pre><h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><pre><code class="js">// 引入http模块const http = require(&#39;http&#39;);// 引入模板引擎const template = require(&#39;art-template&#39;);// 引入path模块const path = require(&#39;path&#39;);// 引入静态资源访问模块const serveStatic = require(&#39;serve-static&#39;);// 引入处理日期的第三方模块const dateformat = require(&#39;dateformat&#39;);const router = require(&#39;./route/index&#39;);// 实现静态资源访问服务const serve = serveStatic(path.join(__dirname, &#39;public&#39;))// 配置模板的根目录template.defaults.root = path.join(__dirname, &#39;views&#39;);// 处理日期格式的方法template.defaults.imports.dateformat = dateformat;// 数据库连接require(&#39;./model/connect&#39;);// 创建网站服务器const app = http.createServer();// 当客户端访问服务器端的时候app.on(&#39;request&#39;, (req, res) =&gt; {    // 启用路由功能    router(req, res, () =&gt; {})    // 启用静态资源访问服务功能    serve(req, res, () =&gt; {})});// 端口监听app.listen(80);console.log(&#39;服务器启动成功&#39;);</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（4）Mongodb数据库</title>
      <link href="/2019/12/04/node/Node.js%EF%BC%884%EF%BC%89Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/12/04/node/Node.js%EF%BC%884%EF%BC%89Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>下载：</strong></p><blockquote><p>下载地址：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a></p></blockquote><p><strong>系统环境变量：</strong></p><blockquote><p>将MongoDB的路径 <code>C:\Program Files\MongoDB\Server\4.1\bin</code> 加入系统环境变量。</p></blockquote><p><strong>启动/停止：</strong></p><blockquote><p>启动： <code>net start mongodb</code> </p><p>停止： <code>net stop mongodb</code> </p><p>注意：以管理员身份运行命令提示行</p></blockquote><p><strong>导入数据：</strong></p><blockquote><p>mongoimport –d 数据库名称 –c 集合名称 –file 要导入的数据文件 (注意：是 - - file)</p><p>mongoimport - d playground - c users –file./ user.json</p></blockquote><p><strong>其他：</strong></p><blockquote><p>创建的数据库会自动加 <code>s</code> ；</p><p><code>const User = mongoose.model(&#39;User&#39;, userSchema);</code> 数据库中的集合名称实际为 <code>users</code> ；</p><p><a href="https://www.jianshu.com/p/775088bb8f92" target="_blank" rel="noopener">使用Mongoose查询数据库一直为空数组？</a></p></blockquote><h3 id="MongoDB-Compass-可视化"><a href="#MongoDB-Compass-可视化" class="headerlink" title="MongoDB Compass 可视化"></a>MongoDB Compass 可视化</h3><p><img src="http://mdimg.95408.com/201912202251_415.png" alt=""></p><h3 id="数据库、集合、文档、字段"><a href="#数据库、集合、文档、字段" class="headerlink" title="数据库、集合、文档、字段"></a>数据库、集合、文档、字段</h3><p>在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）。</p><table><thead><tr><th align="center"><strong>术语</strong></th><th align="center"><strong>解释说明</strong></th></tr></thead><tbody><tr><td align="center">database    数据库</td><td align="center">mongoDB数据库软件中可以建立多个数据库</td></tr><tr><td align="center">collection    集合</td><td align="center">一组数据的集合，可以理解为JavaScript中的数组</td></tr><tr><td align="center">document    文档</td><td align="center">一条具体的数据，可以理解为JavaScript中的对象</td></tr><tr><td align="center">field    字段</td><td align="center">文档中的属性名称，可以理解为JavaScript中的对象属性</td></tr></tbody></table><h2 id="Node-js与MongoDB"><a href="#Node-js与MongoDB" class="headerlink" title="Node.js与MongoDB"></a>Node.js与MongoDB</h2><p>使用Node.js操作MongoDB数据库。</p><h3 id="Mongoose模块"><a href="#Mongoose模块" class="headerlink" title="Mongoose模块"></a>Mongoose模块</h3><ul><li>使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose；</li><li>使用 <code>npm install mongoose</code> ；</li></ul><h3 id="Node-js连接MongoDB"><a href="#Node-js连接MongoDB" class="headerlink" title="Node.js连接MongoDB"></a>Node.js连接MongoDB</h3><ul><li>在MongoDB中<strong>不需要显式创建数据库</strong>，如果正在使用的数据库不存在，<strong>MongoDB</strong>会自动创建；</li></ul><pre><code class="js">// 1.jsconst mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// D:\doc\1220&gt;node 1.js// 数据库连接成功</code></pre><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><ul><li>一个集合就是一个数据库表单，如excel中的表单；</li><li>创建集合分为两步，一是对<strong>对集合设定规则</strong>，二是<strong>创建集合</strong>；</li></ul><pre><code class="js">const mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// 创建集合规则// 返回构造函数const courseSchema = new mongoose.Schema({    name: String,    author: String,    isPublished: Boolean});// 使用集合规则创建集合// 创建的集合名为：courses// 参1：集合名称； 参2：集合规则const Course = mongoose.model(&#39;Course&#39;, courseSchema);// 创建集合的文档const course = new Course({    name: &#39;Node.js&#39;,    author: &#39;JavaScript&#39;,    isPublished: true})// 保存，将创建的文档插入到数据库course.save();</code></pre><h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>创建文档实际就是向集合中插入数据。</p><ul><li>只创建了集合，数据库并没有自动创建；</li><li>只有创建了一个文档，并将文件插入到集合中，集合才会自动创建；</li></ul><p><img src="http://mdimg.95408.com/201912202254_525.png" alt="Compass查看数据"></p><p>上一个代码中展示了一种创建数据的方式，以下是另外一种：</p><pre><code class="js">// 创建集合const Course = mongoose.model(&#39;Course&#39;, courseSchema);// 向集合中插入数据Course.create({    &#39;name&#39;: &#39;Django&#39;,    &#39;author&#39;: &#39;Python&#39;,    &#39;isPublished&#39;: true}, (err, result) =&gt; {    console.log(err);    console.log(result);});</code></pre><p><img src="http://mdimg.95408.com/201912202255_890.png" alt=""></p><p>也支持异步函数的方式：</p><pre><code class="js">Course.create({        &#39;name&#39;: &#39;Django&#39;,        &#39;author&#39;: &#39;Python&#39;,        &#39;isPublished&#39;: true    })    .then(result =&gt; {        console.log(result);    })</code></pre><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><pre><code class="js">mongoimport - d playground - c users--file. / user.json</code></pre><p><img src="http://mdimg.95408.com/201912202255_2.png" alt="图片错误：应是users"></p><h3 id="mongoose验证"><a href="#mongoose验证" class="headerlink" title="mongoose验证"></a>mongoose验证</h3><p>在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败；</p><p>获取错误信息：error.errors[‘字段名称’].message</p><ul><li>required: true   必传字段</li><li>minlength：3   字符串最小长度</li><li>maxlength: 20   字符串最大长度</li><li>min: 2   数值最小为2</li><li>max: 100   数值最大为100</li><li>enum: [‘html’<strong>, ** ‘css’</strong>, ** ‘javascript’*<em>, *</em> ‘node.js’]</li><li>trim: true   去除字符串两边的空格</li><li>validate:   自定义验证器</li><li>default:   默认值</li></ul><pre><code class="js">const postSchema = new mongoose.Schema({    title: {        type: String,        // 必选字段        required: [true, &#39;请传入文章标题&#39;],        // 字符串的最小长度        minlength: [2, &#39;文章长度不能小于2&#39;],        // 字符串的最大长度        maxlength: [5, &#39;文章长度最大不能超过5&#39;],        // 去除字符串两边的空格        trim: true    },    age: {        type: Number,        // 数字的最小范围        min: 18,        // 数字的最大范围        max: 100    },    publishDate: {        type: Date,        // 默认值        default: Date.now    },    category: {        type: String,        // 枚举 列举出当前字段可以拥有的值        enum: {            values: [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;, &#39;node.js&#39;],            message: &#39;分类名称要在一定的范围内才可以&#39;        }    },    author: {        type: String,        validate: {            validator: v =&gt; {                // 返回布尔值                // true 验证成功                // false 验证失败                // v 要验证的值                return v &amp;&amp; v.length &gt; 4            },            // 自定义错误信息            message: &#39;传入的值不符合验证规则&#39;        }    }});const Post = mongoose.model(&#39;Post&#39;, postSchema);Post.create({        title: &#39;aa&#39;,        age: 60,        category: &#39;java&#39;,        author: &#39;bd&#39;    })    .then(result =&gt; console.log(result))    .catch(error =&gt; {        // 获取错误信息对象        const err = error.errors;        // 循环错误信息对象        for (var attr in err) {            // 将错误信息打印到控制台中            console.log(err[attr][&#39;message&#39;]);        }    })</code></pre><h3 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h3><p>通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。</p><ul><li>使用id对集合进行关联</li><li>使用populate方法进行关联集合查询</li></ul><pre><code class="js">// 用户集合const User = mongoose.model(&#39;User&#39;, new mongoose.Schema({    name: {        type: String    }}));// 文章集合const Post = mongoose.model(&#39;Post&#39;, new mongoose.Schema({    title: {        type: String    },    // 使用ID将文章集合和作者集合进行关联    author: {        type: mongoose.Schema.Types.ObjectId,        ref: &#39;User&#39;    }}));//联合查询Post.find()    .populate(&#39;author&#39;)    .then((err, result) =&gt; console.log(result));</code></pre><p>文章关联到作者：</p><pre><code class="js">// 引入mongoose第三方模块 用来操作数据库const mongoose = require(&#39;mongoose&#39;);// 数据库连接mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true    })    // 连接成功    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    // 连接失败    .catch(err =&gt; console.log(err, &#39;数据库连接失败&#39;));// 用户集合规则const userSchema = new mongoose.Schema({    name: {        type: String,        required: true    }});// 文章集合规则const postSchema = new mongoose.Schema({    title: {        type: String    },    author: {        type: mongoose.Schema.Types.ObjectId,        ref: &#39;User&#39;    }});// 用户集合const User = mongoose.model(&#39;User&#39;, userSchema);// 文章集合const Post = mongoose.model(&#39;Post&#39;, postSchema);// 创建用户// User.create({name: &#39;itheima&#39;}).then(result =&gt; console.log(result));// 创建文章// Post.create({titile: &#39;123&#39;, author: &#39;5c0caae2c4e4081c28439791&#39;}).then(result =&gt; console.log(result));Post.find().populate(&#39;author&#39;).then(result =&gt; console.log(result))</code></pre><h2 id="查-改-删"><a href="#查-改-删" class="headerlink" title="查/改/删"></a>查/改/删</h2><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>find()不管查询的数据多少，都返回文档（一个数组）；</p><pre><code class="js">//  根据条件查找文档（条件为空则查找所有文档）Course.find().then(result =&gt; console.log(result))// 返回文档集合[{    _id: 5 c0917ed37ec9b03c07cf95f,    name: &#39;张三&#39;,    email: &#39;zhangsan@qq.cn‘}, {    _id: 5 c09dea28acfb814980ff827,    name: &#39;Javascript&#39;,    email: &#39;zhangsan@qq.cn‘}]</code></pre><h4 id="findOne"><a href="#findOne" class="headerlink" title="findOne()"></a>findOne()</h4><p>findOne() 返回单一的对象；</p><pre><code class="js">//  根据条件查找文档Course.findOne({            name: 张三 &#39;}).then(result =&gt; console.log(result))            // 返回文档            {                _id: 5 c0917ed37ec9b03c07cf95f,                name: &#39;张三&#39;,                author: &#39;zhangsan@qq.cn‘            }</code></pre><h4 id="查询之前导入的数据"><a href="#查询之前导入的数据" class="headerlink" title="查询之前导入的数据"></a>查询之前导入的数据</h4><pre><code class="js">const mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// 创建集合规则const userSchema = new mongoose.Schema({    name: String,    age: Number,    email: String,    password: String,    hobbies: [String],});// 创建集合const User = mongoose.model(&#39;User&#39;, userSchema);// 查询所有User.find().then(result =&gt; console.log(result));</code></pre><h4 id="查询符号使用"><a href="#查询符号使用" class="headerlink" title="查询符号使用"></a>查询符号使用</h4><p><img src="http://mdimg.95408.com/201912202359_364.png" alt=""></p><pre><code class="js">// 年龄大于20 小于50User.find({    age: {        $gt: 20,        $lt: 50    }}).then(result =&gt; console.log(result));// 爱好在敲代码中的数据User.find({    hobbies: {        $in: [&#39;敲代码&#39;]    }}).then(result =&gt; console.log(result));// 只查找name email字段的数据 加-表示不显示的字段，_id字段默认显示User.find().select(&#39;name email -_id&#39;).then(result =&gt; console.log(result));// 按年龄字段进行排序 加-为降序User.find().sort(&#39;age&#39;).then((result) =&gt; {    console.log(result)});// skip 跳过2条，limit 限制显示2条User.find().skip(2).limit(2).then(result =&gt; {    console.log(result)});</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><h4 id="findOneAndDelete"><a href="#findOneAndDelete" class="headerlink" title="findOneAndDelete"></a>findOneAndDelete</h4><ul><li>查找一条文档并删除；</li><li>返回删除的文档</li><li>如果查到了多个文档，删除第一条</li></ul><pre><code class="js">// 删除单个User.findOneAndDelete({        _id: &#39;5c09f267aeb04b22f8460968&#39;    })    .then(result =&gt; console.log(result));// 删除了指定_id的‘王五’的数据</code></pre><h4 id="deleteMany"><a href="#deleteMany" class="headerlink" title="deleteMany"></a>deleteMany</h4><ul><li>为空时，删除所有！！！很危险！！！</li><li>返回删除数据条数</li></ul><pre><code class="js">// 删除多个User.deleteMany({}).then(result =&gt; console.log(result))</code></pre><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="updateOne"><a href="#updateOne" class="headerlink" title="updateOne"></a>updateOne</h4><pre><code class="js">// 更新单个User.updateOne({    查询条件}, {    要修改的值}).then(result =&gt; console.log(result))// 将李四这个文档的年龄改成8User.updateOne({        &#39;name&#39;: &#39;李四&#39;    }, {        &#39;age&#39;: 8    })    .then(result =&gt; console.log(result));</code></pre><h4 id="updateMany"><a href="#updateMany" class="headerlink" title="updateMany"></a>updateMany</h4><ul><li>查询条件为空，更改全部文档数据！！！危险！！！</li></ul><pre><code class="js">// 更新多个User.updateMany({    查询条件}, {    要更改的值}).then(result =&gt; console.log(result))// 将所有数据的年龄改成8User.updateMany({}, {        &#39;age&#39;: 8    })    .then(result =&gt; console.log(result));</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（3）web服务器、http、async异步编程</title>
      <link href="/2019/12/03/node/Node.js%EF%BC%883%EF%BC%89web%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81http%E3%80%81async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/03/node/Node.js%EF%BC%883%EF%BC%89web%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81http%E3%80%81async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP协议"><a href="#1-HTTP协议" class="headerlink" title="1. HTTP协议"></a>1. HTTP协议</h2><h3 id="1-1-web-服务器模块-http"><a href="#1-1-web-服务器模块-http" class="headerlink" title="1.1 web 服务器模块 http"></a>1.1 web 服务器模块 http</h3><ul><li>创建一个服务器对象app，绑定一个端口号：3000；</li><li>通过后台运行 <code>node app.js</code> ，就创建了一个web服务器；</li><li>浏览器请求这个服务器的地址： <code>localhost:3000</code> 时，服务器就响应一段数据（ <code>res.end</code> ）给浏览器；</li></ul><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // 当浏览器请求时，服务器响应内容给浏览器    res.end(&#39;当你在浏览器输入网址请求本web服务器，就会响应这一些文字&#39;);})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><p>Chrome–F12–Network–Headers：请求和响应报文：</p><p><strong>Request 请求报文</strong></p><ul><li>浏览器客户端告诉服务器端的事件；</li><li>能接收的格式，语言；</li></ul><p><strong>Response 响应报文</strong></p><ul><li>服务器端对浏览器客户端响应的事情；</li><li>服务器端响应给客户端具体的数据：html文件</li></ul><h3 id="1-2-请求报文"><a href="#1-2-请求报文" class="headerlink" title="1.2 请求报文"></a>1.2 请求报文</h3><p>请求方式：</p><ul><li>GET 请求数据</li><li>POST 发送数据</li></ul><h3 id="1-3-req-method"><a href="#1-3-req-method" class="headerlink" title="1.3 req.method"></a>1.3 req.method</h3><p>req.method 获取请求的方式</p><p>浏览器端通过post或get向服务器端发送数据：</p><pre><code class="html">// 表单数据通过post请求发送给localhost:3000服务器&lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;    &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;/form&gt;</code></pre><p>服务器端接收来自浏览器客户端的数据，并响应了一段文字 <code>res.end</code> ：</p><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // req.method 获取请求的方式    console.log(req.method)    if (req.method == &#39;POST&#39;) {        res.end(&#39;来自浏览器的请求方式为POST&#39;);    } else if (req.method == &#39;GET&#39;) {        res.end(&#39;来自浏览器的请求方式为GET&#39;);    }})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h3 id="1-4-req-url"><a href="#1-4-req-url" class="headerlink" title="1.4 req.url"></a>1.4 req.url</h3><p>req.url 客户端请求的url地址</p><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // req.url 客户端面请求的url地址    if (req.url == &#39;/index&#39; || req.url == &#39;/&#39;) {        res.end(&#39;welcome to index page&#39;);    } else if (req.url == &#39;/list&#39;) {        res.end(&#39;welcom to list page&#39;);    } else {        res.end(&#39;404 not found page&#39;);    }})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h3 id="1-5-req-headers"><a href="#1-5-req-headers" class="headerlink" title="1.5 req.headers"></a>1.5 req.headers</h3><p>客户端请求的报文信息</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求报文信息中accept中的值    console.log(req.headers[&#39;accept&#39;]);})</code></pre><h3 id="1-6-响应报文"><a href="#1-6-响应报文" class="headerlink" title="1.6 响应报文"></a>1.6 响应报文</h3><h3 id="1-7-HTTP-响应状态码"><a href="#1-7-HTTP-响应状态码" class="headerlink" title="1.7 HTTP 响应状态码"></a>1.7 HTTP 响应状态码</h3><ul><li>200</li><li>404</li><li>500</li><li>400</li></ul><h3 id="1-8-res-writeHead"><a href="#1-8-res-writeHead" class="headerlink" title="1.8 res.writeHead"></a>1.8 res.writeHead</h3><p>书写服务器端给客户端响应的数据</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    res.writeHead(400);})</code></pre><p><img src="http://mdimg.95408.com/web_1576778412.jpg" alt="设置状态码为 400 时"></p><p>设置状态码、文本格式及编码：</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    // 设置状态码200和html格式及编码utf8    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    });    // req.url 客户端面请求的url地址    if (req.url == &#39;/index&#39; || req.url == &#39;/&#39;) {        res.end(&#39;欢迎来到index首页！&#39;);    } else {        res.end(&#39;404&#39;)    }})</code></pre><h2 id="2-HTTP请求和响应"><a href="#2-HTTP请求和响应" class="headerlink" title="2. HTTP请求和响应"></a>2. HTTP请求和响应</h2><h3 id="2-1-请求参数"><a href="#2-1-请求参数" class="headerlink" title="2.1 请求参数"></a>2.1 请求参数</h3><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p><h3 id="2-2-GET请求参数"><a href="#2-2-GET请求参数" class="headerlink" title="2.2 GET请求参数"></a>2.2 GET请求参数</h3><ul><li>参数被放置在浏览器地址栏中，例如：<a href="http://localhost:3000/?name=zhangsan&amp;age=20" target="_blank" rel="noopener">http://localhost:3000/?name=zhangsan&amp;age=20</a></li><li>参数获取需要借助系统模块url<ul><li>之前我们直接使用了 <code>req.url</code> 获得了所有的请求参数，如 <code>/index?name=zhangsan&amp;qq=123456</code> ；</li><li>如果要得到更方便的对象形式的 <code>get参数</code> ，可以使用 <code>url.parse(req.url, true).query;</code> ，将get地址解析成对象形式，如 <code>{ name: &#39;zhangsan&#39;, qq: &#39;123456&#39; }</code> ；</li></ul></li></ul><h4 id="2-2-1-url-parse-query"><a href="#2-2-1-url-parse-query" class="headerlink" title="2.2.1 url.parse( ).query"></a>2.2.1 url.parse( ).query</h4><pre><code class="js">// 引入系统模块urlconst url = require(&#39;url&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求参数    console.log(req.url); // /index?name=zhangsan&amp;qq=123455    // 将请求参数交给url模块进行处理    // parse(参1：要解析的url地址， 参2：将参数解析成对象形式)    let params = url.parse(req.url, true).query;    console.log(params); // { name: &#39;zhangsan&#39;, qq: &#39;123455&#39; }    console.log(params.name); // params.name获取：zhangsan    console.log(params.qq); // params.qq获取：123455})</code></pre><h4 id="2-2-2-url-parse-pathname"><a href="#2-2-2-url-parse-pathname" class="headerlink" title="2.2.2 url.parse( ).pathname"></a>2.2.2 url.parse( ).pathname</h4><p><code>url.parse().pathname</code> 包含的是url地址的 <code>/index</code> 部分，前面通过url的路由没有提取get参数；</p><pre><code class="js">    let query = url.parse(req.url, true).query;    // query:  { name: &#39;zhangsan&#39;, qq: &#39;123455&#39; }    let pathname = url.parse(req.url, true).pathname;    // pathname:  /index    // 等同于：    let {        query,        pathname    } = url.parse(req.url, true);</code></pre><h4 id="2-2-3-get请求响应页面"><a href="#2-2-3-get请求响应页面" class="headerlink" title="2.2.3 get请求响应页面"></a>2.2.3 get请求响应页面</h4><p>通过get请求地址响应不同页面</p><p>修改去除url中的get参数（原来：if (req.url == ‘/index’)，如果url中有参数就无法识别）</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    let {        query,        pathname    } = url.parse(req.url, true);    // 设置状态码200和html格式及编码utf8    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    });    // req.url 客户端面请求的url地址    // 原来：if (req.url == &#39;/index&#39;)，如果url中有参数就无法识别    if (pathname == &#39;/index&#39; || pathname == &#39;/&#39;) {        res.end(&#39;欢迎来到index首页！&#39;);    } else if (pathname == &#39;/list&#39;) {        res.end(&#39;欢迎来到list页面&#39;)    } else {        res.end(&#39;404&#39;)    }})</code></pre><p><img src="http://mdimg.95408.com/201912201246_963.png" alt="url中带get参数"></p><h3 id="2-3-POST请求参数"><a href="#2-3-POST请求参数" class="headerlink" title="2.3 POST请求参数"></a>2.3 POST请求参数</h3><ul><li>参数被放置在请求体中进行传输</li><li>获取POST参数需要使用data事件和end事件</li><li>使用querystring</li></ul><h4 id="2-3-1-form-html"><a href="#2-3-1-form-html" class="headerlink" title="2.3.1 form.html"></a>2.3.1 form.html</h4><p><code>form.html</code> ： html表单通过post参数向服务器传递数据：</p><pre><code class="html">&lt;body&gt;    &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;usename&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><h4 id="2-3-2-提交表单"><a href="#2-3-2-提交表单" class="headerlink" title="2.3.2 提交表单"></a>2.3.2 提交表单</h4><p>使用表单提交数据：</p><p><img src="http://mdimg.95408.com/201912201313_858.png" alt=""></p><h4 id="2-3-3-app-js"><a href="#2-3-3-app-js" class="headerlink" title="2.3.3 app.js"></a>2.3.3 app.js</h4><p><code>app.js</code> ：服务器开启 <code>nodemon app.js</code> 后，接收来自form.html传递的post数据：</p><blockquote><p><code>console.log(postParams);</code> // usename=zhangsan&amp;password=123456；</p><p><code>console.log(querystring.parse(postParams));</code> // { usename: ‘zhangsan’, password: ‘123456’ }；</p></blockquote><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 处理请求参数模块 post参数字符串转为对象const querystring = require(&#39;querystring&#39;)// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // post请求    // 请求参数传输有一定的时间    // post参数是通过事件的方式接收的    // 请求参数传递时触发data事件    // 请求参数传输完成时触发end事件    let postParams = &#39;&#39;;    req.on(&#39;data&#39;, params =&gt; {        postParams += params;    })    req.on(&#39;end&#39;, () =&gt; {        // postParams 为post请求数据的字符串格式        console.log(postParams); // usename=zhangsan&amp;password=123456        // querystring.parse(postParams)         // 通过处理后得到了对象形式的post请求数据        console.log(querystring.parse(postParams));        // { usename: &#39;zhangsan&#39;, password: &#39;123456&#39; }    })})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h2 id="3-路由"><a href="#3-路由" class="headerlink" title="3. 路由"></a>3. 路由</h2><p>之前，我们在浏览器输入 <code>localhost:3000/index</code> ，需要响应到 <code>index</code> 页面上的内容；</p><p>输入 <code>localhost:3000/list</code> ，需要响应到 <code>list</code> 上的数据；</p><blockquote><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p></blockquote><p><img src="http://mdimg.95408.com/201912201325_932.png" alt="路由"></p><p>之前的代码：</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    let {        query,        pathname    } = url.parse(req.url, true);    if (pathname == &#39;/index&#39; || pathname == &#39;/&#39;) {        res.end(&#39;index页面数据&#39;);    } else if (pathname == &#39;/list&#39;) {        res.end(&#39;list页面数据&#39;)    } else {        res.end(&#39;404&#39;)    }})</code></pre><p>以上是简单的路由代码，但没有体现客户端的get、post请求判断；</p><h4 id="3-1-判断为get请求的路由"><a href="#3-1-判断为get请求的路由" class="headerlink" title="3.1 判断为get请求的路由"></a>3.1 判断为get请求的路由</h4><pre><code class="js">const http = require(&#39;http&#39;);const url = require(&#39;url&#39;);const app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求方式,转小写    const method = req.method.toLowerCase();    // 获取请求地址    const pathname = url.parse(req.url).pathname;    // 响应头设置编码    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    })    // 判断请求方式是post还是get    if (method == &#39;get&#39;) {        // 判断请求url来响应数据        if (pathname == &#39;/&#39; || pathname == &#39;/index&#39;) {            res.end(&#39;欢迎来到首页&#39;);        } else if (pathname == &#39;/list&#39;) {            res.end(&#39;欢迎来到列表页&#39;);        } else {            res.end(&#39;没有找到你要的页面&#39;)        }    } else if (method == &#39;post&#39;) {        // 请求方式为post时的内容        // 与get判断基本相同    }})app.listen(3000);console.log(&#39;服务器启动成功&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912201346_522.png" alt=""></p><h2 id="4-静态资源"><a href="#4-静态资源" class="headerlink" title="4. 静态资源"></a>4. 静态资源</h2><p>将客户端浏览器请求的路径，转换为服务器实现静态文件路径：</p><pre><code class="js">const http = require(&#39;http&#39;);const url = require(&#39;url&#39;);const path = require(&#39;path&#39;);const app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    // 响应原始url路径    // res.end(req.url);    // 获取请求地址    const pathname = url.parse(req.url).pathname;    // 响应pathname路径    // res.end(pathname);  // /index    const dirpath = path.join(__dirname, &#39;public&#39; + pathname);    // 响应path拼接的绝对路径    res.end(dirpath); // D:\doc\1218\route\public\index})app.listen(3000);console.log(&#39;服务器启动成功&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912201407_769.png" alt=""></p><p>我们通过拼接得到了文件的绝对路径 <code>d:\doc\1218\route\public\index</code> ，可以通过 <code>fs</code> 模块读取，响应给客户端：</p><h3 id="4-1-读取静态-html文件"><a href="#4-1-读取静态-html文件" class="headerlink" title="4.1 读取静态.html文件"></a>4.1 读取静态.html文件</h3><ul><li>客户端发送请求 <code>localhost:3000/index</code> ，得到请求路径 <code>/index</code> ；</li><li>服务器端 <code>path.join()</code> 拼接出服务器本地绝对地址 <code>d:\doc\1218\route\public\index</code> ；</li><li>在绝对地址下有对应的 <code>index.html</code> 文件时，通过 <code>fs.readFile</code> 读取后响应给客户端；</li><li>浏览器就打开了这个 <code>index.html</code> 的首页文件；</li></ul><pre><code class="js">const fs = require(&#39;fs&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    let pathname = url.parse(req.url).pathname;    let realpath = path.join(__dirname, &#39;public&#39; + pathname);    // res.end(realpath);   // d:\doc\1218\route\public\index    fs.readFile(realpath, (err, result) =&gt; {        // 读取失败响应文字        if (err != null) {            res.end(&#39;文件读取失败&#39;);            return;        }        // 读取成功后，将读取到的index.html文件响应给客户端        res.end(result);    })})</code></pre><p><img src="http://mdimg.95408.com/201912201435_163.png" alt=""></p><h3 id="4-2-请求根目录至首页文件"><a href="#4-2-请求根目录至首页文件" class="headerlink" title="4.2 请求根目录至首页文件"></a>4.2 请求根目录至首页文件</h3><p>当客户请求根目录 <code>localhost:3000</code> 时，跳转到 <code>localhost:3000/index</code> ：</p><pre><code class="js">pathname = pathname == &#39;/&#39; ? &#39;/index&#39; : pathname;</code></pre><h3 id="4-3-指定返回资源的类型-mime"><a href="#4-3-指定返回资源的类型-mime" class="headerlink" title="4.3 指定返回资源的类型 mime"></a>4.3 指定返回资源的类型 mime</h3><pre><code class="js">const mime = require(&#39;mime&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    let pathname = url.parse(req.url).pathname;    pathname = pathname == &#39;/&#39; ? &#39;/index&#39; : pathname;    let realpath = path.join(__dirname, &#39;public&#39;, pathname);    let type = mime.getType(realpath);    fs.readFile(realpath, (err, result) =&gt; {        if (err != null) {            res.end(&#39;文件读取失败&#39;);            return;        }        // 指定资源返回的类型        res.writeHead(200, {            &#39;content-type&#39;: type;        })        res.end(result);    })})</code></pre><p><img src="http://mdimg.95408.com/201912201449_374.png" alt=""></p><h2 id="5-异步API"><a href="#5-异步API" class="headerlink" title="5. 异步API"></a>5. 异步API</h2><h3 id="5-1-同步API-和-异步API"><a href="#5-1-同步API-和-异步API" class="headerlink" title="5.1 同步API 和 异步API"></a>5.1 同步API 和 异步API</h3><p>同步API：只有当前API执行完成后，才能继续执行下一个API；</p><pre><code class="js">console.log(&#39;1&#39;);console.log(&#39;2&#39;);console.log(&#39;3&#39;);</code></pre><p>异步API：当前API的执行不会阻塞后续代码的执行；</p><pre><code class="js">console.log(&#39;1&#39;);setTimeout(    () =&gt; {        console.log(&#39;3&#39;);    }, 2000);console.log(&#39;2&#39;);</code></pre><p>同步API可以<strong>从返回值中拿到API执行的结果</strong>, 但是异步API是不可以的；</p><p>异步API是通过回调函数来完成的。</p><pre><code class="js">// 同步function sum(n1, n2) {    return n1 + n2;}const result = sum(10, 20); // 30// 异步function getMsg() {    setTimeout(function() {        return {            msg: &#39;Hello Node.js&#39;        }    }, 2000);    // 异步不会等待，直接会在此执行 return undefined    // 2秒后才后返回msg，但此时值早已拿到，并输出了}const msg = getMsg(); // undefined</code></pre><p>同步API和异步API的执行顺序不同：</p><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行；</p><pre><code class="js">// 同步：for (var i = 0; i &lt; 100000; i++) {    console.log(i);}console.log(&#39;for循环后面的代码&#39;);// 先执行10万次，再输出最后一句话// 异步：console.log(&#39;代码开始执行&#39;);setTimeout(() =&gt; {    console.log(&#39;2秒后执行的代码&#39;)}, 2000);setTimeout(() =&gt; {    console.log(&#39;0秒后执行的代码&#39;)}, 0);console.log(&#39;代码结束执行&#39;);// 输出顺序：// 代码开始执行// 代码结束执行// 0秒后执行的代码// 2秒后执行的代码</code></pre><h3 id="5-2-Node-js-异步API-回调函数"><a href="#5-2-Node-js-异步API-回调函数" class="headerlink" title="5.2 Node.js 异步API (回调函数)"></a>5.2 Node.js 异步API (回调函数)</h3><p>我们之前读取文件、服务器请求等都是通过回调函数来实现的；</p><p>要得到读取完成后文件的数据，在回调函数中获取；</p><pre><code class="js">fs.readFile(&#39;./demo.txt&#39;, (err, result) =&gt; {    res.end(result);});var app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    res.end(req.url);});</code></pre><p><strong>回调地狱</strong></p><p>如果有多层回调函数，需要一层一层的嵌套，影响代码维护；</p><h3 id="5-3-Promise"><a href="#5-3-Promise" class="headerlink" title="5.3 Promise"></a>5.3 Promise</h3><p>Promise解决Node.js异步编程中回调地狱的问题；</p><pre><code class="js">const fs = require(&#39;fs&#39;);function p1() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./1.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}function p2() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./2.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}function p3() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./3.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}p1().then((r1) =&gt; {    console.log(r1);    return p2();}).then((result2) =&gt; {    console.log(result2);    return p3();}).then((result3) =&gt; {    console.log(result3);})</code></pre><p><img src="http://mdimg.95408.com/201912201630_672.png" alt=""></p><h2 id="6-异步函数-async"><a href="#6-异步函数-async" class="headerlink" title="6. 异步函数 async"></a>6. 异步函数 async</h2><pre><code class="js">const fn = async () =&gt; {};async function fn() {}</code></pre><p>让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p><pre><code class="js">async function fn() {    throw &#39;错误信息txt&#39;;    return 123;}// console.log(fn());   // Promise { 123 }fn().then(function(data) {    console.log(data); // 123      // return替代了resolve 用then获取}).catch(function(err) {    console.log(err); // 错误信息txt      // throw替代了reject 用catch获取})</code></pre><h3 id="6-1-async-关键字"><a href="#6-1-async-关键字" class="headerlink" title="6.1 async 关键字"></a>6.1 async 关键字</h3><ol><li>普通函数定义前加async关键字 普通函数变成异步函数</li><li>异步函数默认返回promise对象</li><li>在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法</li><li>在异步函数内部使用throw关键字抛出程序异常</li><li>调用异步函数再链式调用then方法获取异步函数执行结果</li><li>调用异步函数再链式调用catch方法获取异步函数执行的错误信息</li></ol><h3 id="6-2-await-关键字"><a href="#6-2-await-关键字" class="headerlink" title="6.2 await 关键字"></a>6.2 await 关键字</h3><ol><li>await关键字只能出现在异步函数中</li><li>await promise await后面只能写promise对象 写其他类型的API是不不可以的</li><li>await关键字可是暂停异步函数向下执行 直到promise返回结果</li></ol><pre><code class="js">async function p1() {    return &#39;1.txx&#39;;}async function p2() {    return &#39;2.txt&#39;;}async function p3() {    return &#39;3.txt&#39;;}async function run() {    let r1 = await p1(); // 直接调用p1的return的结果    let r2 = await p2();    let r3 = await p3();    console.log(r1);    console.log(r2);    console.log(r3);}run();// D:\doc\1219&gt;node 2.js// 1.txx// 2.txt// 3.txt</code></pre><h3 id="6-3-顺序读取3个文件"><a href="#6-3-顺序读取3个文件" class="headerlink" title="6.3 顺序读取3个文件"></a>6.3 顺序读取3个文件</h3><ul><li>使用async异步函数的方法按顺序读取3个文件：</li><li>const readFile = promisify(fs.readFile)   // 调用promisify方法改造了现有的异步API，让其返回promise对象；</li><li>从而支持异步函数语法；</li></ul><pre><code class="js">const fs = require(&#39;fs&#39;);// 改造现有的异步函数api，让其返回promise对象，从而支持异步函数语法const promisify = require(&#39;util&#39;).promisify;// 调用promisify方法改造了现有的异步API，让其返回promise对象const readFile = promisify(fs.readFile);async function run() {    let r1 = await readFile(&#39;./1.txt&#39;, &#39;utf8&#39;);    // 通过promisify处理的新reafFile方法，不用写回调函数，直接使用await    let r2 = await readFile(&#39;./2.txt&#39;, &#39;utf8&#39;);    let r3 = await readFile(&#39;./3.txt&#39;, &#39;utf8&#39;);    console.log(r1);    console.log(r2);    console.log(r3);}run();// D: \doc\1219 &gt; node 2.js// 1.txt内容// 2.txt内容// 3.txt内容</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（2）fs、path、gulp模块</title>
      <link href="/2019/12/02/node/Node.js%EF%BC%882%EF%BC%89fs%E3%80%81path%E3%80%81gulp%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/02/node/Node.js%EF%BC%882%EF%BC%89fs%E3%80%81path%E3%80%81gulp%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="fs-文件操作"><a href="#fs-文件操作" class="headerlink" title="fs 文件操作"></a>fs 文件操作</h2><pre><code class="js">const fs = require(&#39;fs&#39;);</code></pre><h3 id="fs-readFile-读取文件"><a href="#fs-readFile-读取文件" class="headerlink" title="fs.readFile 读取文件"></a>fs.readFile 读取文件</h3><pre><code class="js">fs.readFile(&#39;文件路径&#39;，    &#39;文件编码可选&#39;，    callback回调函数)；</code></pre><blockquote><p>callback回调函数的第一个值是错误信息，node.js中都是错误优先的回调函数；</p></blockquote><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的readFile读取文件内容fs.readFile(&#39;./a.txt&#39;, &#39;utf8&#39;, (err, doc) =&gt; {    // 如果读取错误，err包含错误信息    // 反之，err为空    // doc是读取的文件    console.log(err); // 读取正确，err返回null    console.log(doc);})</code></pre><h3 id="fs-writeFile-写入文件"><a href="#fs-writeFile-写入文件" class="headerlink" title="fs.writeFile 写入文件"></a>fs.writeFile 写入文件</h3><pre><code class="js">fs.writeFile(&#39;文件路径’， ‘数据’， callback回调函数)；</code></pre><p>如果错误，err返回错误信息；反之，err为null</p><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的writeFile写入内容fs.writeFile(&#39;./b.txt&#39;, &#39;要写入b.txt的数据&#39;, err =&gt; {    // 如果错误，err返回错误信息    // 反之，err为null    // 如果err不为空，打印err信息，return    if (err != null) {        console.log(err);        return;    }    // 如果err这空，则证明写入正确    console.log(&#39;数据写入b.txt成功&#39;);})</code></pre><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>进行路径拼接：win\os\lunix的路径符不同，使用路径拼接更安全；</p><p>node中的相对路径，是相对于node系统命令工具所在的目录</p><pre><code class="js">// 调用path模块const path = require(&#39;path&#39;);// 使用path模块进行路径拼接const p = path.join(&#39;public&#39;, &#39;halfbamoo&#39;, &#39;src&#39;);console.log(p); // public\halfbamoo\src</code></pre><p><code>__dirname</code> 为系统绝对路径；</p><pre><code class="js">const pp = path.join(__dirname, &#39;public&#39;, &#39;halfbamboo&#39;, &#39;src&#39;);console.log(pp); // D:\doc\1218\public\halfbamboo\src</code></pre><h2 id="gulp-模块"><a href="#gulp-模块" class="headerlink" title="gulp 模块"></a>gulp 模块</h2><p>基于node.js 平台的前端构建工具</p><ul><li>html、css、js文件压缩；</li><li>es6、less语法转换；</li><li>公共文件的抽离；</li><li>修改文件浏览器自动刷新；</li></ul><h3 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h3><p>安装： <code>npm install gulp</code> ，本地安装即可；</p><p>安装： <code>npm install gulp-cli -g</code> ，全局安装gulp命令行工具；</p><p>创建： <code>gulpfile.js</code> 文件写代码；</p><h3 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h3><ul><li>gulp.src()：获取任务要处理的文件</li><li>gulp.dest()：输出文件</li><li>gulp.task()：建立gulp任务</li><li>gulp.watch()：监控文件的变化</li></ul><p>使用gulp将src/css目录下的文件，复制到dist/css目录下：</p><blockquote><p>建立一个固定名称的文件： <code>gulpfile.js</code> ，敲如下代码，</p><p>此时，会将原/src/css中的文件，复制到/dist/css目录下，如果目标目录存在，会自动创建；</p></blockquote><pre><code class="js">gulpfile.js:    // 调用gulp模块    const gulp = require(&#39;gulp&#39;);// 使用gulp.task（任务名称，回调函数）建立任务gulp.task(&#39;first&#39;, () =&gt; {    console.log(&#39;第一个gulp任务&#39;);    // src 获取要处理的文件    gulp.src(&#39;./src/css/a.css&#39;)        // dest 输出文件地址 要放在pipei当中        .pipe(gulp.dest(&#39;./dist/css&#39;));})</code></pre><h3 id="gulp插件-第三方模块"><a href="#gulp插件-第三方模块" class="headerlink" title="gulp插件/第三方模块"></a>gulp插件/第三方模块</h3><ul><li>gulp-htmlmin ：html文件压缩</li><li>gulp-csso ：压缩css</li><li>gulp-babel ：JavaScript语法转化</li><li>gulp-less: less语法转化</li><li>gulp-uglify ：压缩混淆JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><p>安装：</p><pre><code class="js">npm install gulp - htmlminnpm install gulp - file - includenpm install gulp - lessnpm install gulp - cssonpm install gulp - babel @babel / core @babel / preset - env// https://www.npmjs.com/package/gulp-babelnpm install gulp - uglify</code></pre><ul><li>gulp-file-include：源代码中公共样式抽离出来后，使用 <code>@@include(&#39;./common/header.html&#39;)</code> 引入时，使用 gulp-file-include 模块，可以将引入的内容重新生成到一个完整的html页面当中；</li></ul><h3 id="gulpfile-js-创建任务"><a href="#gulpfile-js-创建任务" class="headerlink" title="gulpfile.js 创建任务"></a>gulpfile.js 创建任务</h3><p>压缩html、css、js，处理es6、less语法……</p><p>项目根目录下建立 <code>gulpfile.js</code> 文件；</p><p>源文件：src目录；处理后的文件：dict目录；</p><p>通过以下代码：我们可以：</p><ul><li>将所有html \ css \ js 压缩；</li><li>将 less 语法、es6 语法处理</li><li>将src目录下的所有文件 <strong>经过处理后</strong> 复制到 dist 文件夹</li></ul><pre><code class="js">// 调用gulp模块const gulp = require(&#39;gulp&#39;);// 调用处理htmlconst htmlmin = require(&#39;gulp-htmlmin&#39;);const fileinclude = require(&#39;gulp-file-include&#39;);// 调用处理css lessconst less = require(&#39;gulp-less&#39;);const csso = require(&#39;gulp-csso&#39;);// 调用处理jsconst babel = require(&#39;gulp-babel&#39;);const uglify = require(&#39;gulp-uglify&#39;);// 压缩html任务// 1 压缩html 2 抽取html公共代码gulp.task(&#39;htmlmin&#39;, () =&gt; {    gulp.src(&#39;./src/*.html&#39;)        .pipe(fileinclude())        // 压缩html代码        .pipe(htmlmin({            collapseWhitespace: true        }))        .pipe(gulp.dest(&#39;dist&#39;));})// 压缩css 及处理 lessgulp.task(&#39;cssmin&#39;, () =&gt; {    gulp.src([&#39;./src/css/*.css&#39;, &#39;./src/css/*.less&#39;])        // 处理less        .pipe(less())        // 压缩css        .pipe(csso())        .pipe(gulp.dest(&#39;dist/css&#39;));})// 处理es6 及压缩jsgulp.task(&#39;jsmin&#39;, () =&gt; {    gulp.src(&#39;./src/js/*.js&#39;)        // 处理es6语法        .pipe(babel({            // 识别当前运行环境，将代码按当前环境转换            presets: [&#39;@babel/env&#39;]        }))        // 压缩js代码        .pipe(uglify())        .pipe(gulp.dest(&#39;dist/js&#39;));})// 复制其他不需要处理的夹 img / libgulp.task(&#39;copy&#39;, () =&gt; {    gulp.src(&#39;./src/images/*&#39;)        .pipe(gulp.dest(&#39;dist/images&#39;));    gulp.src(&#39;./src/lib/**/*&#39;)        .pipe(gulp.dest(&#39;dist/lib&#39;));})// 构建任务// gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]);gulp.task(&#39;default&#39;, gulp.parallel(&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;, function() {    console.log(&#39;任务完成&#39;);}));// 任务命令：// gulp default 或者 gulp</code></pre><h3 id="gulp3-和-gulp4的区别"><a href="#gulp3-和-gulp4的区别" class="headerlink" title="gulp3 和 gulp4的区别"></a>gulp3 和 gulp4的区别</h3><blockquote><p>操作时报错：gulp Task function must be specified。</p><p>gulp 版本的原因！</p></blockquote><p>在Gulp 4中需要使用 <code>gulp.series</code> 和 <code>gulp.parallel</code> ，因为gulp任务现在只有两个参数。</p><blockquote><p><code>gulp.series</code> ：按照顺序执行<br><code>gulp.paralle</code> ：可以并行计算</p></blockquote><pre><code class="js">gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, function() {    // Do something after a, b, and c are finished.}));gulp.task(&#39;build&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;, function() {    // Build the website.}));gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;), &#39;b&#39;, &#39;c&#39;, function() {    // Do something after a, b, and c are finished.}));</code></pre><h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><h3 id="当模块拥有路径但没有后缀时"><a href="#当模块拥有路径但没有后缀时" class="headerlink" title="当模块拥有路径但没有后缀时"></a>当模块拥有路径但没有后缀时</h3><pre><code class="js">require(&#39;./find.js&#39;);require(&#39;./find&#39;);</code></pre><ol><li>require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</li><li>如果模块后缀省略，<strong>先找同名JS文件再找同名JS文件夹</strong></li><li>如果找到了同名文件夹，找文件夹中的index.js</li><li>如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件</li><li>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li></ol><h3 id="当模块没有路径且没有后缀时"><a href="#当模块没有路径且没有后缀时" class="headerlink" title="当模块没有路径且没有后缀时"></a>当模块没有路径且没有后缀时</h3><pre><code class="js">require(&#39;find&#39;);</code></pre><ol><li>Node.js会假设它是<strong>系统模块</strong></li><li>Node.js会去node_modules文件夹中</li><li>首先看是否有该名字的JS文件</li><li>再看是否有该名字的文件夹</li><li>如果是文件夹看里面是否有index.js</li><li>如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件</li><li>否则找不到报错</li></ol><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（1）基础</title>
      <link href="/2019/12/01/node/Node.js%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/01/node/Node.js%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912182243_175.png" alt="Node.js"></p><h2 id="常用信息"><a href="#常用信息" class="headerlink" title="常用信息"></a>常用信息</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a></p><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm 官网</a></p><p>win系统中，需要将node.js放入系统环境变量；</p><p>如果不能安装成功，需要以管理员身份运行命令行工具；</p><p>查看 Node.js 版本： <code>node -v</code> ；</p><p>nodejs已经集成了 <code>npm</code> ，查看 npm 版本： <code>npm -v</code> ；</p><h2 id="Node-js-与JavaScript"><a href="#Node-js-与JavaScript" class="headerlink" title="Node.js 与JavaScript"></a>Node.js 与JavaScript</h2><ul><li><strong>Node</strong> 是一个基于 Chrome V8 引擎的 JavaScript <strong>代码运行环境</strong>；</li><li>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境；</li><li>Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境；</li><li>JavaScript 由三部分组成，<strong>ECMAScript</strong>，<strong>DOM</strong>，<strong>BOM</strong> ；</li><li>Node.js是由<strong>ECMAScript</strong>及<strong>Node 环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等等一些更加强大的 API ；</li><li>浏览器全局对象是 <code>window</code> ，Node.js 全局对象是 <code>global</code> 。</li></ul><p><img src="http://mdimg.95408.com/201912182202_431.png" alt="Node.js与JavaScript"></p><h2 id="Node-js-模块化"><a href="#Node-js-模块化" class="headerlink" title="Node.js 模块化"></a>Node.js 模块化</h2><ul><li>Node.js规定一个 <code>JavaScript</code> 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到；</li><li>模块内部使用 <code>exports</code> 导出对象，在其他模块（文件）中使用 <code>require</code> 导入其他模块；</li></ul><pre><code class="js">a.js文件const add = (n1, n2) =&gt; n1 + n2; // 一个加法的函数exports.add = add; // 将函数导出b.js文件const a = require(&#39;./a.js&#39;); // 导入a.js中的加法函数console.log(a.add(1, 2)) // 使用加法函数得到3</code></pre><h2 id="npm-工具"><a href="#npm-工具" class="headerlink" title="npm 工具"></a>npm 工具</h2><p>npmjs.com 第三方模块管理工具 （node package manager）</p><h3 id="安装模块："><a href="#安装模块：" class="headerlink" title="安装模块："></a>安装模块：</h3><pre><code class="js">本地安装：npm install 模块名称全局安装：npm install 模块名称 - g</code></pre><blockquote><ul><li><strong>本地安装</strong>的第三方模块，只存储在当前项目文件夹 <code>node_modules</code> ，只有本项目能使用，其他项目使用相同模块，需要在其他项目下再次安装；</li><li>命令行工具使用<strong>全局安装</strong>，在其他项目都可以使用；</li></ul></blockquote><h3 id="卸载模块："><a href="#卸载模块：" class="headerlink" title="卸载模块："></a>卸载模块：</h3><pre><code class="js">npm uninstall 模块名</code></pre><h2 id="nodemon-模块"><a href="#nodemon-模块" class="headerlink" title="nodemon 模块"></a>nodemon 模块</h2><p>是一个命令行工具，全局安装： <code>npm install nodemon -g</code> ；</p><p>辅助替换node命令，项目更改时，能自动刷新；</p><h2 id="nrm-替换国内镜像源"><a href="#nrm-替换国内镜像源" class="headerlink" title="nrm 替换国内镜像源"></a>nrm 替换国内镜像源</h2><p>nrm 安装： <code>npm install nrm -g</code> ；</p><p>查询下载地址列表： <code>nrm ls</code> ；</p><p>选择国内taobao下载源，加快下载速度： <code>nrm use taobao</code> ；</p><p><img src="http://mdimg.95408.com/201912182305_359.png?null" alt=""></p><h2 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h2><p>node_modules 文件夹中包含了项目中所有的第三方模块，数百个，多而碎；</p><p>依赖关系复杂，不同版本的兼容问题；</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。</p><p>使用 <code>npm init -y</code> 命令生成。</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><p>开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖；</p><p>正常使用 <code>npm install 包名</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;dependencies&quot;: {        &quot;jquery&quot;: &quot;^3.3.1“    }}</code></pre><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><p>开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖；</p><p>命令行加 –save -dev 安装： <code>npm install 包名 --save -dev</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;devDependencies&quot;: {        &quot;gulp&quot;: &quot;^3.9.1“    }}</code></pre><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>当我们将项目移到其他电脑，由于有了 <code>package.json</code> 和 <code>package-lock.json</code> 文件，不需要拷贝 <code>node_modules</code> 文件夹；</p><p>只需运行 <code>npm install</code> 即可通过这两个文件，自行下载所需的所有第三方模块。</p></blockquote><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
