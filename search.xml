<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Express框架</title>
      <link href="/2019/12/22/node/Node.js%EF%BC%886%EF%BC%89%EF%BC%9AExpress%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/12/22/node/Node.js%EF%BC%886%EF%BC%89%EF%BC%9AExpress%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>art-Template 模板引擎</title>
      <link href="/2019/12/22/node/Node.js%EF%BC%885%EF%BC%89%EF%BC%9Aart-Template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2019/12/22/node/Node.js%EF%BC%885%EF%BC%89%EF%BC%9Aart-Template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue/Vue基础</title>
      <link href="/2019/12/21/vue/Vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/21/vue/Vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Node.js与数据库Mongodb</title>
      <link href="/2019/12/20/node/Node.js%EF%BC%884%EF%BC%89%EF%BC%9AMongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/12/20/node/Node.js%EF%BC%884%EF%BC%89%EF%BC%9AMongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>下载：</strong></p><blockquote><p>下载地址：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a></p></blockquote><p><strong>系统环境变量：</strong></p><blockquote><p>将MongoDB的路径 <code>C:\Program Files\MongoDB\Server\4.1\bin</code> 加入系统环境变量。</p></blockquote><p><strong>启动/停止：</strong></p><blockquote><p>启动： <code>net start mongodb</code> </p><p>停止： <code>net stop mongodb</code> </p><p>注意：以管理员身份运行命令提示行</p></blockquote><p><strong>导入数据：</strong></p><blockquote><p>mongoimport –d 数据库名称 –c 集合名称 –file 要导入的数据文件 (注意：是 - - file)</p><p>mongoimport - d playground - c users –file. / user.json</p></blockquote><p><strong>其他：</strong></p><blockquote><p>  创建的数据库会自动加<code>s</code>；</p><p>  <code>const User = mongoose.model(&#39;User&#39;, userSchema);</code>数据库中的集合名称实际为<code>users</code>；</p><p>  <a href="https://www.jianshu.com/p/775088bb8f92" target="_blank" rel="noopener">使用Mongoose查询数据库一直为空数组？</a></p></blockquote><h3 id="MongoDB-Compass-可视化"><a href="#MongoDB-Compass-可视化" class="headerlink" title="MongoDB Compass 可视化"></a>MongoDB Compass 可视化</h3><p><img src="http://mdimg.95408.com/201912202251_415.png" alt=""></p><h3 id="数据库、集合、文档、字段"><a href="#数据库、集合、文档、字段" class="headerlink" title="数据库、集合、文档、字段"></a>数据库、集合、文档、字段</h3><p>在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）。</p><table><thead><tr><th align="center"><strong>术语</strong></th><th align="center"><strong>解释说明</strong></th></tr></thead><tbody><tr><td align="center">database    数据库</td><td align="center">mongoDB数据库软件中可以建立多个数据库</td></tr><tr><td align="center">collection    集合</td><td align="center">一组数据的集合，可以理解为JavaScript中的数组</td></tr><tr><td align="center">document    文档</td><td align="center">一条具体的数据，可以理解为JavaScript中的对象</td></tr><tr><td align="center">field    字段</td><td align="center">文档中的属性名称，可以理解为JavaScript中的对象属性</td></tr></tbody></table><h2 id="Node-js与MongoDB"><a href="#Node-js与MongoDB" class="headerlink" title="Node.js与MongoDB"></a>Node.js与MongoDB</h2><p>使用Node.js操作MongoDB数据库。</p><h3 id="Mongoose模块"><a href="#Mongoose模块" class="headerlink" title="Mongoose模块"></a>Mongoose模块</h3><ul><li>使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose；</li><li>使用 <code>npm install mongoose</code> ；</li></ul><h3 id="Node-js连接MongoDB"><a href="#Node-js连接MongoDB" class="headerlink" title="Node.js连接MongoDB"></a>Node.js连接MongoDB</h3><ul><li>在MongoDB中<strong>不需要显式创建数据库</strong>，如果正在使用的数据库不存在，<strong>MongoDB</strong>会自动创建；</li></ul><pre><code class="js">// 1.jsconst mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// D:\doc\1220&gt;node 1.js// 数据库连接成功</code></pre><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><ul><li>一个集合就是一个数据库表单，如excel中的表单；</li><li>创建集合分为两步，一是对<strong>对集合设定规则</strong>，二是<strong>创建集合</strong>；</li></ul><pre><code class="js">const mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// 创建集合规则// 返回构造函数const courseSchema = new mongoose.Schema({    name: String,    author: String,    isPublished: Boolean});// 使用集合规则创建集合// 创建的集合名为：courses// 参1：集合名称； 参2：集合规则const Course = mongoose.model(&#39;Course&#39;, courseSchema);// 创建集合的文档const course = new Course({    name: &#39;Node.js&#39;,    author: &#39;JavaScript&#39;,    isPublished: true})// 保存，将创建的文档插入到数据库course.save();</code></pre><h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>创建文档实际就是向集合中插入数据。</p><ul><li>只创建了集合，数据库并没有自动创建；</li><li>只有创建了一个文档，并将文件插入到集合中，集合才会自动创建；</li></ul><p><img src="http://mdimg.95408.com/201912202254_525.png" alt="Compass查看数据"></p><p>上一个代码中展示了一种创建数据的方式，以下是另外一种：</p><pre><code class="js">// 创建集合const Course = mongoose.model(&#39;Course&#39;, courseSchema);// 向集合中插入数据Course.create({    &#39;name&#39;: &#39;Django&#39;,    &#39;author&#39;: &#39;Python&#39;,    &#39;isPublished&#39;: true}, (err, result) =&gt; {    console.log(err);    console.log(result);});</code></pre><p><img src="http://mdimg.95408.com/201912202255_890.png" alt=""></p><p>也支持异步函数的方式：</p><pre><code class="js">Course.create({        &#39;name&#39;: &#39;Django&#39;,        &#39;author&#39;: &#39;Python&#39;,        &#39;isPublished&#39;: true    })    .then(result =&gt; {        console.log(result);    })</code></pre><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><pre><code class="js">mongoimport - d playground - c users --file. / user.json</code></pre><p><img src="http://mdimg.95408.com/201912202255_2.png" alt="图片错误：应是users"></p><h3 id="mongoose验证"><a href="#mongoose验证" class="headerlink" title="mongoose验证"></a>mongoose验证</h3><p>在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败；</p><p>获取错误信息：error.errors[‘字段名称’].message</p><ul><li>required: true   必传字段</li><li>minlength：3   字符串最小长度</li><li>maxlength: 20   字符串最大长度</li><li>min: 2   数值最小为2</li><li>max: 100   数值最大为100</li><li>enum: [‘html’<strong>,</strong> ‘css’<strong>,</strong> ‘javascript’<strong>,</strong> ‘node.js’]</li><li>trim: true   去除字符串两边的空格</li><li>validate:   自定义验证器</li><li>default:   默认值</li></ul><h3 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h3><p>通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。</p><ul><li>使用id对集合进行关联</li><li>使用populate方法进行关联集合查询</li></ul><pre><code class="js">// 用户集合const User = mongoose.model(&#39;User&#39;, new mongoose.Schema({ name: { type: String } })); // 文章集合const Post = mongoose.model(&#39;Post&#39;, new mongoose.Schema({    title: { type: String },    // 使用ID将文章集合和作者集合进行关联    author: { type: mongoose.Schema.Types.ObjectId, ref: &#39;User&#39; }}));//联合查询Post.find()      .populate(&#39;author&#39;)      .then((err, result) =&gt; console.log(result));</code></pre><h2 id="查-改-删"><a href="#查-改-删" class="headerlink" title="查/改/删"></a>查/改/删</h2><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>find()不管查询的数据多少，都返回文档（一个数组）；</p><pre><code class="js">//  根据条件查找文档（条件为空则查找所有文档）Course.find().then(result =&gt; console.log(result))// 返回文档集合[{    _id: 5 c0917ed37ec9b03c07cf95f,    name: &#39;张三&#39;,    email: &#39;zhangsan@qq.cn‘}, {    _id: 5 c09dea28acfb814980ff827,    name: &#39;Javascript&#39;,    email: &#39;zhangsan@qq.cn‘}]</code></pre><h4 id="findOne"><a href="#findOne" class="headerlink" title="findOne()"></a>findOne()</h4><p>findOne() 返回单一的对象；</p><pre><code class="js">//  根据条件查找文档Course.findOne({            name: 张三 &#39;}).then(result =&gt; console.log(result))            // 返回文档            {                _id: 5 c0917ed37ec9b03c07cf95f,                name: &#39;张三&#39;,                author: &#39;zhangsan@qq.cn‘            }</code></pre><h4 id="查询之前导入的数据"><a href="#查询之前导入的数据" class="headerlink" title="查询之前导入的数据"></a>查询之前导入的数据</h4><pre><code class="js">const mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// 创建集合规则const userSchema = new mongoose.Schema({    name: String,    age: Number,    email: String,    password: String,    hobbies: [String],});// 创建集合const User = mongoose.model(&#39;User&#39;, userSchema);// 查询所有User.find().then(result =&gt; console.log(result));</code></pre><h4 id="查询符号使用"><a href="#查询符号使用" class="headerlink" title="查询符号使用"></a>查询符号使用</h4><p><img src="http://mdimg.95408.com/201912202359_364.png" alt=""></p><pre><code class="js">// 年龄大于20 小于50User.find({    age: {        $gt: 20,        $lt: 50    }}).then(result =&gt; console.log(result));// 爱好在敲代码中的数据User.find({    hobbies: {        $in: [&#39;敲代码&#39;]    }}).then(result =&gt; console.log(result));// 只查找name email字段的数据 加-表示不显示的字段，_id字段默认显示User.find().select(&#39;name email -_id&#39;).then(result =&gt; console.log(result));// 按年龄字段进行排序 加-为降序User.find().sort(&#39;age&#39;).then((result) =&gt; {    console.log(result)});// skip 跳过2条，limit 限制显示2条User.find().skip(2).limit(2).then(result =&gt; {    console.log(result)});</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><h4 id="findOneAndDelete"><a href="#findOneAndDelete" class="headerlink" title="findOneAndDelete"></a>findOneAndDelete</h4><ul><li>查找一条文档并删除；</li><li>返回删除的文档</li><li>如果查到了多个文档，删除第一条</li></ul><pre><code class="js">// 删除单个User.findOneAndDelete({        _id: &#39;5c09f267aeb04b22f8460968&#39;    })    .then(result =&gt; console.log(result));// 删除了指定_id的‘王五’的数据</code></pre><h4 id="deleteMany"><a href="#deleteMany" class="headerlink" title="deleteMany"></a>deleteMany</h4><ul><li>为空时，删除所有！！！很危险！！！</li><li>返回删除数据条数</li></ul><pre><code class="js">// 删除多个User.deleteMany({}).then(result =&gt; console.log(result))</code></pre><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="updateOne"><a href="#updateOne" class="headerlink" title="updateOne"></a>updateOne</h4><pre><code class="js">// 更新单个User.updateOne({    查询条件}, {    要修改的值}).then(result =&gt; console.log(result))// 将李四这个文档的年龄改成8User.updateOne({        &#39;name&#39;: &#39;李四&#39;    }, {        &#39;age&#39;: 8    })    .then(result =&gt; console.log(result));</code></pre><h4 id="updateMany"><a href="#updateMany" class="headerlink" title="updateMany"></a>updateMany</h4><ul><li>查询条件为空，更改全部文档数据！！！危险！！！</li></ul><pre><code class="js">// 更新多个User.updateMany({    查询条件}, {    要更改的值}).then(result =&gt; console.log(result))// 将所有数据的年龄改成8User.updateMany({}, {        &#39;age&#39;: 8    })    .then(result =&gt; console.log(result));</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(2)Css3动画、2D、3D</title>
      <link href="/2019/12/19/css/(2)Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/"/>
      <url>/2019/12/19/css/(2)Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/</url>
      
        <content type="html"><![CDATA[<h2 id="2D转换-transform"><a href="#2D转换-transform" class="headerlink" title="2D转换 transform"></a>2D转换 transform</h2><p>2D 转换是改变标签在二维平面上的位置和形状</p><ul><li>移动： <code>translate</code></li><li>旋转： <code>rotate</code></li><li>缩放： <code>scale</code></li></ul><h3 id="translate-移动"><a href="#translate-移动" class="headerlink" title="translate 移动"></a>translate 移动</h3><ul><li><code>translate</code> 最大的优点就是不影响其他元素的位置</li><li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li></ul><pre><code class="css">transform: translate(x, y)transform: translateX(n)transfrom: translateY(n)</code></pre><ul><li>行内标签没有效果</li></ul><pre><code class="css">div {  background-color: lightseagreen;  width: 200px;  height: 100px;  /* 水平垂直移动 100px */  /* transform: translate(100px, 100px); */  /* 水平移动 100px */  /* transform: translate(100px, 0) */  /* 垂直移动 100px */  /* transform: translate(0, 100px) */  /* 水平移动 100px */  /* transform: translateX(100px); */  /* 垂直移动 100px */  transform: translateY(100px)}</code></pre><h3 id="例：让盒子水平垂直居中"><a href="#例：让盒子水平垂直居中" class="headerlink" title="例：让盒子水平垂直居中"></a>例：让盒子水平垂直居中</h3><pre><code class="html">&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;style&gt;    div {        position: relative;        width: 500px;        height: 500px;        background-color: red;    }    p {        position: absolute;        top: 50%;        left: 50%;        /* 原来的办法：计算返回原元素的一半 */        /* margin-top: -100px; */        /* margin-left: -100px; */        /* translate(-50%, -50%)  盒子往上走自己高度的一半 */        transform: translate(-50%, -50%);        width: 200px;        height: 200px;        background-color: burlywood;    }&lt;/style&gt;</code></pre><h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><pre><code class="css">/* 单位是：deg */transform: rotate(度数如180deg) </code></pre><ul><li><code>rotate</code> 里面跟度数，单位是 <code>deg</code></li><li>角度为正时，顺时针，角度为负时，逆时针</li><li>默认旋转的中心点是元素的中心点</li></ul><pre><code class="html">&lt;style&gt;    div {        width: 200px;        height: 100px;        background-color: red;    }    div:hover {        transform: rotate(90deg);        /* 鼠标移动时顺时针转90度 */    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h3 id="例：图标360度旋转"><a href="#例：图标360度旋转" class="headerlink" title="例：图标360度旋转"></a>例：图标360度旋转</h3><p><img src="http://mdimg.95408.com/web_2019121903.gif" alt="图标360度旋转"></p><pre><code class="html">&lt;style&gt;    img {        width: 200px;        height: 200px;        background-color: pink;        border: pink solid 1px;        border-radius: 50%;        transition: all 0.3s;    }    img:hover {        transform: rotate(180deg);    }&lt;/style&gt;&lt;body&gt;    &lt;img src=&quot;media/pic.jpg&quot; alt=&quot;&quot;&gt;&lt;/body&gt;</code></pre><h3 id="例：制作上下-gt-符号"><a href="#例：制作上下-gt-符号" class="headerlink" title="例：制作上下  &gt; 符号"></a>例：制作上下  &gt; 符号</h3><p><img src="http://mdimg.95408.com/web_2019121902.gif" alt="上下  &gt; 符号"></p><pre><code class="html">&lt;style&gt;    div {        position: relative;        width: 249px;        height: 35px;        border: 1px solid #333;    }    div::after {        content: &quot;&quot;;        position: absolute;        top: 10px;        right: 10px;        /* 创建一个只有两边边框的方形 */        width: 10px;        height: 10px;        border-right: 1px solid #333;        border-bottom: 1px solid #333;        /* 将方形旋转45度 */        transform: rotate(45deg);        transition: all .2s;    }    /* 是鼠标经过div时，::after变动效果 */    div:hover::after {        transform: rotate(225deg);        top: 15px;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="旋转中心点-transform-origin"><a href="#旋转中心点-transform-origin" class="headerlink" title="旋转中心点 transform-origin"></a>旋转中心点 transform-origin</h3><pre><code class="css">transform-origin: x y;div {    width: 200px;    height: 200px;    background-color: pink;    margin: 100px auto;    transition: all 1s;    /* 1.可以跟方位名词 */    /* transform-origin: left bottom; */    /* 2. 默认的是 50%  50%  等价于 center  center */    /* 3. 可以是px 像素 */    transform-origin: 50px 50px;}</code></pre><ul><li>注意后面的参数 x 和 y 用空格隔开</li><li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code></li><li>还可以给 x y 设置像素或者方位名词(<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code>)</li></ul><h3 id="例：图片从左下角旋转上升"><a href="#例：图片从左下角旋转上升" class="headerlink" title="例：图片从左下角旋转上升"></a>例：图片从左下角旋转上升</h3><p><img src="http://mdimg.95408.com/2019121901.gif" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* 隐藏div外的after中的内容 */        overflow: hidden;        position: relative;        width: 300px;        height: 200px;        border: 1px solid #333;        margin: 10px;        float: left;    }    img {        position: absolute;        top: 0;        left: 0;        width: 300px;        height: 200px;        /* 以左 下 角为基点，旋转180度，看不看的状态 */        transform: rotate(100deg);        transform-origin: left bottom;        transition: all .2s;    }    div:hover img {        /* 鼠标移动，图片旋转到div内 */        transform: rotate(0deg);    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><pre><code class="css">transform: scale(x, y)div:hover {    /* 注意，数字是倍数的含义，所以不需要加单位 */    /* transform: scale(2, 2) */    /* 实现等比缩放，同时修改宽与高 */    /* transform: scale(2) */    /* 小于 1 就等于缩放*/    transform: scale(0.5, 0.5)}</code></pre><ul><li>x 与 y 之间使用逗号进行分隔</li><li><code>transform: scale(1, 1)</code>: 宽高都放大一倍，相当于没有放大</li><li><code>transform: scale(2, 2)</code>: 宽和高都放大了二倍</li><li><code>transform: scale(2)</code>: 如果只写了一个参数，第二个参数就和第一个参数一致</li><li><code>transform:scale(0.5, 0.5)</code>: 缩小</li><li>优势：可以设置转换中心点缩放，默认以中心点缩放，而且<strong>不影响其他盒子</strong></li></ul><h3 id="例：图片放大"><a href="#例：图片放大" class="headerlink" title="例：图片放大"></a>例：图片放大</h3><p><img src="http://mdimg.95408.com/web_2019121905.gif" alt="图片放大"></p><h3 id="例：分类按钮放大"><a href="#例：分类按钮放大" class="headerlink" title="例：分类按钮放大"></a>例：分类按钮放大</h3><p><img src="http://mdimg.95408.com/web_2019121906.gif" alt="分类按钮放大"></p><h3 id="2D-转换综合写法-及-顺序"><a href="#2D-转换综合写法-及-顺序" class="headerlink" title="2D 转换综合写法 及 顺序"></a>2D 转换综合写法 及 顺序</h3><ul><li>顺序会影响到转换的效果；</li><li>同时有位置或者其他属性的时候，要将<strong>位移放到最前面</strong> ；</li></ul><pre><code class="css">div:hover {  transform: translate(200px, 0) rotate(360deg) scale(1.2)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(1)HTML5+Css3基础</title>
      <link href="/2019/12/19/css/(1)HTML5+Css3%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/19/css/(1)HTML5+Css3%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML新增"><a href="#HTML新增" class="headerlink" title="HTML新增"></a>HTML新增</h2><h2 id="1-1、语义化标签"><a href="#1-1、语义化标签" class="headerlink" title="1.1、语义化标签"></a>1.1、语义化标签</h2><ul><li><code>header</code>   —  头部标签</li><li><code>nav</code>        —  导航标签</li><li><code>article</code> —   内容标签</li><li><code>section</code> —   块级标签</li><li><code>aside</code>     —   侧边栏标签</li><li><code>footer</code>   —   尾部标签</li></ul><blockquote><p>  在 <code>IE9</code> 浏览器中，需要把语义化标签都转换为块级元素语义化标签；</p><p>  在移动端支持比较友好；</p></blockquote><h2 id="1-2、多媒体音频标签"><a href="#1-2、多媒体音频标签" class="headerlink" title="1.2、多媒体音频标签"></a>1.2、多媒体音频标签</h2><h3 id="1-2-1、audio"><a href="#1-2-1、audio" class="headerlink" title="1.2.1、audio"></a>1.2.1、audio</h3><p><img src="http://mdimg.95408.com/201912191818_942.png" alt="audio 的参数"></p><blockquote><p>注意：在 chrome 浏览器中已经禁用了 autoplay 属性</p></blockquote><h3 id="1-2-2、video"><a href="#1-2-2、video" class="headerlink" title="1.2.2、video"></a>1.2.2、video</h3><pre><code class="html">&lt;body&gt;  &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;  &lt;!-- 多个视频格式支持不同浏览器 --&gt;  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;  &lt;/video&gt;&lt;/body&gt;</code></pre><blockquote><p>谷歌浏览器禁用了自动播放功能，解决办法：需要添加 <strong>muted</strong> 属性</p></blockquote><p><img src="http://mdimg.95408.com/201912191820_561.png?null" alt="video 参数"></p><h2 id="1-3、input-标签"><a href="#1-3、input-标签" class="headerlink" title="1.3、input 标签"></a>1.3、input 标签</h2><p>tel只能输入电话；search能直接删除搜索数据；</p><p><img src="http://mdimg.95408.com/201912191824_8.png?null" alt="新增 input 标签"></p><h2 id="1-4、表单属性"><a href="#1-4、表单属性" class="headerlink" title="1.4、表单属性"></a>1.4、表单属性</h2><p>placeholder：表单中增加一行提示文本，获得焦点时消失；</p><p><img src="http://mdimg.95408.com/201912191826_338.png?null" alt="新增表单属性"></p><h2 id="Css3-新增"><a href="#Css3-新增" class="headerlink" title="Css3 新增"></a>Css3 新增</h2><h2 id="2-1、属性选择器"><a href="#2-1、属性选择器" class="headerlink" title="2.1、属性选择器"></a>2.1、属性选择器</h2><p><img src="http://mdimg.95408.com/201912191830_587.png?null" alt=""></p><p>1）</p><pre><code class="css">button {    /* 选择所有的button元素 */}button[disabled] {    /* 选择标签中带有disabled属性的button元素 */}</code></pre><p>2）</p><pre><code class="css">input[type=search] {    /* 选择type属性=search的input元素 */}span[class^=black] {    /* 选择class属性 以black开头的 span元素 */}span[class$=black] {    /* 选择class属性 以black结尾的 span元素 */}span[class*=black] {    /* 选择class属性 包含black的 span元素 */}</code></pre><h2 id="2-2、结构伪类选择器"><a href="#2-2、结构伪类选择器" class="headerlink" title="2.2、结构伪类选择器"></a>2.2、结构伪类选择器</h2><p><img src="http://mdimg.95408.com/201912191838_395.png" alt="结构伪类选择器属性列表"></p><h3 id="2-2-1、first-child-last-child"><a href="#2-2-1、first-child-last-child" class="headerlink" title="2.2.1、first-child / last-child"></a>2.2.1、first-child / last-child</h3><pre><code class="css">ul li:first-child {  /* 选择第一个li元素 */}ul li:last-child {  /* 选择最后一个li元素 */}ul li:nth-child(3) {  /* 选择第3个li元素 */}</code></pre><h3 id="2-2-2、nth-child"><a href="#2-2-2、nth-child" class="headerlink" title="2.2.2、nth-child( )"></a>2.2.2、nth-child( )</h3><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td>ul li:nth-child(<strong>even</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>odd</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>2n</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>2n+1</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>5n</strong>) { }</td><td>第5、10、15个</td></tr><tr><td>ul li:nth-child(<strong>3n</strong>) { }</td><td>第3、6、9个</td></tr><tr><td>ul li:nth-child(<strong>n+5</strong>) { }</td><td>从第5个到最后</td></tr><tr><td>ul li:nth-child(<strong>-n+5</strong>) { }</td><td>前面5个</td></tr></tbody></table><blockquote><p>  有时需要将2排各5个div中的最右边2个去除 <code>margin-right</code> 时，可以用 <code>ul li:nth-child(5)</code> 来选择第 5、10个div元素。</p></blockquote><h3 id="2-2-3、nth-child-和-nt-of-type-的区别"><a href="#2-2-3、nth-child-和-nt-of-type-的区别" class="headerlink" title="2.2.3、nth-child 和 nt-of-type 的区别"></a>2.2.3、nth-child 和 nt-of-type 的区别</h3><ul><li>ul中只有li元素时，两都选择相同；</li><li>ul中第一个是p元素，后面是li元素时：<ul><li>nth-child 选择父元素里面的第几个子元素，只要是子元素即可，不管是什么类型；</li><li>nth-of-type 是选择父元素的某一种子元素的第几个；</li></ul></li></ul><pre><code class="css">&lt;body&gt;    &lt;ul&gt;        &lt;p&gt;p&lt;/p&gt;        &lt;li&gt;li 1&lt;/li&gt;        &lt;li&gt;li 2&lt;/li&gt;        &lt;li&gt;li 3&lt;/li&gt;        &lt;li&gt;li 4&lt;/li&gt;        &lt;li&gt;li 5&lt;/li&gt;        &lt;li&gt;li 6&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;style&gt;    ul :nth-child(1){        background-color: red;          /* 选择p */    }    ul li:nth-child(3){        background-color: blue;        /* 选择li 2 */        /* 虽然选择的是li的第3个，但是从第一个子元素p就开始计算 */    }    ul li:nth-of-type(3){        background-color: green;        /* 选择li 3 */    }    ul li:nth-of-type(1){        background-color: hotpink;        /* 选择li 1 */    }&lt;/style&gt;</code></pre><h2 id="2-3、伪元素选择器"><a href="#2-3、伪元素选择器" class="headerlink" title="2.3、伪元素选择器"></a>2.3、伪元素选择器</h2><p><img src="http://mdimg.95408.com/201912191916_205.png?null" alt="伪类选择器"></p><h3 id="2-3-1、注意事项"><a href="#2-3-1、注意事项" class="headerlink" title="2.3.1、注意事项"></a>2.3.1、注意事项</h3><ul><li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li><li><code>before</code> 在内容前面，<code>after</code> 在内容后面</li><li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li><li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li><li>伪元素和标签选择器一样，权重为 1</li></ul><h3 id="2-3-2、增加字体图标"><a href="#2-3-2、增加字体图标" class="headerlink" title="2.3.2、增加字体图标"></a>2.3.2、增加字体图标</h3><pre><code class="css">p {   width: 220px;   height: 22px;   border: 1px solid lightseagreen;   margin: 60px;   position: relative;}p::after {  content: &#39;\ea50&#39;;  font-family: &#39;icomoon&#39;;  position: absolute;  top: -1px;  right: 10px;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js的web服务器、http、路由、异步编程</title>
      <link href="/2019/12/19/node/Node.js%EF%BC%883%EF%BC%89%EF%BC%9Aweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81http%E3%80%81async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/19/node/Node.js%EF%BC%883%EF%BC%89%EF%BC%9Aweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81http%E3%80%81async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP协议"><a href="#1-HTTP协议" class="headerlink" title="1. HTTP协议"></a>1. HTTP协议</h2><h3 id="1-1-web-服务器模块-http"><a href="#1-1-web-服务器模块-http" class="headerlink" title="1.1 web 服务器模块 http"></a>1.1 web 服务器模块 http</h3><ul><li>创建一个服务器对象app，绑定一个端口号：3000；</li><li>通过后台运行 <code>node app.js</code> ，就创建了一个web服务器；</li><li>浏览器请求这个服务器的地址： <code>localhost:3000</code> 时，服务器就响应一段数据（ <code>res.end</code> ）给浏览器；</li></ul><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // 当浏览器请求时，服务器响应内容给浏览器    res.end(&#39;当你在浏览器输入网址请求本web服务器，就会响应这一些文字&#39;);})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><p>Chrome–F12–Network–Headers：请求和响应报文：</p><p><strong>Request 请求报文</strong></p><ul><li>浏览器客户端告诉服务器端的事件；</li><li>能接收的格式，语言；</li></ul><p><strong>Response 响应报文</strong></p><ul><li>服务器端对浏览器客户端响应的事情；</li><li>服务器端响应给客户端具体的数据：html文件</li></ul><h3 id="1-2-请求报文"><a href="#1-2-请求报文" class="headerlink" title="1.2 请求报文"></a>1.2 请求报文</h3><p>请求方式：</p><ul><li>GET 请求数据</li><li>POST 发送数据</li></ul><h3 id="1-3-req-method"><a href="#1-3-req-method" class="headerlink" title="1.3 req.method"></a>1.3 req.method</h3><p>req.method 获取请求的方式</p><p>浏览器端通过post或get向服务器端发送数据：</p><pre><code class="html">// 表单数据通过post请求发送给localhost:3000服务器&lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;    &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;/form&gt;</code></pre><p>服务器端接收来自浏览器客户端的数据，并响应了一段文字 <code>res.end</code> ：</p><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // req.method 获取请求的方式    console.log(req.method)    if (req.method == &#39;POST&#39;) {        res.end(&#39;来自浏览器的请求方式为POST&#39;);    } else if (req.method == &#39;GET&#39;) {        res.end(&#39;来自浏览器的请求方式为GET&#39;);    }})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h3 id="1-4-req-url"><a href="#1-4-req-url" class="headerlink" title="1.4 req.url"></a>1.4 req.url</h3><p>req.url 客户端请求的url地址</p><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // req.url 客户端面请求的url地址    if (req.url == &#39;/index&#39; || req.url == &#39;/&#39;) {        res.end(&#39;welcome to index page&#39;);    } else if (req.url == &#39;/list&#39;) {        res.end(&#39;welcom to list page&#39;);    } else {        res.end(&#39;404 not found page&#39;);    }})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h3 id="1-5-req-headers"><a href="#1-5-req-headers" class="headerlink" title="1.5 req.headers"></a>1.5 req.headers</h3><p>客户端请求的报文信息</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求报文信息中accept中的值    console.log(req.headers[&#39;accept&#39;]);})</code></pre><h3 id="1-6-响应报文"><a href="#1-6-响应报文" class="headerlink" title="1.6 响应报文"></a>1.6 响应报文</h3><h3 id="1-7-HTTP-响应状态码"><a href="#1-7-HTTP-响应状态码" class="headerlink" title="1.7 HTTP 响应状态码"></a>1.7 HTTP 响应状态码</h3><ul><li>200</li><li>404</li><li>500</li><li>400</li></ul><h3 id="1-8-res-writeHead"><a href="#1-8-res-writeHead" class="headerlink" title="1.8 res.writeHead"></a>1.8 res.writeHead</h3><p>书写服务器端给客户端响应的数据</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    res.writeHead(400);})</code></pre><p><img src="http://mdimg.95408.com/web_1576778412.jpg" alt="设置状态码为 400 时"></p><p>设置状态码、文本格式及编码：</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    // 设置状态码200和html格式及编码utf8    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    });    // req.url 客户端面请求的url地址    if (req.url == &#39;/index&#39; || req.url == &#39;/&#39;) {        res.end(&#39;欢迎来到index首页！&#39;);    } else {        res.end(&#39;404&#39;)    }})</code></pre><h2 id="2-HTTP请求和响应"><a href="#2-HTTP请求和响应" class="headerlink" title="2. HTTP请求和响应"></a>2. HTTP请求和响应</h2><h3 id="2-1-请求参数"><a href="#2-1-请求参数" class="headerlink" title="2.1 请求参数"></a>2.1 请求参数</h3><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p><h3 id="2-2-GET请求参数"><a href="#2-2-GET请求参数" class="headerlink" title="2.2 GET请求参数"></a>2.2 GET请求参数</h3><ul><li>参数被放置在浏览器地址栏中，例如：<a href="http://localhost:3000/?name=zhangsan&amp;age=20" target="_blank" rel="noopener">http://localhost:3000/?name=zhangsan&amp;age=20</a></li><li>参数获取需要借助系统模块url<ul><li>之前我们直接使用了 <code>req.url</code> 获得了所有的请求参数，如 <code>/index?name=zhangsan&amp;qq=123456</code> ；</li><li>如果要得到更方便的对象形式的 <code>get参数</code> ，可以使用 <code>url.parse(req.url, true).query;</code> ，将get地址解析成对象形式，如 <code>{ name: &#39;zhangsan&#39;, qq: &#39;123456&#39; }</code> ；</li></ul></li></ul><h4 id="2-2-1-url-parse-query"><a href="#2-2-1-url-parse-query" class="headerlink" title="2.2.1 url.parse( ).query"></a>2.2.1 url.parse( ).query</h4><pre><code class="js">// 引入系统模块urlconst url = require(&#39;url&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求参数    console.log(req.url); // /index?name=zhangsan&amp;qq=123455    // 将请求参数交给url模块进行处理    // parse(参1：要解析的url地址， 参2：将参数解析成对象形式)    let params = url.parse(req.url, true).query;    console.log(params); // { name: &#39;zhangsan&#39;, qq: &#39;123455&#39; }    console.log(params.name); // params.name获取：zhangsan    console.log(params.qq); // params.qq获取：123455})</code></pre><h4 id="2-2-2-url-parse-pathname"><a href="#2-2-2-url-parse-pathname" class="headerlink" title="2.2.2 url.parse( ).pathname"></a>2.2.2 url.parse( ).pathname</h4><p><code>url.parse().pathname</code> 包含的是url地址的 <code>/index</code> 部分，前面通过url的路由没有提取get参数；</p><pre><code class="js">    let query = url.parse(req.url, true).query;    // query:  { name: &#39;zhangsan&#39;, qq: &#39;123455&#39; }    let pathname = url.parse(req.url, true).pathname;    // pathname:  /index    // 等同于：    let {        query,        pathname    } = url.parse(req.url, true);</code></pre><h4 id="2-2-3-get请求响应页面"><a href="#2-2-3-get请求响应页面" class="headerlink" title="2.2.3 get请求响应页面"></a>2.2.3 get请求响应页面</h4><p>通过get请求地址响应不同页面</p><p>修改去除url中的get参数（原来：if (req.url == ‘/index’)，如果url中有参数就无法识别）</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    let {        query,        pathname    } = url.parse(req.url, true);    // 设置状态码200和html格式及编码utf8    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    });    // req.url 客户端面请求的url地址    // 原来：if (req.url == &#39;/index&#39;)，如果url中有参数就无法识别    if (pathname == &#39;/index&#39; || pathname == &#39;/&#39;) {        res.end(&#39;欢迎来到index首页！&#39;);    } else if (pathname == &#39;/list&#39;) {        res.end(&#39;欢迎来到list页面&#39;)    } else {        res.end(&#39;404&#39;)    }})</code></pre><p><img src="http://mdimg.95408.com/201912201246_963.png" alt="url中带get参数"></p><h3 id="2-3-POST请求参数"><a href="#2-3-POST请求参数" class="headerlink" title="2.3 POST请求参数"></a>2.3 POST请求参数</h3><ul><li>参数被放置在请求体中进行传输</li><li>获取POST参数需要使用data事件和end事件</li><li>使用querystring</li></ul><h4 id="2-3-1-form-html"><a href="#2-3-1-form-html" class="headerlink" title="2.3.1 form.html"></a>2.3.1 form.html</h4><p><code>form.html</code> ： html表单通过post参数向服务器传递数据：</p><pre><code class="html">&lt;body&gt;    &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;usename&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><h4 id="2-3-2-提交表单"><a href="#2-3-2-提交表单" class="headerlink" title="2.3.2 提交表单"></a>2.3.2 提交表单</h4><p>使用表单提交数据：</p><p><img src="http://mdimg.95408.com/201912201313_858.png" alt=""></p><h4 id="2-3-3-app-js"><a href="#2-3-3-app-js" class="headerlink" title="2.3.3 app.js"></a>2.3.3 app.js</h4><p><code>app.js</code> ：服务器开启 <code>nodemon app.js</code> 后，接收来自form.html传递的post数据：</p><blockquote><p><code>console.log(postParams);</code> // usename=zhangsan&amp;password=123456；</p><p><code>console.log(querystring.parse(postParams));</code> // { usename: ‘zhangsan’, password: ‘123456’ }；</p></blockquote><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 处理请求参数模块 post参数字符串转为对象const querystring = require(&#39;querystring&#39;)// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // post请求    // 请求参数传输有一定的时间    // post参数是通过事件的方式接收的    // 请求参数传递时触发data事件    // 请求参数传输完成时触发end事件    let postParams = &#39;&#39;;    req.on(&#39;data&#39;, params =&gt; {        postParams += params;    })    req.on(&#39;end&#39;, () =&gt; {        // postParams 为post请求数据的字符串格式        console.log(postParams); // usename=zhangsan&amp;password=123456        // querystring.parse(postParams)         // 通过处理后得到了对象形式的post请求数据        console.log(querystring.parse(postParams));        // { usename: &#39;zhangsan&#39;, password: &#39;123456&#39; }    })})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h2 id="3-路由"><a href="#3-路由" class="headerlink" title="3. 路由"></a>3. 路由</h2><p>之前，我们在浏览器输入 <code>localhost:3000/index</code> ，需要响应到 <code>index</code> 页面上的内容；</p><p>输入 <code>localhost:3000/list</code> ，需要响应到 <code>list</code> 上的数据；</p><blockquote><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p></blockquote><p><img src="http://mdimg.95408.com/201912201325_932.png" alt="路由"></p><p>之前的代码：</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    let {        query,        pathname    } = url.parse(req.url, true);    if (pathname == &#39;/index&#39; || pathname == &#39;/&#39;) {        res.end(&#39;index页面数据&#39;);    } else if (pathname == &#39;/list&#39;) {        res.end(&#39;list页面数据&#39;)    } else {        res.end(&#39;404&#39;)    }})</code></pre><p>以上是简单的路由代码，但没有体现客户端的get、post请求判断；</p><h4 id="3-1-判断为get请求的路由"><a href="#3-1-判断为get请求的路由" class="headerlink" title="3.1 判断为get请求的路由"></a>3.1 判断为get请求的路由</h4><pre><code class="js">const http = require(&#39;http&#39;);const url = require(&#39;url&#39;);const app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求方式,转小写    const method = req.method.toLowerCase();    // 获取请求地址    const pathname = url.parse(req.url).pathname;    // 响应头设置编码    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    })    // 判断请求方式是post还是get    if (method == &#39;get&#39;) {        // 判断请求url来响应数据        if (pathname == &#39;/&#39; || pathname == &#39;/index&#39;) {            res.end(&#39;欢迎来到首页&#39;);        } else if (pathname == &#39;/list&#39;) {            res.end(&#39;欢迎来到列表页&#39;);        } else {            res.end(&#39;没有找到你要的页面&#39;)        }    } else if (method == &#39;post&#39;) {        // 请求方式为post时的内容        // 与get判断基本相同    }})app.listen(3000);console.log(&#39;服务器启动成功&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912201346_522.png" alt=""></p><h2 id="4-静态资源"><a href="#4-静态资源" class="headerlink" title="4. 静态资源"></a>4. 静态资源</h2><p>将客户端浏览器请求的路径，转换为服务器实现静态文件路径：</p><pre><code class="js">const http = require(&#39;http&#39;);const url = require(&#39;url&#39;);const path = require(&#39;path&#39;);const app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    // 响应原始url路径    // res.end(req.url);    // 获取请求地址    const pathname = url.parse(req.url).pathname;    // 响应pathname路径    // res.end(pathname);  // /index    const dirpath = path.join(__dirname, &#39;public&#39; + pathname);    // 响应path拼接的绝对路径    res.end(dirpath); // D:\doc\1218\route\public\index})app.listen(3000);console.log(&#39;服务器启动成功&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912201407_769.png" alt=""></p><p>我们通过拼接得到了文件的绝对路径 <code>d:\doc\1218\route\public\index</code> ，可以通过 <code>fs</code> 模块读取，响应给客户端：</p><h3 id="4-1-读取静态-html文件"><a href="#4-1-读取静态-html文件" class="headerlink" title="4.1 读取静态.html文件"></a>4.1 读取静态.html文件</h3><ul><li>客户端发送请求 <code>localhost:3000/index</code> ，得到请求路径 <code>/index</code> ；</li><li>服务器端 <code>path.join()</code> 拼接出服务器本地绝对地址 <code>d:\doc\1218\route\public\index</code> ；</li><li>在绝对地址下有对应的 <code>index.html</code> 文件时，通过 <code>fs.readFile</code> 读取后响应给客户端；</li><li>浏览器就打开了这个 <code>index.html</code> 的首页文件；</li></ul><pre><code class="js">const fs = require(&#39;fs&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    let pathname = url.parse(req.url).pathname;    let realpath = path.join(__dirname, &#39;public&#39; + pathname);    // res.end(realpath);   // d:\doc\1218\route\public\index    fs.readFile(realpath, (err, result) =&gt; {        // 读取失败响应文字        if (err != null) {            res.end(&#39;文件读取失败&#39;);            return;        }        // 读取成功后，将读取到的index.html文件响应给客户端        res.end(result);    })})</code></pre><p><img src="http://mdimg.95408.com/201912201435_163.png" alt=""></p><h3 id="4-2-请求根目录至首页文件"><a href="#4-2-请求根目录至首页文件" class="headerlink" title="4.2 请求根目录至首页文件"></a>4.2 请求根目录至首页文件</h3><p>当客户请求根目录 <code>localhost:3000</code> 时，跳转到 <code>localhost:3000/index</code> ：</p><pre><code class="js">pathname = pathname == &#39;/&#39; ? &#39;/index&#39; : pathname;</code></pre><h3 id="4-3-指定返回资源的类型-mime"><a href="#4-3-指定返回资源的类型-mime" class="headerlink" title="4.3 指定返回资源的类型 mime"></a>4.3 指定返回资源的类型 mime</h3><pre><code class="js">const mime = require(&#39;mime&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    let pathname = url.parse(req.url).pathname;    pathname = pathname == &#39;/&#39; ? &#39;/index&#39; : pathname;    let realpath = path.join(__dirname, &#39;public&#39;, pathname);    let type = mime.getType(realpath);    fs.readFile(realpath, (err, result) =&gt; {        if (err != null) {            res.end(&#39;文件读取失败&#39;);            return;        }        // 指定资源返回的类型        res.writeHead(200, {            &#39;content-type&#39;: type;        })        res.end(result);    })})</code></pre><p><img src="http://mdimg.95408.com/201912201449_374.png" alt=""></p><h2 id="5-异步API"><a href="#5-异步API" class="headerlink" title="5. 异步API"></a>5. 异步API</h2><h3 id="5-1-同步API-和-异步API"><a href="#5-1-同步API-和-异步API" class="headerlink" title="5.1 同步API 和 异步API"></a>5.1 同步API 和 异步API</h3><p>同步API：只有当前API执行完成后，才能继续执行下一个API；</p><pre><code class="js">console.log(&#39;1&#39;);console.log(&#39;2&#39;);console.log(&#39;3&#39;);</code></pre><p>异步API：当前API的执行不会阻塞后续代码的执行；</p><pre><code class="js">console.log(&#39;1&#39;);setTimeout(    () =&gt; {        console.log(&#39;3&#39;);    }, 2000);console.log(&#39;2&#39;);</code></pre><p>同步API可以<strong>从返回值中拿到API执行的结果</strong>, 但是异步API是不可以的；</p><p>异步API是通过回调函数来完成的。</p><pre><code class="js">// 同步function sum(n1, n2) {    return n1 + n2;}const result = sum(10, 20); // 30// 异步function getMsg() {    setTimeout(function() {        return {            msg: &#39;Hello Node.js&#39;        }    }, 2000);    // 异步不会等待，直接会在此执行 return undefined    // 2秒后才后返回msg，但此时值早已拿到，并输出了}const msg = getMsg(); // undefined</code></pre><p>同步API和异步API的执行顺序不同：</p><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行；</p><pre><code class="js">// 同步：for (var i = 0; i &lt; 100000; i++) {    console.log(i);}console.log(&#39;for循环后面的代码&#39;);// 先执行10万次，再输出最后一句话// 异步：console.log(&#39;代码开始执行&#39;);setTimeout(() =&gt; {    console.log(&#39;2秒后执行的代码&#39;)}, 2000);setTimeout(() =&gt; {    console.log(&#39;0秒后执行的代码&#39;)}, 0);console.log(&#39;代码结束执行&#39;);// 输出顺序：// 代码开始执行// 代码结束执行// 0秒后执行的代码// 2秒后执行的代码</code></pre><h3 id="5-2-Node-js-异步API-回调函数"><a href="#5-2-Node-js-异步API-回调函数" class="headerlink" title="5.2 Node.js 异步API (回调函数)"></a>5.2 Node.js 异步API (回调函数)</h3><p>我们之前读取文件、服务器请求等都是通过回调函数来实现的；</p><p>要得到读取完成后文件的数据，在回调函数中获取；</p><pre><code class="js">fs.readFile(&#39;./demo.txt&#39;, (err, result) =&gt; {    res.end(result);});var app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    res.end(req.url);});</code></pre><p><strong>回调地狱</strong></p><p>如果有多层回调函数，需要一层一层的嵌套，影响代码维护；</p><h3 id="5-3-Promise"><a href="#5-3-Promise" class="headerlink" title="5.3 Promise"></a>5.3 Promise</h3><p>Promise解决Node.js异步编程中回调地狱的问题；</p><pre><code class="js">const fs = require(&#39;fs&#39;);function p1() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./1.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}function p2() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./2.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}function p3() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./3.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}p1().then((r1) =&gt; {    console.log(r1);    return p2();}).then((result2) =&gt; {    console.log(result2);    return p3();}).then((result3) =&gt; {    console.log(result3);})</code></pre><p><img src="http://mdimg.95408.com/201912201630_672.png" alt=""></p><h2 id="6-异步函数-async"><a href="#6-异步函数-async" class="headerlink" title="6. 异步函数 async"></a>6. 异步函数 async</h2><pre><code class="js">const fn = async () =&gt; {};async function fn() {}</code></pre><p>让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p><pre><code class="js">async function fn() {    throw &#39;错误信息txt&#39;;    return 123;}// console.log(fn());   // Promise { 123 }fn().then(function(data) {    console.log(data); // 123      // return替代了resolve 用then获取}).catch(function(err) {    console.log(err); // 错误信息txt      // throw替代了reject 用catch获取})</code></pre><h3 id="6-1-async-关键字"><a href="#6-1-async-关键字" class="headerlink" title="6.1 async 关键字"></a>6.1 async 关键字</h3><ol><li>普通函数定义前加async关键字 普通函数变成异步函数</li><li>异步函数默认返回promise对象</li><li>在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法</li><li>在异步函数内部使用throw关键字抛出程序异常</li><li>调用异步函数再链式调用then方法获取异步函数执行结果</li><li>调用异步函数再链式调用catch方法获取异步函数执行的错误信息</li></ol><h3 id="6-2-await-关键字"><a href="#6-2-await-关键字" class="headerlink" title="6.2 await 关键字"></a>6.2 await 关键字</h3><ol><li>await关键字只能出现在异步函数中</li><li>await promise await后面只能写promise对象 写其他类型的API是不不可以的</li><li>await关键字可是暂停异步函数向下执行 直到promise返回结果</li></ol><pre><code class="js">async function p1() {    return &#39;1.txx&#39;;}async function p2() {    return &#39;2.txt&#39;;}async function p3() {    return &#39;3.txt&#39;;}async function run() {    let r1 = await p1(); // 直接调用p1的return的结果    let r2 = await p2();    let r3 = await p3();    console.log(r1);    console.log(r2);    console.log(r3);}run();// D:\doc\1219&gt;node 2.js// 1.txx// 2.txt// 3.txt</code></pre><h3 id="6-3-顺序读取3个文件"><a href="#6-3-顺序读取3个文件" class="headerlink" title="6.3 顺序读取3个文件"></a>6.3 顺序读取3个文件</h3><ul><li>使用async异步函数的方法按顺序读取3个文件：</li><li>const readFile = promisify(fs.readFile)   // 调用promisify方法改造了现有的异步API，让其返回promise对象；</li><li>从而支持异步函数语法；</li></ul><pre><code class="js">const fs = require(&#39;fs&#39;);// 改造现有的异步函数api，让其返回promise对象，从而支持异步函数语法const promisify = require(&#39;util&#39;).promisify;// 调用promisify方法改造了现有的异步API，让其返回promise对象const readFile = promisify(fs.readFile);async function run() {    let r1 = await readFile(&#39;./1.txt&#39;, &#39;utf8&#39;);    // 通过promisify处理的新reafFile方法，不用写回调函数，直接使用await    let r2 = await readFile(&#39;./2.txt&#39;, &#39;utf8&#39;);    let r3 = await readFile(&#39;./3.txt&#39;, &#39;utf8&#39;);    console.log(r1);    console.log(r2);    console.log(r3);}run();// D: \doc\1219 &gt; node 2.js// 1.txt内容// 2.txt内容// 3.txt内容</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js模块：fs、path、gulp</title>
      <link href="/2019/12/18/node/Node.js%EF%BC%882%EF%BC%89%EF%BC%9Afs%E3%80%81path%E3%80%81gulp%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/18/node/Node.js%EF%BC%882%EF%BC%89%EF%BC%9Afs%E3%80%81path%E3%80%81gulp%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="fs-文件操作"><a href="#fs-文件操作" class="headerlink" title="fs 文件操作"></a>fs 文件操作</h2><pre><code class="js">const fs = require(&#39;fs&#39;);</code></pre><h3 id="fs-readFile-读取文件"><a href="#fs-readFile-读取文件" class="headerlink" title="fs.readFile 读取文件"></a>fs.readFile 读取文件</h3><pre><code class="js">fs.readFile(&#39;文件路径&#39; ，&#39;文件编码可选&#39; ，callback回调函数)；</code></pre><blockquote><p>  callback回调函数的第一个值是错误信息，node.js中都是错误优先的回调函数；</p></blockquote><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的readFile读取文件内容fs.readFile(&#39;./a.txt&#39;, &#39;utf8&#39;, (err, doc) =&gt; {    // 如果读取错误，err包含错误信息    // 反之，err为空    // doc是读取的文件    console.log(err);  // 读取正确，err返回null    console.log(doc);  })</code></pre><h3 id="fs-writeFile-写入文件"><a href="#fs-writeFile-写入文件" class="headerlink" title="fs.writeFile 写入文件"></a>fs.writeFile 写入文件</h3><pre><code class="js">fs.writeFile(&#39;文件路径’， ‘数据’， callback回调函数)；</code></pre><p>如果错误，err返回错误信息；反之，err为null</p><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的writeFile写入内容fs.writeFile(&#39;./b.txt&#39;, &#39;要写入b.txt的数据&#39;, err =&gt; {    // 如果错误，err返回错误信息    // 反之，err为null    // 如果err不为空，打印err信息，return    if(err != null){        console.log(err);        return;    }    // 如果err这空，则证明写入正确    console.log(&#39;数据写入b.txt成功&#39;);})</code></pre><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>进行路径拼接：win\os\lunix的路径符不同，使用路径拼接更安全；</p><p>node中的相对路径，是相对于node系统命令工具所在的目录</p><pre><code class="js">// 调用path模块const path = require(&#39;path&#39;);// 使用path模块进行路径拼接const p = path.join(&#39;public&#39;, &#39;halfbamoo&#39;, &#39;src&#39;);console.log(p);   // public\halfbamoo\src</code></pre><p><code>__dirname</code>为系统绝对路径；</p><pre><code class="js">const pp = path.join(__dirname, &#39;public&#39;, &#39;halfbamboo&#39;, &#39;src&#39;);console.log(pp);  // D:\doc\1218\public\halfbamboo\src</code></pre><h2 id="Gulp-模块"><a href="#Gulp-模块" class="headerlink" title="Gulp 模块"></a>Gulp 模块</h2><p>基于node.js 平台的前端构建工具</p><ul><li>html、css、js文件压缩；</li><li>es6、less语法转换；</li><li>公共文件的抽离；</li><li>修改文件浏览器自动刷新；</li></ul><h3 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h3><p>安装： <code>npm install gulp</code> ，本地安装即可；</p><p>安装： <code>npm install gulp-cli -g</code> ，全局安装gulp命令行工具；</p><p>创建： <code>gulpfile.js</code> 文件写代码；</p><h3 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h3><ul><li>gulp.src()：获取任务要处理的文件</li><li>gulp.dest()：输出文件</li><li>gulp.task()：建立gulp任务</li><li>gulp.watch()：监控文件的变化</li></ul><p>使用gulp将src/css目录下的文件，复制到dist/css目录下：</p><blockquote><p>  建立一个固定名称的文件：<code>gulpfile.js</code> ，敲如下代码，</p><p>  此时，会将原/src/css中的文件，复制到/dist/css目录下，如果目标目录存在，会自动创建；</p></blockquote><pre><code class="js">gulpfile.js:// 调用gulp模块const gulp = require(&#39;gulp&#39;);// 使用gulp.task（任务名称，回调函数）建立任务gulp.task(&#39;first&#39;, () =&gt; {    console.log(&#39;第一个gulp任务&#39;);    // src 获取要处理的文件    gulp.src(&#39;./src/css/a.css&#39;)        // dest 输出文件地址 要放在pipei当中        .pipe(gulp.dest(&#39;./dist/css&#39;));})</code></pre><h3 id="gulp插件-第三方模块"><a href="#gulp插件-第三方模块" class="headerlink" title="gulp插件/第三方模块"></a>gulp插件/第三方模块</h3><ul><li>gulp-htmlmin ：html文件压缩</li><li>gulp-csso ：压缩css</li><li>gulp-babel ：JavaScript语法转化</li><li>gulp-less: less语法转化</li><li>gulp-uglify ：压缩混淆JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><p>安装：</p><pre><code class="js">npm install gulp-htmlminnpm install gulp-file-includenpm install gulp-lessnpm install gulp-cssonpm install gulp-babel @babel/core @babel/preset-env// https://www.npmjs.com/package/gulp-babelnpm install gulp-uglify</code></pre><ul><li>gulp-file-include：源代码中公共样式抽离出来后，使用 <code>@@include(&#39;./common/header.html&#39;)</code> 引入时，使用 gulp-file-include 模块，可以将引入的内容重新生成到一个完整的html页面当中；</li></ul><h3 id="gulpfile-js-创建任务"><a href="#gulpfile-js-创建任务" class="headerlink" title="gulpfile.js 创建任务"></a>gulpfile.js 创建任务</h3><p>压缩html、css、js，处理es6、less语法……</p><p>项目根目录下建立 <code>gulpfile.js</code> 文件；</p><p>源文件：src目录；处理后的文件：dict目录；</p><p>通过以下代码：我们可以：</p><ul><li>将所有html \ css \ js 压缩；</li><li>将 less 语法、es6 语法处理</li><li>将src目录下的所有文件 <strong>经过处理后</strong> 复制到 dist 文件夹</li></ul><pre><code class="js">// 调用gulp模块const gulp = require(&#39;gulp&#39;);// 调用处理htmlconst htmlmin = require(&#39;gulp-htmlmin&#39;);const fileinclude = require(&#39;gulp-file-include&#39;);// 调用处理css lessconst less = require(&#39;gulp-less&#39;);const csso = require(&#39;gulp-csso&#39;);// 调用处理jsconst babel = require(&#39;gulp-babel&#39;);const uglify = require(&#39;gulp-uglify&#39;);// 压缩html任务// 1 压缩html 2 抽取html公共代码gulp.task(&#39;htmlmin&#39;, () =&gt; {    gulp.src(&#39;./src/*.html&#39;)        .pipe(fileinclude())        // 压缩html代码        .pipe(htmlmin({ collapseWhitespace: true}))        .pipe(gulp.dest(&#39;dist&#39;));})// 压缩css 及处理 lessgulp.task(&#39;cssmin&#39;, () =&gt; {    gulp.src([&#39;./src/css/*.css&#39;, &#39;./src/css/*.less&#39;])        // 处理less        .pipe(less())        // 压缩css        .pipe(csso())        .pipe(gulp.dest(&#39;dist/css&#39;));})// 处理es6 及压缩jsgulp.task(&#39;jsmin&#39;, () =&gt; {    gulp.src(&#39;./src/js/*.js&#39;)        // 处理es6语法        .pipe(babel({            // 识别当前运行环境，将代码按当前环境转换            presets: [&#39;@babel/env&#39;]        }))        // 压缩js代码        .pipe(uglify())        .pipe(gulp.dest(&#39;dist/js&#39;));})// 复制其他不需要处理的夹 img / libgulp.task(&#39;copy&#39;, () =&gt; {    gulp.src(&#39;./src/images/*&#39;)        .pipe(gulp.dest(&#39;dist/images&#39;));    gulp.src(&#39;./src/lib/**/*&#39;)        .pipe(gulp.dest(&#39;dist/lib&#39;));})// 构建任务// gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]);gulp.task(&#39;default&#39;, gulp.parallel(&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;, function () {    console.log(&#39;任务完成&#39;);}));// 任务命令：// gulp default 或者 gulp</code></pre><h3 id="gulp3-和-gulp4的区别"><a href="#gulp3-和-gulp4的区别" class="headerlink" title="gulp3 和 gulp4的区别"></a>gulp3 和 gulp4的区别</h3><blockquote><p>  操作时报错：gulp Task function must be specified。</p><p>  gulp 版本的原因！</p></blockquote><p>在Gulp 4中需要使用<code>gulp.series</code>和<code>gulp.parallel</code>，因为gulp任务现在只有两个参数。</p><blockquote><p>  <code>gulp.series</code>：按照顺序执行<br>  <code>gulp.paralle</code>：可以并行计算</p></blockquote><pre><code class="js">gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, function() {  // Do something after a, b, and c are finished.}));gulp.task(&#39;build&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;, function () {  // Build the website.}));gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, gulp.parallel(&#39;styles&#39;,&#39;scripts&#39;, &#39;images&#39;), &#39;b&#39;, &#39;c&#39;, function() {  // Do something after a, b, and c are finished.}));</code></pre><h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><h3 id="当模块拥有路径但没有后缀时"><a href="#当模块拥有路径但没有后缀时" class="headerlink" title="当模块拥有路径但没有后缀时"></a>当模块拥有路径但没有后缀时</h3><pre><code class="js">require(&#39;./find.js&#39;);require(&#39;./find&#39;);</code></pre><ol><li>require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</li><li>如果模块后缀省略，<strong>先找同名JS文件再找同名JS文件夹</strong></li><li>如果找到了同名文件夹，找文件夹中的index.js</li><li>如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件</li><li>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li></ol><h3 id="当模块没有路径且没有后缀时"><a href="#当模块没有路径且没有后缀时" class="headerlink" title="当模块没有路径且没有后缀时"></a>当模块没有路径且没有后缀时</h3><pre><code class="js">require(&#39;find&#39;);</code></pre><ol><li>Node.js会假设它是<strong>系统模块</strong></li><li>Node.js会去node_modules文件夹中</li><li>首先看是否有该名字的JS文件</li><li>再看是否有该名字的文件夹</li><li>如果是文件夹看里面是否有index.js</li><li>如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件</li><li>否则找不到报错</li></ol><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js基础</title>
      <link href="/2019/12/18/node/Node.js%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/18/node/Node.js%EF%BC%881%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912182243_175.png" alt="Node.js"></p><h2 id="常用信息"><a href="#常用信息" class="headerlink" title="常用信息"></a>常用信息</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a></p><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm 官网</a></p><p>win系统中，需要将node.js放入系统环境变量；</p><p>如果不能安装成功，需要以管理员身份运行命令行工具；</p><p>查看 Node.js 版本： <code>node -v</code> ；</p><p>nodejs已经集成了 <code>npm</code> ，查看 npm 版本： <code>npm -v</code> ；</p><h2 id="Node-js-与JavaScript"><a href="#Node-js-与JavaScript" class="headerlink" title="Node.js 与JavaScript"></a>Node.js 与JavaScript</h2><ul><li><strong>Node</strong> 是一个基于 Chrome V8 引擎的 JavaScript <strong>代码运行环境</strong>；</li><li>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境；</li><li>Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境；</li><li>JavaScript 由三部分组成，<strong>ECMAScript</strong>，<strong>DOM</strong>，<strong>BOM</strong> ；</li><li>Node.js是由<strong>ECMAScript</strong>及<strong>Node 环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等等一些更加强大的 API ；</li><li>浏览器全局对象是 <code>window</code> ，Node.js 全局对象是 <code>global</code> 。</li></ul><p><img src="http://mdimg.95408.com/201912182202_431.png" alt="Node.js与JavaScript"></p><h2 id="Node-js-模块化"><a href="#Node-js-模块化" class="headerlink" title="Node.js 模块化"></a>Node.js 模块化</h2><ul><li>Node.js规定一个 <code>JavaScript</code> 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到；</li><li>模块内部使用 <code>exports</code> 导出对象，在其他模块（文件）中使用 <code>require</code> 导入其他模块；</li></ul><pre><code class="js">a.js文件const add = (n1, n2) =&gt; n1 + n2;  // 一个加法的函数exports.add = add;  // 将函数导出b.js文件const a = require(&#39;./a.js&#39;);  // 导入a.js中的加法函数console.log(a.add(1, 2))  // 使用加法函数得到3</code></pre><h2 id="npm-工具"><a href="#npm-工具" class="headerlink" title="npm 工具"></a>npm 工具</h2><p>npmjs.com 第三方模块管理工具 （node package manager）</p><h3 id="安装模块："><a href="#安装模块：" class="headerlink" title="安装模块："></a>安装模块：</h3><pre><code class="js">本地安装：npm install 模块名称全局安装：npm install 模块名称 -g</code></pre><blockquote><ul><li><strong>本地安装</strong>的第三方模块，只存储在当前项目文件夹 <code>node_modules</code> ，只有本项目能使用，其他项目使用相同模块，需要在其他项目下再次安装；</li><li>命令行工具使用<strong>全局安装</strong>，在其他项目都可以使用；</li></ul></blockquote><h3 id="卸载模块："><a href="#卸载模块：" class="headerlink" title="卸载模块："></a>卸载模块：</h3><pre><code class="js">npm uninstall 模块名</code></pre><h2 id="nodemon-模块"><a href="#nodemon-模块" class="headerlink" title="nodemon 模块"></a>nodemon 模块</h2><p>是一个命令行工具，全局安装： <code>npm install nodemon -g</code> ；</p><p>辅助替换node命令，项目更改时，能自动刷新；</p><h2 id="nrm-替换国内镜像源"><a href="#nrm-替换国内镜像源" class="headerlink" title="nrm 替换国内镜像源"></a>nrm 替换国内镜像源</h2><p>nrm 安装： <code>npm install nrm -g</code> ；</p><p>查询下载地址列表：<code>nrm ls</code> ；</p><p>选择国内taobao下载源，加快下载速度：<code>nrm use taobao</code> ；</p><p><img src="http://mdimg.95408.com/201912182305_359.png?null" alt=""></p><h2 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h2><p>node_modules 文件夹中包含了项目中所有的第三方模块，数百个，多而碎；</p><p>依赖关系复杂，不同版本的兼容问题；</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。</p><p>使用 <code>npm init -y</code> 命令生成。</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><p>开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖；</p><p>正常使用 <code>npm install 包名</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;dependencies&quot;: {        &quot;jquery&quot;: &quot;^3.3.1“    } } </code></pre><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><p>开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖；</p><p>命令行加 –save -dev 安装： <code>npm install 包名 --save -dev</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;devDependencies&quot;: {        &quot;gulp&quot;: &quot;^3.9.1“    } } </code></pre><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>  当我们将项目移到其他电脑，由于有了 <code>package.json</code> 和 <code>package-lock.json</code> 文件，不需要拷贝 <code>node_modules</code> 文件夹；</p><p>  只需运行 <code>npm install</code> 即可通过这两个文件，自行下载所需的所有第三方模块。</p></blockquote><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo折腾记录更新</title>
      <link href="/2019/12/18/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/12/18/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>   更新中 …</p></blockquote><hr><h2 id="增加域名，备份git仓库"><a href="#增加域名，备份git仓库" class="headerlink" title="增加域名，备份git仓库"></a>增加域名，备份git仓库</h2><blockquote><p>  20191218</p></blockquote><ul><li>绑定独立域名： <code>halfbamboo.com</code> ；</li><li>新修改的文件备份到 <code>git</code> 仓库： <a href="https://github.com/yuanshengorg/myHexoBlog" target="_blank" rel="noopener">myHexoBlog</a>；</li></ul><hr><h2 id="修改主题及压缩css-js"><a href="#修改主题及压缩css-js" class="headerlink" title="修改主题及压缩css/js"></a>修改主题及压缩css/js</h2><blockquote><p>  20191218</p></blockquote><ul><li>修改博客主题的CSS样式；</li><li>增加 pulyfile.js 压缩 html/css/js；（放弃）</li><li>增加 hexo-neat 插件压缩 css/js；（html未能压缩）</li></ul><p><img src="http://mdimg.95408.com/201912182118_637.png?imageView2/2/w/1200/h/1200" alt="修改后的3-hexo主题"></p><hr><h2 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h2><blockquote><p>  20191217</p></blockquote><ul><li>本地创建hexo博客：<code>d:/hexo</code> ；</li><li>更换主题：<code>hexo-theme-3-hexo</code> ；</li><li>上传至 <code>github.com</code> ： <a href="https://github.com/yuanshengorg/yuanshengorg.github.io" target="_blank" rel="noopener">yuanshengorg.github.io</a> ；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法CSS表现测试</title>
      <link href="/2019/12/18/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/18/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>下载： <code>$ npm install hexo-cli -g</code> 。</p><p>列表： <code>1.</code></p><ol><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ol><p>列表： <code>-</code></p><ul><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ul><p>链接：<code>[]()</code></p><p><a href="http://www.halfbamboo.com" target="_blank" rel="noopener">半根竹子的官方网站</a></p><p>块引用： <code>&gt;</code></p><blockquote><p>  回归20年，背靠<code>祖国</code>、面向世界的澳门特区迎来一次次发展机遇；脚踏实地、开拓进取的澳门创业者站上更为广阔的发展舞台。</p></blockquote><p>水平分割线：<code>------</code></p><hr><p>代码块： </p><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});   // 注释</code></pre><p>图片：</p><p><img src="http://mdimg.95408.com/20191218121717.png" alt="图片说明文字"></p><p>表格：</p><table><thead><tr><th>标题</th><th>标题2</th><th>标题2</th></tr></thead><tbody><tr><td>一</td><td>二</td><td>三</td></tr><tr><td>hello,hello,hello</td><td>python,python,python</td><td>js,js,js</td></tr><tr><td>css,css,css</td><td>html,html,html</td><td>node,node,node</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 vs code 命令快捷键</title>
      <link href="/2019/12/17/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/"/>
      <url>/2019/12/17/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、光标移动到行尾-行首"><a href="#1、光标移动到行尾-行首" class="headerlink" title="1、光标移动到行尾/行首"></a>1、光标移动到行尾/行首</h3><p>当软件自动补全时，我们常常会需要将光标移动到行尾，可以使用 <code>end</code> 键，或者自定义一个更方便的键，比如：<code>Ctrl + ;</code> 。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>END</td><td>cursorEnd   光标移动到行尾</td><td>/</td></tr><tr><td>HOME</td><td>cursorHome   光标移动到行首</td><td>Ctrl + Shift + ;</td></tr><tr><td>无</td><td>cursorLineEnd   光标移动到行尾</td><td>Ctrl + ;</td></tr><tr><td>无</td><td>cursorLineStart   光标移动到行首</td><td>/</td></tr></tbody></table><h3 id="2、选择当前单词"><a href="#2、选择当前单词" class="headerlink" title="2、选择当前单词"></a>2、选择当前单词</h3><p>连续按展开选择，第一次选中当前单词，第二次选择当前行；继续选择当前块；只按一次的话，就是选择当前单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Shift + Alt + Right</td><td>展开选择</td><td>Alt + I</td></tr><tr><td>Shift + Alt + Left</td><td>收起选择</td><td>Alt + O</td></tr></tbody></table><h3 id="3、光标移动到下-上一个单词"><a href="#3、光标移动到下-上一个单词" class="headerlink" title="3、光标移动到下/上一个单词"></a>3、光标移动到下/上一个单词</h3><p>我们需要将光标跳转到下一个单词或者上一个单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Ctrl + Right</td><td>cursorWordEndRight   光标移动到右边单词结尾</td><td>Alt + ;</td></tr><tr><td>Ctrl + Left</td><td>cursorWordStartLeft   光标移动到左边单词开关</td><td>Alt + L</td></tr></tbody></table><h3 id="4、不使用方向键上下移动"><a href="#4、不使用方向键上下移动" class="headerlink" title="4、不使用方向键上下移动"></a>4、不使用方向键上下移动</h3><p>我们要将光标上下移动时，使用上、下按键也是不方便，所以 vim 中使用了 <code>h j k l</code> ；</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>DOWN</td><td>cursorDown   向下移动光标</td><td>Alt + J</td></tr><tr><td>UP</td><td>cursorUp   向上移动光标</td><td>Alt + K</td></tr><tr><td>LEFT</td><td>cursorLeft   向左移动光标</td><td>/</td></tr><tr><td>RIGTH</td><td>cursorRight   向右移动光标</td><td>/</td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912111130_513.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code>![1575993392487](D:\Markdown\css-js-blog\assets\1575993392487.png)</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（一）</title>
      <link href="/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1、数组是一种特殊的变量，它能够一次存放一个以上的值。</p><p>2、数组是一种特殊类型的对象，在 JavaScript 中对数组使用 typeof 运算符会返回 “object”。JavaScript 数组最好以数组来描述。</p><p>4、数组使用数字来访问其“元素”，对象使用名称来访问其“成员”。数组和对象的区别：数组使用数字索引、象使用命名索引。数组是特殊类型的对象，具有数字索引。</p><p><code>var person = [&quot;Bill&quot;, &quot;Gates&quot;, 62];</code> 使用： <code>person[0]</code> </p><p><code>var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:46};</code> 使用： <code>person.firstName</code> </p><p>5、如果希望元素名为字符串（文本）则应该使用对象、如果希望元素名为数字则应该使用数组。</p><p>6、可以在数组保存对象、函数、甚至是数组；</p><p><code>myArray[0] = Date.now;  myArray[1] = myFunction;  myArray[2] = myCars;</code> </p><h3 id="1、定义数组"><a href="#1、定义数组" class="headerlink" title="1、定义数组"></a>1、定义数组</h3><pre><code class="js">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 以逗号隔开；// 最后不要加逗号；// var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);// 尽量不要使用 new Array() ，执行效率更低；</code></pre><h3 id="2、-识别数组"><a href="#2、-识别数组" class="headerlink" title="2、 识别数组"></a>2、 识别数组</h3><pre><code class="js">typeof cars; // 返回 object// typeof 运算符返回 &quot;object&quot;，因为 JavaScript 数组属于对象。Array.isArray(cars); // 返回 true</code></pre><h3 id="3、访问数组元素"><a href="#3、访问数组元素" class="headerlink" title="3、访问数组元素"></a>3、访问数组元素</h3><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);console.log(cars[0]); // Saab</code></pre><h3 id="4、改变数组元素"><a href="#4、改变数组元素" class="headerlink" title="4、改变数组元素"></a>4、改变数组元素</h3><p>通过使用它们的索引号来访问、更改数组元素</p><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);cars[0] = &#39;abc&#39;console.log(cars[0]); // abc</code></pre><h3 id="5、访问完整数组"><a href="#5、访问完整数组" class="headerlink" title="5、访问完整数组"></a>5、访问完整数组</h3><pre><code class="js">var cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars; &lt;p id = &quot;demo&quot; &gt; &lt; /p&gt;//&lt;p id=&quot;demo&quot;&gt;Audi,BMW,porsche&lt;/p&gt;</code></pre><h2 id="数组属性方法"><a href="#数组属性方法" class="headerlink" title="数组属性方法"></a>数组属性方法</h2><h3 id="1、length-属性"><a href="#1、length-属性" class="headerlink" title="1、length 属性"></a>1、length 属性</h3><p>返回数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.length; // 4</code></pre><h3 id="2、length-访问最后一个元素"><a href="#2、length-访问最后一个元素" class="headerlink" title="2、length 访问最后一个元素"></a>2、length 访问最后一个元素</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var first = fruits[0]; // 访问第一个元素var last = fruits[fruits.length - 1]; // Mango// str.length 为长度4，减1表示是索引3（索引从0开始）</code></pre><h3 id="3、push-、length添加元素"><a href="#3、push-、length添加元素" class="headerlink" title="3、push()、length添加元素"></a>3、push()、length添加元素</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// str.length是数组长度，比索引大1（索引从0开始）// 等于在原来最大索引+1的位置添加元素</code></pre><h3 id="4、添加元素时的空位"><a href="#4、添加元素时的空位" class="headerlink" title="4、添加元素时的空位"></a>4、添加元素时的空位</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[6] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// Banana// Orange// Apple// Mango// undefined 添加最高索引的元素可在数组中创建未定义的“洞”：// undefined// Lemon</code></pre><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="1、toString-转为字符串"><a href="#1、toString-转为字符串" class="headerlink" title="1、toString() 转为字符串"></a>1、toString() 转为字符串</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.toString()); // Banana,Orange,Apple,Mangoconsole.log(fruits); // 也可以直接调用// 所有 JavaScript 对象都拥有 toString() 方法。</code></pre><h3 id="2、join-转字符串"><a href="#2、join-转字符串" class="headerlink" title="2、join() 转字符串"></a>2、join() 转字符串</h3><p>类似 toString()，但是您还可以规定分隔符</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.join(&#39;*&#39;)); // Banana*Orange*Apple*Mango</code></pre><h3 id="3、pop-删除最后元素"><a href="#3、pop-删除最后元素" class="headerlink" title="3、pop() 删除最后元素"></a>3、pop() 删除最后元素</h3><p>1、pop() 删除最后元素，返回被删除元素</p><p>2、push() 在最后增加元素，返回数组长度</p><p>3、shift() 删除开始元素，返回被删除元素</p><p>4、unshift() 在开始增加元素，返回数组长度</p><p>返回被删除的值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop()// console.log(fruits.pop()); // Mango// console.log(fruits); // Banana,Orange,Apple</code></pre><h3 id="4、push-在最后增加元素"><a href="#4、push-在最后增加元素" class="headerlink" title="4、push() 在最后增加元素"></a>4、push() 在最后增加元素</h3><p>返回新数组的长度值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var f = fruits.push(&#39;Kiwi&#39;);// console.log(f); // 5// console.log(fruits); // Banana Orange Apple Mango Kiwi</code></pre><h3 id="5、shift-删除第一个元素"><a href="#5、shift-删除第一个元素" class="headerlink" title="5、shift() 删除第一个元素"></a>5、shift() 删除第一个元素</h3><p>返回被“位移出”的字符串</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 返回 &quot;Banana&quot;</code></pre><h3 id="6、unshift-在最前面增加元素"><a href="#6、unshift-在最前面增加元素" class="headerlink" title="6、unshift() 在最前面增加元素"></a>6、unshift() 在最前面增加元素</h3><p>返回新数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 返回 5</code></pre><h3 id="7、delete-删除元素"><a href="#7、delete-删除元素" class="headerlink" title="7、delete 删除元素"></a>7、delete 删除元素</h3><p>使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // 把 fruits 中的首个元素改为 undefined</code></pre><h3 id="8、splice-向数组添加新项"><a href="#8、splice-向数组添加新项" class="headerlink" title="8、splice() 向数组添加新项"></a>8、splice() 向数组添加新项</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi,Apple,Mango</code></pre><p>第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>第二个参数（0）定义应删除多少元素。</p><p>其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>splice() 方法返回一个包含已删除项的数组：</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi// 已删除项： Apple,Mango</code></pre><h3 id="8、splice-删除元素"><a href="#8、splice-删除元素" class="headerlink" title="8、splice() 删除元素"></a>8、splice() 删除元素</h3><p>第一个参数（0）定义新元素应该被添加（接入）的位置。</p><p>第二个参数（1）定义应该删除多个元素。</p><p>其余参数被省略。没有新元素将被添加。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 Banana// 原数组： Banana,Orange,Apple,Mango// 新数组： Orange,Apple,Mangofruits.splice(1, 2); // Banana,Mango</code></pre><h3 id="9、concat-合并、连接数组"><a href="#9、concat-合并、连接数组" class="headerlink" title="9、concat() 合并、连接数组"></a>9、concat() 合并、连接数组</h3><p>concat() 方法不会更改现有数组。它总是返回一个新数组。</p><p>concat() 方法可以使用任意数量的数组参数：</p><p>concat() 方法也可以将值作为参数：</p><pre><code class="js">var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var arr2 = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var arr3 = [&quot;Robin&quot;, &quot;Morgan&quot;];arr1.concat(arr2); // 将arr1 与 arr2 连接在一起arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起arr1.concat([&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]); // 也可以将值作为参数</code></pre><h3 id="10、slice-裁剪新数组"><a href="#10、slice-裁剪新数组" class="headerlink" title="10、slice() 裁剪新数组"></a>10、slice() 裁剪新数组</h3><p>slice() 方法创建新数组。它不会从源数组中删除任何元素。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.slice(1); // Orange,Lemon,Apple,Mangofruits.slice(3); // Apple,Mango</code></pre><p>slice() 可接受两个参数，从开始参数选取元素，直到结束参数（不包括）为止。</p><p>第2个参数可省略，表示从第1个参数往后所有的元素；</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // Orange,Lemon</code></pre><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（二）</title>
      <link href="/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h2><h3 id="1、for循环遍历数组"><a href="#1、for循环遍历数组" class="headerlink" title="1、for循环遍历数组"></a>1、for循环遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (var i = 0; i &lt; fruits.length; i++) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="2、for-in-遍历数组"><a href="#2、for-in-遍历数组" class="headerlink" title="2、for in 遍历数组"></a>2、for in 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (i in fruits) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="3、forEach-遍历数组"><a href="#3、forEach-遍历数组" class="headerlink" title="3、forEach() 遍历数组"></a>3、forEach() 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});// Banana// Orange// Apple// Mango  fruits.forEach(v =&gt; {    console.log(v);});// Banana// Orange// Apple// Mango  </code></pre><p>数组元素和元素索引</p><pre><code class="js">var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    console.log(&#39;数组元素&#39; + value);    console.log(&#39;数组元素索引号&#39; + index);})// 数组元素1// 数组元素索引号0// 数组元素2// 数组元素索引号1// 数组元素3// 数组元素索引号2</code></pre><p>求数组的和</p><pre><code class="js">var sum = 0;var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    sum += value;})console.log(sum); // 6</code></pre><h2 id="二、数组迭代"><a href="#二、数组迭代" class="headerlink" title="二、数组迭代"></a>二、数组迭代</h2><h3 id="1、filter-筛选数组"><a href="#1、filter-筛选数组" class="headerlink" title="1、filter() 筛选数组"></a>1、filter() 筛选数组</h3><p>返回一个新数组，接受 3 个参数：项目值、项目索引、数组本身</p><p>返回大于50的元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value) {    return value &gt;= 50;})console.log(newArr); // [66, 88]</code></pre><p>返回偶数元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr2 = arr.filter(function(value) {    return value % 2 === 0;})console.log(newArr2); // [12, 66, 4, 88]</code></pre><h3 id="2、some-查找满足条件的元素是否存在"><a href="#2、some-查找满足条件的元素是否存在" class="headerlink" title="2、some() 查找满足条件的元素是否存在"></a>2、some() 查找满足条件的元素是否存在</h3><p>filter() 查找满足条件的元素 返回一个 <code>新数组</code> </p><p>some() 查找满足条件的元素是否存在 返回一个 <code>布尔值</code> </p><p>接受 3 个参数： <code>项目值</code> 、 <code>项目索引</code> 、 <code>数组本身</code> </p><p>sonme() 如果查找到第一个满足条件的元素就终止循环，效率更高</p><pre><code class="js">var arr = [10, 30, 4];var flag = arr.some(function(value) {    return value &lt; 3;});console.log(flag); // falsevar arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;];var flag1 = arr1.some(function(value) {    return value == &#39;pink&#39;;});console.log(flag1); // true</code></pre><h3 id="3、forEach-和-some-的区别"><a href="#3、forEach-和-some-的区别" class="headerlink" title="3、forEach() 和 some() 的区别"></a>3、forEach() 和 some() 的区别</h3><p>如果查询数组中唯一的元素, 用some方法更合适</p><p>在 some 里面 遇到 return true 就是终止遍历 迭代效率更高</p><p>在forEach 里面 return 不会终止迭代</p><pre><code class="js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];arr.some(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在 some 里面 return true 就终止遍历 迭代效率更高        return true;    }    console.log(11);    // 11    // 找到了该元素});var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];// 1. forEach迭代 遍历arr.forEach(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在forEach 里面 return 不会终止迭代        return true;    }    console.log(11);})// 11// 找到了该元素// 11// 11</code></pre><h3 id="4、indexOf"><a href="#4、indexOf" class="headerlink" title="4、indexOf()"></a>4、indexOf()</h3><p>在数组中搜索元素值并返回其位置</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); // 0</code></pre><h3 id="5、lastIndexOf"><a href="#5、lastIndexOf" class="headerlink" title="5、lastIndexOf()"></a>5、lastIndexOf()</h3><p>在数组中搜索元素值并返回其位置，从数组结尾开始搜索</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); // 2</code></pre><h3 id="6、find"><a href="#6、find" class="headerlink" title="6、find()"></a>6、find()</h3><p>返回通过测试函数的第一个数组元素的值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.find(function(value) {    return value &gt; 18;})console.log(first); // 25 第一个比18大的值</code></pre><h3 id="7、findIndex"><a href="#7、findIndex" class="headerlink" title="7、findIndex()"></a>7、findIndex()</h3><p>返回通过测试函数的第一个数组元素的索引</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(function(value) {    return value &gt; 18;})console.log(first); // 3 第一个比18大的值的索引号是3</code></pre><h3 id="8、map"><a href="#8、map" class="headerlink" title="8、map()"></a>8、map()</h3><p>对每个数组元素执行函数来创建新数组，不会更改原始数组。</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.map(function(value) {    return value * 2;})console.log(first); // [2, 4, 6] 将每个数组值乘以2</code></pre><h3 id="9、reduce-reduceRight"><a href="#9、reduce-reduceRight" class="headerlink" title="9、reduce() reduceRight()"></a>9、reduce() reduceRight()</h3><p>在每个数组元素上运行函数，以生成（减少它）单个值</p><p>reduceRight() 方法在数组中从左到右工作</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.reduce(function(total, value) {    return total + value;})console.log(first); // 6 总和为6</code></pre><h3 id="10、every"><a href="#10、every" class="headerlink" title="10、every()"></a>10、every()</h3><p>检查所有数组值是否通过测试，返回布尔值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.every(function(value) {    return value &gt; 18;})console.log(first); // false(并非所有元素都大于18)</code></pre><h2 id="三、数组排序"><a href="#三、数组排序" class="headerlink" title="三、数组排序"></a>三、数组排序</h2><h3 id="1、reverse-反转数组"><a href="#1、reverse-反转数组" class="headerlink" title="1、reverse() 反转数组"></a>1、reverse() 反转数组</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // Mango,Apple,Orange,Banana</code></pre><h3 id="2、sort-以字母方式排序"><a href="#2、sort-以字母方式排序" class="headerlink" title="2、sort() 以字母方式排序"></a>2、sort() 以字母方式排序</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // Apple,Banana,Mango,Orange</code></pre><h3 id="3、sort-以数字方式排序"><a href="#3、sort-以数字方式排序" class="headerlink" title="3、sort() 以数字方式排序"></a>3、sort() 以数字方式排序</h3><p>如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b}); // 1,5,10,25,40,100</code></pre><p>通过一个比值函数，对数组进行降序排序。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a}); // 100,40,25,10,5,1</code></pre><h3 id="4、sort-随机排序"><a href="#4、sort-随机排序" class="headerlink" title="4、sort() 随机排序"></a>4、sort() 随机排序</h3><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return 0.5 - Math.random()});// 40,10,5,100,1,25  随机生成排序// 5,40,100,25,1,10</code></pre><h3 id="5、sort-查找最高-最低数组值"><a href="#5、sort-查找最高-最低数组值" class="headerlink" title="5、sort() 查找最高/最低数组值"></a>5、sort() 查找最高/最低数组值</h3><p>升序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b});// 现在 points[0] 包含最低值// 而 points[points.length-1] 包含最高值</code></pre><p>降序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a});// 现在 points[0] 包含最高值// 而 points[points.length-1] 包含最低值</code></pre><h3 id="6、Math-max-apply-查找最高数组值"><a href="#6、Math-max-apply-查找最高数组值" class="headerlink" title="6、Math.max.apply() 查找最高数组值"></a>6、Math.max.apply() 查找最高数组值</h3><p>apply() 第二个参数须是数组，与 <code>Math.max</code> 相结合使用。</p><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> .</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.max.apply(Math, points)var a = Math.max.apply(null, points) // null 也可以console.log(a); // 100</code></pre><h3 id="7、Math-min-apply-查找最低数组值"><a href="#7、Math-min-apply-查找最低数组值" class="headerlink" title="7、Math.min.apply() 查找最低数组值"></a>7、Math.min.apply() 查找最低数组值</h3><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> 。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.min.apply(Math, points)console.log(a); // 1</code></pre><p><img src="http://mdimg.95408.com/20191213144049.png" alt="20191213144049"></p><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github</title>
      <link href="/2019/12/17/tools/git%E5%92%8Cgithub/"/>
      <url>/2019/12/17/tools/git%E5%92%8Cgithub/</url>
      
        <content type="html"><![CDATA[<h1 id="git-本地仓库"><a href="#git-本地仓库" class="headerlink" title="git 本地仓库"></a>git 本地仓库</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>Git 使用前配置</strong></p><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名： <code>git config --global user.name 提交人姓名</code> </li><li>配置提交人姓名： <code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息： <code>git config --list</code> </li></ol><p><strong>提交步骤</strong></p><ol><li><code>git init</code> 初始化git仓库</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件/提交到暂存区</li><li><code>git commit -m 提交信息</code> 向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><p><strong>撤销</strong></p><ul><li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code> </li><li>将文件从暂存区中删除： <code>git rm --cached 文件</code> </li><li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录： <code>git rest --hard commitID</code> （ID号可以通过 <code>git log</code> 查看） </li></ul><p><strong>分支命令</strong></p><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 来源分支</code> 合并分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><p><strong>暂时保存更改</strong></p><ul><li>存储临时改动： <code>git stash</code> </li><li>恢复改动： <code>git stash pop</code> </li></ul><h2 id="创建-git-init"><a href="#创建-git-init" class="headerlink" title="创建 git init"></a>创建 git init</h2><p>进入到一个目标管理文件夹，输入 <code>init</code> 命令创建完成；</p><pre><code class="git">$ git init  // 初始化工作区，创建.git的隐藏文件夹</code></pre><h2 id="保存-git-add-commit"><a href="#保存-git-add-commit" class="headerlink" title="保存 git add / commit"></a>保存 git add / commit</h2><p>保存一个文件的版本：</p><pre><code class="git">$ git add code1.py   // 保存到暂存区$ git commit -m &#39;这是第一个版本&#39;   // 保存到本地文件库</code></pre><p>再保存一个文件的另一个版本：</p><pre><code class="git">$ git add code1.py$ git commit -m &#39;这是第二个版本&#39;</code></pre><p>将工作区所有文件保存到暂存区：</p><pre><code class="git">$ git add .</code></pre><h2 id="查看版本-git-log"><a href="#查看版本-git-log" class="headerlink" title="查看版本 git log"></a>查看版本 git log</h2><p>查看文件多个版本：</p><pre><code class="git">$ git logcommit 699977fa2a89db2dabc8bf9c1d2e17f23dc4a73f (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 15:02:37 2019 +0800    &#39;这是第二个版本。&#39;commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>以简短形式显示：</p><pre><code class="git">$ git log --pretty=oneline</code></pre><p>ps.win窗口使用命令行<strong>不能显示中文字符</strong>：</p><p>使用 <code>Git Bash</code> 窗口，右键设置–文本设置为 <code>zh_ch UTF-8</code> 退出重新进入即可。</p><h2 id="回退-git-reset"><a href="#回退-git-reset" class="headerlink" title="回退 git reset"></a>回退 git reset</h2><p>回到第一个版本：</p><p>HEAD^ 前一个版本；HEAD^^ 前两个版本；HEAD<del>1 前一个版本；HEAD</del>100 前100个版本；</p><pre><code class="git">$ git reset --hard HEAD^commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154 (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>通过版本号回到第二个版本：</p><pre><code class="git">$ git reset --hard 6999HEAD is now at 699977f &#39;这是第二个版本。&#39;</code></pre><p>如果退回到第一版本记录后，即出终端就找不到第二版本的版本号时，我们可以使用 <code>git reflog</code> 查看操作记录，得到最前面的版本号；如下， <code>699977f</code> 就是第二个版本的版本号。</p><pre><code class="git">$ git reflog699977f (HEAD -&gt; master) HEAD@{0}: reset: moving to 6999325e516 HEAD@{1}: reset: moving to HEAD^699977f (HEAD -&gt; master) HEAD@{2}: commit: &#39;这是第二个版本。&#39;325e516 HEAD@{3}: commit (initial): &#39;这是第一个版本。&#39;</code></pre><h2 id="工作区-暂存区"><a href="#工作区-暂存区" class="headerlink" title="工作区 暂存区"></a>工作区 暂存区</h2><p>保存文件的 git_test 是工作区；</p><p>git_test 文件夹下的 .git 文件夹是版本库；其中包含暂存区；</p><p>git add 将文件添加到暂存区； git commit 把暂存区所有内容提交到当前分支，创建版本记录；</p><pre><code class="git">$ git add XXX$ git commit -m 保存到本地文件库要增加的说明文字</code></pre><p>查看未处理提交的文件状态：</p><pre><code class="git">$ git status</code></pre><h2 id="撤销修改-git-checkout"><a href="#撤销修改-git-checkout" class="headerlink" title="撤销修改 git checkout"></a>撤销修改 git checkout</h2><p>文件没有保存到暂存区时，取消修改：</p><pre><code class="git">git checkout -- code2.txt</code></pre><p>文件通过git add code2.txt 保存到了暂存区，取消修改：</p><pre><code class="git">git reset HEAD code2.txt  # 先取消暂存git checkout -- code2.txt # 和上一步一样，取消修改</code></pre><p>如果已经提交到了版本库（git commit -m ‘版本4’），就通过版本回退</p><pre><code class="git">$ git reset --hard HEAD^</code></pre><h2 id="查看不同-git-diff"><a href="#查看不同-git-diff" class="headerlink" title="查看不同 git diff"></a>查看不同 git diff</h2><p>查看工作区与之前版本的不同：</p><pre><code class="git">$ git diff HEAD -- code1.py</code></pre><p>查看上个版本和上上个版本的不同：</p><pre><code class="git">$ git diff Head HEAD^ -- code1.py</code></pre><h2 id="删除文件-git-rm"><a href="#删除文件-git-rm" class="headerlink" title="删除文件 git rm"></a>删除文件 git rm</h2><pre><code class="git">git add code2.txt  # 文件提交到了暂存区rm code2.txt  # 工作区删除文件git rm code2.txt # 将删除提交到暂存区git commit -m &#39;删除后提交的版本&#39;  # 将删除后提交一个版本# 删除后恢复与撤销修改相同</code></pre><h2 id="切换分支-git-branch"><a href="#切换分支-git-branch" class="headerlink" title="切换分支 git branch"></a>切换分支 git branch</h2><p>查看当前所有分支：git branch</p><pre><code class="git">$ git branch* master</code></pre><p>创建分支：git branch dev</p><pre><code class="git">// 创建新分支后：$ git branch* master  // 当前分支  dev  // 新创建的分支</code></pre><p>切换分支：git checkout dev</p><pre><code class="git">// 切换分支后：$ git branch  master* dev  // 当前分支为dev</code></pre><p>创建并切换分支：git checkout -b dev</p><pre><code class="git">$ git checkout -b dev$ git branch* dev  master</code></pre><p>切换回master分支：git checkout master</p><pre><code class="git">$ git checkout master$ git branch  dev* master</code></pre><p>在dev分支上做修改并提交后，可以切换到master分支，并使用以下方式合并dev分支；</p><h2 id="合并分支-git-merge"><a href="#合并分支-git-merge" class="headerlink" title="合并分支 git merge"></a>合并分支 git merge</h2><p>回到主分支master上，合并dev分支：git merge dev</p><pre><code class="git">$ git merge dev</code></pre><h2 id="删除分支-git-branch"><a href="#删除分支-git-branch" class="headerlink" title="删除分支 git branch"></a>删除分支 git branch</h2><p>分支上所有内容都合并到主分支时，可以删除分支：git branch -d dev</p><pre><code class="git">$ git branch -d dev// 如果没有合并子分支上的内容，并需要强制合并，改成大写 -D</code></pre><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>当切换到dev分支修改code.txt并提交add、commit；</p><p>又切换回master分支修改code.txt并提交add、commit；</p><p>将dev分支合并到master时（git merge dev），会出现冲突；</p><p>（现在在master分支当中），手动修改code.txt冲突文件，并再次add、commit提交；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>当在dev分支修改一个文件，并提交commit；</p><p>又在master分支增加一个新文件，并提交commit；</p><p>此时，在两个不同分支下有两个不同的提交；</p><p>此时合并时，git会提示输入一个分支注释文字，并自动创建一个新的分支；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="禁用快速合并-–no-ff"><a href="#禁用快速合并-–no-ff" class="headerlink" title="禁用快速合并 –no-ff"></a>禁用快速合并 –no-ff</h2><p>在dev分支上做了修改并提交一个分支为“dev分支”；</p><p>切换回master分支，将dev分支合并：</p><pre><code class="git">$ git merge dev</code></pre><p>无冲突时，git会使用快速合并 <code>Fast forward</code> ，如果我们要保存分支信息时，需要禁止快速合并；</p><pre><code class="git">$ git merge --no-ff -m &#39;禁用fast forward版本&#39; dev</code></pre><p>此时，原来dev创建的“dev分支”会保留下来，</p><p>并会创建一个新的分支：“禁用fast forward版本”；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p><strong>禁用快速合并的情况</strong></p><p>当我们在dev分支进行工作时，需要临时进入一个临时分支进行bug处理；</p><p>可以先将当前分支存储起来：</p><pre><code class="git">git stash</code></pre><p>此时我们使用 <code>git status</code> 查看，变成了干净的工作区；</p><p>切换回master分支：git checkout master</p><p>创建一个临时分支：bug-001；</p><p>修改bug完成，提交commit一个“修改bug-001版本”；</p><p>切换回master分支；</p><p>此时如果直接合并分支，就没有修改bug-001版本的记录；</p><p>我们就采用禁用快速合并的处理方式；</p><p>合并临时分支：bug-001；</p><pre><code class="git">git merge --no-ff -m &quot;修复bug后的版本&quot; bug-001</code></pre><h2 id="存储工作现场-git-stash-暂时保存更改"><a href="#存储工作现场-git-stash-暂时保存更改" class="headerlink" title="存储工作现场 git stash 暂时保存更改"></a>存储工作现场 git stash 暂时保存更改</h2><p>当我们在dev分支上工作时，需要临时进入master分支上做修改，</p><p>只需在分支上临时保存，再进入master分支操作保存。</p><p>返回dev分支上重新开始工作。</p><pre><code class="git">git stash  // 当前在dev分支，暂存文件$ git statusOn branch dev  // 当前在dev分支nothing to commit, working tree clean  // 暂存文件后，分支变干净了</code></pre><p>回到master分支，进行bug修改，保存：</p><pre><code class="git">git checkout master</code></pre><p>查看存储的工作记录：</p><pre><code class="git">git stash list</code></pre><p>在master分支上完成操作后，返回到dev分支上，恢复工作记录：</p><pre><code class="git">git checkout dev   // 返回dev分支git stash pop   // 恢复工作记录</code></pre><h1 id="github-远程仓库"><a href="#github-远程仓库" class="headerlink" title="github 远程仓库"></a>github 远程仓库</h1><p><img src="http://mdimg.95408.com/201912171203_333.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="1、-A-将新项目-push-至-github"><a href="#1、-A-将新项目-push-至-github" class="headerlink" title="1、  A 将新项目 push 至 github"></a>1、  A 将新项目 push 至 github</h2><p>(1)、A 将地址文件夹1215_git中的项目修改完成，保存到本地仓库；</p><p>(2)、A 在 github.com 上创建一个新项目：1215_git；并得到了项目远程地址： <code>https://github.com/yuanshengorg/1215_git.git</code> 。</p><p>(3)、A 将本地项目 push 至远程仓库：master 表示本地仓库的分支；</p><pre><code class="git">$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>将远程地址改为简短别名：</p><pre><code class="git">$ git remote add origin https://github.com/yuanshengorg/1215_git.gitorigin 表示将远程地址改为的别名</code></pre><p>通过别名推送到远程仓库：</p><pre><code class="git">$ git push origin master</code></pre><p>在第一次推送时，加上 -u 记录：</p><pre><code class="git">$ git push -u origin master</code></pre><p>下一次推送可以更简单：</p><pre><code class="git">$ git push</code></pre><h2 id="2、-B-将项目-clone-到-本地"><a href="#2、-B-将项目-clone-到-本地" class="headerlink" title="2、 B 将项目 clone 到 本地"></a>2、 B 将项目 clone 到 本地</h2><p>在网站上获取 Clone 地址：</p><p><img src="http://mdimg.95408.com/201912171139_943.png?imageView2/2/w/1200/h/1200" alt=""></p><p>克隆远端数据仓库到本地： <code>git clone 仓库地址</code> </p><pre><code class="git">git clone https://github.com/yuanshengorg/1215_git.git</code></pre><h2 id="3、-B-将项目修改后-push-至-github"><a href="#3、-B-将项目修改后-push-至-github" class="headerlink" title="3、 B 将项目修改后 push 至 github"></a>3、 B 将项目修改后 push 至 github</h2><p>B 将项目克隆到本地后，直接在本地修改，add 至暂存区，commit 至本地仓库；</p><p>完成修改，上传到 A 创建的项目远程仓库：</p><pre><code class="git">$ git push origin master   // A 创建的远程地址别名 B 也可以使用或者：$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>B 如果想摄推送内容至 A 的仓库，需要 A 设置一下：邀请 B 为团队成员。</p><p><img src="http://mdimg.95408.com/201912171157_660.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="4、-A-拉取远程仓库中最新的版本"><a href="#4、-A-拉取远程仓库中最新的版本" class="headerlink" title="4、 A 拉取远程仓库中最新的版本"></a>4、 A 拉取远程仓库中最新的版本</h2><p>拉取远程仓库中最新的版本： <code>git pull 远程仓库地址 分支名称</code> </p><pre><code class="git">$ git pull origin master或者：$ git pull https://github.com/yuanshengorg/1215_git.git master</code></pre><p>git clone 是完全克隆；</p><p>git pull 是本地已有项目，只拉取远程仓库中更新的内容；</p><h2 id="SSH-推送"><a href="#SSH-推送" class="headerlink" title="SSH 推送"></a>SSH 推送</h2><p><img src="http://mdimg.95408.com/201912171137_313.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code class="git">$ ssh-keygen</code></pre><p>会在本地（/c/Users/用户名/.ssh/）生成：id_rsa 文件和 id_rsa.pub 文件；</p><p>将 <code>id_rsa.pub</code> 文件打开复制内容设置到 github.com 网站上，即可。</p><p>github.com ——右上角个人中心——settings——SSH and GPG keys——SSH keys，新增保存即可。</p><p><img src="http://mdimg.95408.com/201912171135_162.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="跨团队合作："><a href="#跨团队合作：" class="headerlink" title="跨团队合作："></a>跨团队合作：</h2><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h2 id="忽略清单文件创建："><a href="#忽略清单文件创建：" class="headerlink" title="忽略清单文件创建："></a>忽略清单文件创建：</h2><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>git忽略清单文件名称：<strong>.gitignore</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo创建博客</title>
      <link href="/2019/12/17/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/17/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912180011_408.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="node-js-和-npm"><a href="#node-js-和-npm" class="headerlink" title="node.js 和 npm"></a>node.js 和 npm</h3><p>Hexo是基于nodejs的静态博客，首先需要安装nodejs，并且需要nodejs中的重要工具：<code>npm</code> ；</p><p>查看 nodejs 版本：<code>node -V</code> ；</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>有了nodejs，其他就简单了！安装hexo： <code>npm install -g hexo</code> ；</p><p>查看 hexo 版本： <code>hexo -v</code> ；</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>你也可以安装一个必备的代码管理工具：<code>git</code> ；这样我们就可以使用 <code>git bash</code> 这个工具了；</p><p>查看 git 版本： <code>git version</code> ；</p><h2 id="创建-hexo"><a href="#创建-hexo" class="headerlink" title="创建 hexo"></a>创建 hexo</h2><p>我们在本地创建一个文件夹 <code>d\hexo</code> 做为博客的目录；</p><p>只需3步，完成博客的搭建：</p><p>1、在 <code>d\hexo</code>目录下，执行以下命令，创建 hexo 完成；</p><pre><code class="git">hexo init</code></pre><p>2、开始书写文章：</p><pre><code class="git">hexo new &#39;我的第一篇hexo博客文章&#39;</code></pre><p>3、运行本地博客服务器：</p><pre><code class="git">$ hexo s    INFO  Start processing    INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>此时，我们在浏览器当中输入：<code>http://local:4000</code> 即可查看网站。</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>使用以下命令创建文章，我们就可以通过 <code>D:\hexo\source\_posts</code> 查看创建的文件，开始创作即可。</p><pre><code class="git">$ hexo new [layout] &lt;title&gt;</code></pre><p>或者直接将md文章放入到 <code>D:\hexo\source\_posts</code> 目录下；</p><h2 id="文章预定义参数"><a href="#文章预定义参数" class="headerlink" title="文章预定义参数"></a>文章预定义参数</h2><p>我们在md文章形状，使用yaml定义标题、分类、标签、日期等等，可以自己增减。</p><pre><code class="yaml">---title: 文章标题date： 日期categories: 分类tags: 标签---</code></pre><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">官方文档：更多预先定义的参数</a></p><p>如果是有子分类：</p><pre><code class="yaml">categories: [父分类， 子分类]</code></pre><p>如果是有多个标签：</p><pre><code class="yaml">tags: [标签1， 标签2]</code></pre><h2 id="搭建到-github"><a href="#搭建到-github" class="headerlink" title="搭建到 github"></a>搭建到 github</h2><p>1、创建 github 账号，并创建 ssh （参考：<a href="https://yuanshengorg.github.io/2019/12/17/tools/git%E5%92%8Cgithub/#SSH-%E6%8E%A8%E9%80%81" target="_blank" rel="noopener">git和github：SSH</a>）； </p><p>2、在自己的账号下，新建一个repo：<code>New repository</code> （github右上角 + 号——New repository）；</p><p>3、项目名称（Repository name）为：<code>你的名称.github.io</code> ，如 <code>yuansheng.github.io</code>；</p><p><img src="http://mdimg.95408.com/201912172352_728.png?imageView2/2/w/1200/h/1200" alt=""></p><p>4、回到本地文件夹：<code>d/hexo</code> ，修改文件： <code>_config.yml</code> ：</p><pre><code class="git">deploy:  type: git  repo: https://github.com/yuansheng/yuansheng.github.io.git  branch: master</code></pre><p>repo 请修改为你创建的地址。</p><p>5、安装工具：hexo-deployer-git</p><pre><code class="git">npm install hexo-deployer-git --save</code></pre><p>6、回到命令行工具运行：</p><pre><code class="git">hexo clean // 清除之前生成的文件hexo generate   // 生成新的静态文件hexo depoly   // 部署网站</code></pre><p>执行 <code>hexo depoly</code> 时，第一次可能会需要注册 github.com 的账号及密码；</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>输入 <code>yuansheng.github.io</code> ，即你设置的项目文件名，即可访问网站；</p><p>你也可以绑定自己的域名，如 <code>www.yuanblogname.com</code>；</p><h2 id="增-改文章"><a href="#增-改文章" class="headerlink" title="增/改文章"></a>增/改文章</h2><p>上面的三个命令 <code>hexo clean / generate / depoly</code> 可简写为：</p><pre><code class="git">hexo cleanhexo ghexo d</code></pre><p>以后每次在文件夹中增加、修改了 md 文章后，执行这三个命令即可；</p><p>所有在本地电脑上修改的文档，远程博客也就修改了。</p><h2 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo官方文档：指令</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档：中文</a></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
