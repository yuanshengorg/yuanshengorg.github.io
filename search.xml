<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(2)Css3动画、2D、3D</title>
      <link href="/2019/12/19/css/Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/"/>
      <url>/2019/12/19/css/Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/</url>
      
        <content type="html"><![CDATA[<h2 id="2D转换-transform"><a href="#2D转换-transform" class="headerlink" title="2D转换 transform"></a>2D转换 transform</h2><p>2D 转换是改变标签在二维平面上的位置和形状</p><ul><li>移动： <code>translate</code></li><li>旋转： <code>rotate</code></li><li>缩放： <code>scale</code></li></ul><h3 id="translate-移动"><a href="#translate-移动" class="headerlink" title="translate 移动"></a>translate 移动</h3><ul><li><code>translate</code> 最大的优点就是不影响其他元素的位置</li><li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li></ul><pre><code class="css">transform: translate(x, y)transform: translateX(n)transfrom: translateY(n)</code></pre><ul><li>行内标签没有效果</li></ul><pre><code class="css">div {  background-color: lightseagreen;  width: 200px;  height: 100px;  /* 水平垂直移动 100px */  /* transform: translate(100px, 100px); */  /* 水平移动 100px */  /* transform: translate(100px, 0) */  /* 垂直移动 100px */  /* transform: translate(0, 100px) */  /* 水平移动 100px */  /* transform: translateX(100px); */  /* 垂直移动 100px */  transform: translateY(100px)}</code></pre><h3 id="例：让盒子水平垂直居中"><a href="#例：让盒子水平垂直居中" class="headerlink" title="例：让盒子水平垂直居中"></a>例：让盒子水平垂直居中</h3><pre><code class="html">&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;style&gt;    div {        position: relative;        width: 500px;        height: 500px;        background-color: red;    }    p {        position: absolute;        top: 50%;        left: 50%;        /* 原来的办法：计算返回原元素的一半 */        /* margin-top: -100px; */        /* margin-left: -100px; */        /* translate(-50%, -50%)  盒子往上走自己高度的一半 */        transform: translate(-50%, -50%);        width: 200px;        height: 200px;        background-color: burlywood;    }&lt;/style&gt;</code></pre><h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><pre><code class="css">/* 单位是：deg */transform: rotate(度数如180deg) </code></pre><ul><li><code>rotate</code> 里面跟度数，单位是 <code>deg</code></li><li>角度为正时，顺时针，角度为负时，逆时针</li><li>默认旋转的中心点是元素的中心点</li></ul><pre><code class="html">&lt;style&gt;    div {        width: 200px;        height: 100px;        background-color: red;    }    div:hover {        transform: rotate(90deg);        /* 鼠标移动时顺时针转90度 */    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h3 id="例：图标360度旋转"><a href="#例：图标360度旋转" class="headerlink" title="例：图标360度旋转"></a>例：图标360度旋转</h3><pre><code class="html">&lt;style&gt;    img {        width: 200px;        height: 200px;        background-color: pink;        border: pink solid 1px;        border-radius: 50%;        transition: all 0.3s;    }    img:hover {        transform: rotate(180deg);    }&lt;/style&gt;&lt;body&gt;    &lt;img src=&quot;media/pic.jpg&quot; alt=&quot;&quot;&gt;&lt;/body&gt;</code></pre><h3 id="例：制作上下-gt-符号"><a href="#例：制作上下-gt-符号" class="headerlink" title="例：制作上下  &gt; 符号"></a>例：制作上下  &gt; 符号</h3><p><img src="D:%5Chexo%5Csource_posts%5Ccss%5Cassets%5C201912192235_205.png" alt=""></p><pre><code class="html">&lt;style&gt;    div {        position: relative;        width: 249px;        height: 35px;        border: 1px solid #333;    }    div::after {        content: &quot;&quot;;        position: absolute;        top: 10px;        right: 10px;        /* 创建一个只有两边边框的方形 */        width: 10px;        height: 10px;        border-right: 1px solid #333;        border-bottom: 1px solid #333;        /* 将方形旋转45度 */        transform: rotate(45deg);        transition: all .2s;    }    /* 是鼠标经过div时，::after变动效果 */    div:hover::after {        transform: rotate(225deg);        top: 15px;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="旋转中心点-transform-origin"><a href="#旋转中心点-transform-origin" class="headerlink" title="旋转中心点 transform-origin"></a>旋转中心点 transform-origin</h3><pre><code class="css">transform-origin: x y;div {    width: 200px;    height: 200px;    background-color: pink;    margin: 100px auto;    transition: all 1s;    /* 1.可以跟方位名词 */    /* transform-origin: left bottom; */    /* 2. 默认的是 50%  50%  等价于 center  center */    /* 3. 可以是px 像素 */    transform-origin: 50px 50px;}</code></pre><ul><li>注意后面的参数 x 和 y 用空格隔开</li><li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code></li><li>还可以给 x y 设置像素或者方位名词(<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>、<code>center</code>)</li></ul><h3 id="例：图片从左下角旋转上升"><a href="#例：图片从左下角旋转上升" class="headerlink" title="例：图片从左下角旋转上升"></a>例：图片从左下角旋转上升</h3><p><img src="http://mdimg.95408.com/2019121901.gif" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* 隐藏div外的after中的内容 */        overflow: hidden;        position: relative;        width: 300px;        height: 200px;        border: 1px solid #333;        margin: 10px;        float: left;    }    img {        position: absolute;        top: 0;        left: 0;        width: 300px;        height: 200px;        /* 以左 下 角为基点，旋转180度，看不看的状态 */        transform: rotate(100deg);        transform-origin: left bottom;        transition: all .2s;    }    div:hover img {        /* 鼠标移动，图片旋转到div内 */        transform: rotate(0deg);    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><pre><code class="css">transform: scale(x, y)div:hover {    /* 注意，数字是倍数的含义，所以不需要加单位 */    /* transform: scale(2, 2) */    /* 实现等比缩放，同时修改宽与高 */    /* transform: scale(2) */    /* 小于 1 就等于缩放*/    transform: scale(0.5, 0.5)}</code></pre><ul><li>x 与 y 之间使用逗号进行分隔</li><li><code>transform: scale(1, 1)</code>: 宽高都放大一倍，相当于没有放大</li><li><code>transform: scale(2, 2)</code>: 宽和高都放大了二倍</li><li><code>transform: scale(2)</code>: 如果只写了一个参数，第二个参数就和第一个参数一致</li><li><code>transform:scale(0.5, 0.5)</code>: 缩小</li><li>优势：可以设置转换中心点缩放，默认以中心点缩放，而且<strong>不影响其他盒子</strong></li></ul><h3 id="例：图片放大"><a href="#例：图片放大" class="headerlink" title="例：图片放大"></a>例：图片放大</h3><h3 id="例：分类按钮放大"><a href="#例：分类按钮放大" class="headerlink" title="例：分类按钮放大"></a>例：分类按钮放大</h3><h3 id="2D-转换综合写法-及-顺序"><a href="#2D-转换综合写法-及-顺序" class="headerlink" title="2D 转换综合写法 及 顺序"></a>2D 转换综合写法 及 顺序</h3><ul><li>顺序会影响到转换的效果；</li><li>同时有位置或者其他属性的时候，要将<strong>位移放到最前面</strong> ；</li></ul><pre><code class="css">div:hover {  transform: translate(200px, 0) rotate(360deg) scale(1.2)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(2)Css3动画、2D、3D</title>
      <link href="/2019/12/19/css/(2)Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/"/>
      <url>/2019/12/19/css/(2)Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(1)HTML5+Css3基础</title>
      <link href="/2019/12/19/css/(1)HTML5+Css3%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/19/css/(1)HTML5+Css3%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML新增"><a href="#HTML新增" class="headerlink" title="HTML新增"></a>HTML新增</h2><h2 id="1-1、语义化标签"><a href="#1-1、语义化标签" class="headerlink" title="1.1、语义化标签"></a>1.1、语义化标签</h2><ul><li><code>header</code>   —  头部标签</li><li><code>nav</code>        —  导航标签</li><li><code>article</code> —   内容标签</li><li><code>section</code> —   块级标签</li><li><code>aside</code>     —   侧边栏标签</li><li><code>footer</code>   —   尾部标签</li></ul><blockquote><p>  在 <code>IE9</code> 浏览器中，需要把语义化标签都转换为块级元素语义化标签；</p><p>  在移动端支持比较友好；</p></blockquote><h2 id="1-2、多媒体音频标签"><a href="#1-2、多媒体音频标签" class="headerlink" title="1.2、多媒体音频标签"></a>1.2、多媒体音频标签</h2><h3 id="1-2-1、audio"><a href="#1-2-1、audio" class="headerlink" title="1.2.1、audio"></a>1.2.1、audio</h3><p><img src="http://mdimg.95408.com/201912191818_942.png" alt="audio 的参数"></p><blockquote><p>注意：在 chrome 浏览器中已经禁用了 autoplay 属性</p></blockquote><h3 id="1-2-2、video"><a href="#1-2-2、video" class="headerlink" title="1.2.2、video"></a>1.2.2、video</h3><pre><code class="html">&lt;body&gt;  &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;  &lt;!-- 多个视频格式支持不同浏览器 --&gt;  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;  &lt;/video&gt;&lt;/body&gt;</code></pre><blockquote><p>谷歌浏览器禁用了自动播放功能，解决办法：需要添加 <strong>muted</strong> 属性</p></blockquote><p><img src="http://mdimg.95408.com/201912191820_561.png?null" alt="video 参数"></p><h2 id="1-3、input-标签"><a href="#1-3、input-标签" class="headerlink" title="1.3、input 标签"></a>1.3、input 标签</h2><p>tel只能输入电话；search能直接删除搜索数据；</p><p><img src="http://mdimg.95408.com/201912191824_8.png?null" alt="新增 input 标签"></p><h2 id="1-4、表单属性"><a href="#1-4、表单属性" class="headerlink" title="1.4、表单属性"></a>1.4、表单属性</h2><p>placeholder：表单中增加一行提示文本，获得焦点时消失；</p><p><img src="http://mdimg.95408.com/201912191826_338.png?null" alt="新增表单属性"></p><h2 id="Css3-新增"><a href="#Css3-新增" class="headerlink" title="Css3 新增"></a>Css3 新增</h2><h2 id="2-1、属性选择器"><a href="#2-1、属性选择器" class="headerlink" title="2.1、属性选择器"></a>2.1、属性选择器</h2><p><img src="http://mdimg.95408.com/201912191830_587.png?null" alt=""></p><p>1）</p><pre><code class="css">button {    /* 选择所有的button元素 */}button[disabled] {    /* 选择标签中带有disabled属性的button元素 */}</code></pre><p>2）</p><pre><code class="css">input[type=search] {    /* 选择type属性=search的input元素 */}span[class^=black] {    /* 选择class属性 以black开头的 span元素 */}span[class$=black] {    /* 选择class属性 以black结尾的 span元素 */}span[class*=black] {    /* 选择class属性 包含black的 span元素 */}</code></pre><h2 id="2-2、结构伪类选择器"><a href="#2-2、结构伪类选择器" class="headerlink" title="2.2、结构伪类选择器"></a>2.2、结构伪类选择器</h2><p><img src="http://mdimg.95408.com/201912191838_395.png" alt="结构伪类选择器属性列表"></p><h3 id="2-2-1、first-child-last-child"><a href="#2-2-1、first-child-last-child" class="headerlink" title="2.2.1、first-child / last-child"></a>2.2.1、first-child / last-child</h3><pre><code class="css">ul li:first-child {  /* 选择第一个li元素 */}ul li:last-child {  /* 选择最后一个li元素 */}ul li:nth-child(3) {  /* 选择第3个li元素 */}</code></pre><h3 id="2-2-2、nth-child"><a href="#2-2-2、nth-child" class="headerlink" title="2.2.2、nth-child( )"></a>2.2.2、nth-child( )</h3><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td>ul li:nth-child(<strong>even</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>odd</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>2n</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>2n+1</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>5n</strong>) { }</td><td>第5、10、15个</td></tr><tr><td>ul li:nth-child(<strong>3n</strong>) { }</td><td>第3、6、9个</td></tr><tr><td>ul li:nth-child(<strong>n+5</strong>) { }</td><td>从第5个到最后</td></tr><tr><td>ul li:nth-child(<strong>-n+5</strong>) { }</td><td>前面5个</td></tr></tbody></table><blockquote><p>  有时需要将2排各5个div中的最右边2个去除 <code>margin-right</code> 时，可以用 <code>ul li:nth-child(5)</code> 来选择第 5、10个div元素。</p></blockquote><h3 id="2-2-3、nth-child-和-nt-of-type-的区别"><a href="#2-2-3、nth-child-和-nt-of-type-的区别" class="headerlink" title="2.2.3、nth-child 和 nt-of-type 的区别"></a>2.2.3、nth-child 和 nt-of-type 的区别</h3><ul><li>ul中只有li元素时，两都选择相同；</li><li>ul中第一个是p元素，后面是li元素时：<ul><li>nth-child 选择父元素里面的第几个子元素，只要是子元素即可，不管是什么类型；</li><li>nth-of-type 是选择父元素的某一种子元素的第几个；</li></ul></li></ul><pre><code class="css">&lt;body&gt;    &lt;ul&gt;        &lt;p&gt;p&lt;/p&gt;        &lt;li&gt;li 1&lt;/li&gt;        &lt;li&gt;li 2&lt;/li&gt;        &lt;li&gt;li 3&lt;/li&gt;        &lt;li&gt;li 4&lt;/li&gt;        &lt;li&gt;li 5&lt;/li&gt;        &lt;li&gt;li 6&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;style&gt;    ul :nth-child(1){        background-color: red;          /* 选择p */    }    ul li:nth-child(3){        background-color: blue;        /* 选择li 2 */        /* 虽然选择的是li的第3个，但是从第一个子元素p就开始计算 */    }    ul li:nth-of-type(3){        background-color: green;        /* 选择li 3 */    }    ul li:nth-of-type(1){        background-color: hotpink;        /* 选择li 1 */    }&lt;/style&gt;</code></pre><h2 id="2-3、伪元素选择器"><a href="#2-3、伪元素选择器" class="headerlink" title="2.3、伪元素选择器"></a>2.3、伪元素选择器</h2><p><img src="http://mdimg.95408.com/201912191916_205.png?null" alt="伪类选择器"></p><h3 id="2-3-1、注意事项"><a href="#2-3-1、注意事项" class="headerlink" title="2.3.1、注意事项"></a>2.3.1、注意事项</h3><ul><li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li><li><code>before</code> 在内容前面，<code>after</code> 在内容后面</li><li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li><li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li><li>伪元素和标签选择器一样，权重为 1</li></ul><h3 id="2-3-2、增加字体图标"><a href="#2-3-2、增加字体图标" class="headerlink" title="2.3.2、增加字体图标"></a>2.3.2、增加字体图标</h3><pre><code class="css">p {   width: 220px;   height: 22px;   border: 1px solid lightseagreen;   margin: 60px;   position: relative;}p::after {  content: &#39;\ea50&#39;;  font-family: &#39;icomoon&#39;;  position: absolute;  top: -1px;  right: 10px;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js的web服务器http+异步编程</title>
      <link href="/2019/12/19/node/Node.js%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8http+%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/19/node/Node.js%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8http+%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="web-服务器"><a href="#web-服务器" class="headerlink" title="web 服务器"></a>web 服务器</h2><ul><li>创建一个服务器对象app，绑定一个商品号：3000；</li><li>通过后台运行 <code>node app.js</code> ，就创建了一个web服务器；</li><li>浏览器请求这个服务器的地址： <code>localhost:3000</code> 时，服务器就响应一段数据（<code>res.end</code> ）给浏览器；</li></ul><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app  = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // 当浏览器请求时，服务器响应内容给浏览器    res.end(&#39;当你在浏览器输入网址请求本web服务器，就会响应这一些文字&#39;);})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js系统模块 + Gulp</title>
      <link href="/2019/12/18/node/Node.js%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97+Gulp/"/>
      <url>/2019/12/18/node/Node.js%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97+Gulp/</url>
      
        <content type="html"><![CDATA[<h2 id="fs-文件操作"><a href="#fs-文件操作" class="headerlink" title="fs 文件操作"></a>fs 文件操作</h2><pre><code class="js">const fs = require(&#39;fs&#39;);</code></pre><h3 id="fs-readFile-读取文件"><a href="#fs-readFile-读取文件" class="headerlink" title="fs.readFile 读取文件"></a>fs.readFile 读取文件</h3><pre><code class="js">fs.readFile(&#39;文件路径&#39; ，&#39;文件编码可选&#39; ，callback回调函数)；</code></pre><blockquote><p>  callback回调函数的第一个值是错误信息，node.js中都是错误优先的回调函数；</p></blockquote><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的readFile读取文件内容fs.readFile(&#39;./a.txt&#39;, &#39;utf8&#39;, (err, doc) =&gt; {    // 如果读取错误，err包含错误信息    // 反之，err为空    // doc是读取的文件    console.log(err);  // 读取正确，err返回null    console.log(doc);  })</code></pre><h3 id="fs-writeFile-写入文件"><a href="#fs-writeFile-写入文件" class="headerlink" title="fs.writeFile 写入文件"></a>fs.writeFile 写入文件</h3><pre><code class="js">fs.writeFile(&#39;文件路径’， ‘数据’， callback回调函数)；</code></pre><p>如果错误，err返回错误信息；反之，err为null</p><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的writeFile写入内容fs.writeFile(&#39;./b.txt&#39;, &#39;要写入b.txt的数据&#39;, err =&gt; {    // 如果错误，err返回错误信息    // 反之，err为null    // 如果err不为空，打印err信息，return    if(err != null){        console.log(err);        return;    }    // 如果err这空，则证明写入正确    console.log(&#39;数据写入b.txt成功&#39;);})</code></pre><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>进行路径拼接：win\os\lunix的路径符不同，使用路径拼接更安全；</p><p>node中的相对路径，是相对于node系统命令工具所在的目录</p><pre><code class="js">// 调用path模块const path = require(&#39;path&#39;);// 使用path模块进行路径拼接const p = path.join(&#39;public&#39;, &#39;halfbamoo&#39;, &#39;src&#39;);console.log(p);   // public\halfbamoo\src</code></pre><p><code>__dirname</code>为系统绝对路径；</p><pre><code class="js">const pp = path.join(__dirname, &#39;public&#39;, &#39;halfbamboo&#39;, &#39;src&#39;);console.log(pp);  // D:\doc\1218\public\halfbamboo\src</code></pre><h2 id="Gulp-模块"><a href="#Gulp-模块" class="headerlink" title="Gulp 模块"></a>Gulp 模块</h2><p>基于node.js 平台的前端构建工具</p><ul><li>html、css、js文件压缩；</li><li>es6、less语法转换；</li><li>公共文件的抽离；</li><li>修改文件浏览器自动刷新；</li></ul><h3 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h3><p>安装： <code>npm install gulp</code> ，本地安装即可；</p><p>安装： <code>npm install gulp-cli -g</code> ，全局安装gulp命令行工具；</p><p>创建： <code>gulpfile.js</code> 文件写代码；</p><h3 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h3><ul><li>gulp.src()：获取任务要处理的文件</li><li>gulp.dest()：输出文件</li><li>gulp.task()：建立gulp任务</li><li>gulp.watch()：监控文件的变化</li></ul><p>使用gulp将src/css目录下的文件，复制到dist/css目录下：</p><blockquote><p>  建立一个固定名称的文件：<code>gulpfile.js</code> ，敲如下代码，</p><p>  此时，会将原/src/css中的文件，复制到/dist/css目录下，如果目标目录存在，会自动创建；</p></blockquote><pre><code class="js">gulpfile.js:// 调用gulp模块const gulp = require(&#39;gulp&#39;);// 使用gulp.task（任务名称，回调函数）建立任务gulp.task(&#39;first&#39;, () =&gt; {    console.log(&#39;第一个gulp任务&#39;);    // src 获取要处理的文件    gulp.src(&#39;./src/css/a.css&#39;)        // dest 输出文件地址 要放在pipei当中        .pipe(gulp.dest(&#39;./dist/css&#39;));})</code></pre><h3 id="gulp插件-第三方模块"><a href="#gulp插件-第三方模块" class="headerlink" title="gulp插件/第三方模块"></a>gulp插件/第三方模块</h3><ul><li>gulp-htmlmin ：html文件压缩</li><li>gulp-csso ：压缩css</li><li>gulp-babel ：JavaScript语法转化</li><li>gulp-less: less语法转化</li><li>gulp-uglify ：压缩混淆JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><p>安装：</p><pre><code class="js">npm install gulp-htmlminnpm install gulp-file-includenpm install gulp-lessnpm install gulp-cssonpm install gulp-babel @babel/core @babel/preset-env// https://www.npmjs.com/package/gulp-babelnpm install gulp-uglify</code></pre><ul><li>gulp-file-include：源代码中公共样式抽离出来后，使用 <code>@@include(&#39;./common/header.html&#39;)</code> 引入时，使用 gulp-file-include 模块，可以将引入的内容重新生成到一个完整的html页面当中；</li></ul><h3 id="gulpfile-js-创建任务"><a href="#gulpfile-js-创建任务" class="headerlink" title="gulpfile.js 创建任务"></a>gulpfile.js 创建任务</h3><p>压缩html、css、js，处理es6、less语法……</p><p>项目根目录下建立 <code>gulpfile.js</code> 文件；</p><p>源文件：src目录；处理后的文件：dict目录；</p><p>通过以下代码：我们可以：</p><ul><li>将所有html \ css \ js 压缩；</li><li>将 less 语法、es6 语法处理</li><li>将src目录下的所有文件 <strong>经过处理后</strong> 复制到 dist 文件夹</li></ul><pre><code class="js">// 调用gulp模块const gulp = require(&#39;gulp&#39;);// 调用处理htmlconst htmlmin = require(&#39;gulp-htmlmin&#39;);const fileinclude = require(&#39;gulp-file-include&#39;);// 调用处理css lessconst less = require(&#39;gulp-less&#39;);const csso = require(&#39;gulp-csso&#39;);// 调用处理jsconst babel = require(&#39;gulp-babel&#39;);const uglify = require(&#39;gulp-uglify&#39;);// 压缩html任务// 1 压缩html 2 抽取html公共代码gulp.task(&#39;htmlmin&#39;, () =&gt; {    gulp.src(&#39;./src/*.html&#39;)        .pipe(fileinclude())        // 压缩html代码        .pipe(htmlmin({ collapseWhitespace: true}))        .pipe(gulp.dest(&#39;dist&#39;));})// 压缩css 及处理 lessgulp.task(&#39;cssmin&#39;, () =&gt; {    gulp.src([&#39;./src/css/*.css&#39;, &#39;./src/css/*.less&#39;])        // 处理less        .pipe(less())        // 压缩css        .pipe(csso())        .pipe(gulp.dest(&#39;dist/css&#39;));})// 处理es6 及压缩jsgulp.task(&#39;jsmin&#39;, () =&gt; {    gulp.src(&#39;./src/js/*.js&#39;)        // 处理es6语法        .pipe(babel({            // 识别当前运行环境，将代码按当前环境转换            presets: [&#39;@babel/env&#39;]        }))        // 压缩js代码        .pipe(uglify())        .pipe(gulp.dest(&#39;dist/js&#39;));})// 复制其他不需要处理的夹 img / libgulp.task(&#39;copy&#39;, () =&gt; {    gulp.src(&#39;./src/images/*&#39;)        .pipe(gulp.dest(&#39;dist/images&#39;));    gulp.src(&#39;./src/lib/**/*&#39;)        .pipe(gulp.dest(&#39;dist/lib&#39;));})// 构建任务// gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]);gulp.task(&#39;default&#39;, gulp.parallel(&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;, function () {    console.log(&#39;任务完成&#39;);}));// 任务命令：// gulp default 或者 gulp</code></pre><h3 id="gulp3-和-gulp4的区别"><a href="#gulp3-和-gulp4的区别" class="headerlink" title="gulp3 和 gulp4的区别"></a>gulp3 和 gulp4的区别</h3><blockquote><p>  操作时报错：gulp Task function must be specified。</p><p>  gulp 版本的原因！</p></blockquote><p>在Gulp 4中需要使用<code>gulp.series</code>和<code>gulp.parallel</code>，因为gulp任务现在只有两个参数。</p><blockquote><p>  <code>gulp.series</code>：按照顺序执行<br>  <code>gulp.paralle</code>：可以并行计算</p></blockquote><pre><code class="js">gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, function() {  // Do something after a, b, and c are finished.}));gulp.task(&#39;build&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;, function () {  // Build the website.}));gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, gulp.parallel(&#39;styles&#39;,&#39;scripts&#39;, &#39;images&#39;), &#39;b&#39;, &#39;c&#39;, function() {  // Do something after a, b, and c are finished.}));</code></pre><h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><h3 id="当模块拥有路径但没有后缀时"><a href="#当模块拥有路径但没有后缀时" class="headerlink" title="当模块拥有路径但没有后缀时"></a>当模块拥有路径但没有后缀时</h3><pre><code class="js">require(&#39;./find.js&#39;);require(&#39;./find&#39;);</code></pre><ol><li>require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</li><li>如果模块后缀省略，<strong>先找同名JS文件再找同名JS文件夹</strong></li><li>如果找到了同名文件夹，找文件夹中的index.js</li><li>如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件</li><li>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li></ol><h3 id="当模块没有路径且没有后缀时"><a href="#当模块没有路径且没有后缀时" class="headerlink" title="当模块没有路径且没有后缀时"></a>当模块没有路径且没有后缀时</h3><pre><code class="js">require(&#39;find&#39;);</code></pre><ol><li>Node.js会假设它是<strong>系统模块</strong></li><li>Node.js会去node_modules文件夹中</li><li>首先看是否有该名字的JS文件</li><li>再看是否有该名字的文件夹</li><li>如果是文件夹看里面是否有index.js</li><li>如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件</li><li>否则找不到报错</li></ol><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js基础</title>
      <link href="/2019/12/18/node/Node.js%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/18/node/Node.js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912182243_175.png" alt="Node.js"></p><h2 id="常用信息"><a href="#常用信息" class="headerlink" title="常用信息"></a>常用信息</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a></p><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm 官网</a></p><p>win系统中，需要将node.js放入系统环境变量；</p><p>如果不能安装成功，需要以管理员身份运行命令行工具；</p><p>查看 Node.js 版本： <code>node -v</code> ；</p><p>nodejs已经集成了 <code>npm</code> ，查看 npm 版本： <code>npm -v</code> ；</p><h2 id="Node-js-与JavaScript"><a href="#Node-js-与JavaScript" class="headerlink" title="Node.js 与JavaScript"></a>Node.js 与JavaScript</h2><ul><li><strong>Node</strong> 是一个基于 Chrome V8 引擎的 JavaScript <strong>代码运行环境</strong>；</li><li>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境；</li><li>Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境；</li><li>JavaScript 由三部分组成，<strong>ECMAScript</strong>，<strong>DOM</strong>，<strong>BOM</strong> ；</li><li>Node.js是由<strong>ECMAScript</strong>及<strong>Node 环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等等一些更加强大的 API ；</li><li>浏览器全局对象是 <code>window</code> ，Node.js 全局对象是 <code>global</code> 。</li></ul><p><img src="http://mdimg.95408.com/201912182202_431.png" alt="Node.js与JavaScript"></p><h2 id="Node-js-模块化"><a href="#Node-js-模块化" class="headerlink" title="Node.js 模块化"></a>Node.js 模块化</h2><ul><li>Node.js规定一个 <code>JavaScript</code> 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到；</li><li>模块内部使用 <code>exports</code> 导出对象，在其他模块（文件）中使用 <code>require</code> 导入其他模块；</li></ul><pre><code class="js">a.js文件const add = (n1, n2) =&gt; n1 + n2;  // 一个加法的函数exports.add = add;  // 将函数导出b.js文件const a = require(&#39;./a.js&#39;);  // 导入a.js中的加法函数console.log(a.add(1, 2))  // 使用加法函数得到3</code></pre><h2 id="npm-工具"><a href="#npm-工具" class="headerlink" title="npm 工具"></a>npm 工具</h2><p>npmjs.com 第三方模块管理工具 （node package manager）</p><h3 id="安装模块："><a href="#安装模块：" class="headerlink" title="安装模块："></a>安装模块：</h3><pre><code class="js">本地安装：npm install 模块名称全局安装：npm install 模块名称 -g</code></pre><blockquote><ul><li><strong>本地安装</strong>的第三方模块，只存储在当前项目文件夹 <code>node_modules</code> ，只有本项目能使用，其他项目使用相同模块，需要在其他项目下再次安装；</li><li>命令行工具使用<strong>全局安装</strong>，在其他项目都可以使用；</li></ul></blockquote><h3 id="卸载模块："><a href="#卸载模块：" class="headerlink" title="卸载模块："></a>卸载模块：</h3><pre><code class="js">npm uninstall 模块名</code></pre><h2 id="nodemon-模块"><a href="#nodemon-模块" class="headerlink" title="nodemon 模块"></a>nodemon 模块</h2><p>是一个命令行工具，全局安装： <code>npm install nodemon -g</code> ；</p><p>辅助替换node命令，项目更改时，能自动刷新；</p><h2 id="nrm-替换国内镜像源"><a href="#nrm-替换国内镜像源" class="headerlink" title="nrm 替换国内镜像源"></a>nrm 替换国内镜像源</h2><p>nrm 安装： <code>npm install nrm -g</code> ；</p><p>查询下载地址列表：<code>nrm ls</code> ；</p><p>选择国内taobao下载源，加快下载速度：<code>nrm use taobao</code> ；</p><p><img src="http://mdimg.95408.com/201912182305_359.png?null" alt=""></p><h2 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h2><p>node_modules 文件夹中包含了项目中所有的第三方模块，数百个，多而碎；</p><p>依赖关系复杂，不同版本的兼容问题；</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。</p><p>使用 <code>npm init -y</code> 命令生成。</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><p>开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖；</p><p>正常使用 <code>npm install 包名</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;dependencies&quot;: {        &quot;jquery&quot;: &quot;^3.3.1“    } } </code></pre><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><p>开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖；</p><p>命令行加 –save -dev 安装： <code>npm install 包名 --save -dev</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;devDependencies&quot;: {        &quot;gulp&quot;: &quot;^3.9.1“    } } </code></pre><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>  当我们将项目移到其他电脑，由于有了 <code>package.json</code> 和 <code>package-lock.json</code> 文件，不需要拷贝 <code>node_modules</code> 文件夹；</p><p>  只需运行 <code>npm install</code> 即可通过这两个文件，自行下载所需的所有第三方模块。</p></blockquote><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo折腾记录更新</title>
      <link href="/2019/12/18/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/12/18/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>   更新中 …</p></blockquote><hr><h2 id="增加域名，备份git仓库"><a href="#增加域名，备份git仓库" class="headerlink" title="增加域名，备份git仓库"></a>增加域名，备份git仓库</h2><blockquote><p>  20191218</p></blockquote><ul><li>绑定独立域名： <code>halfbamboo.com</code> ；</li><li>新修改的文件备份到 <code>git</code> 仓库： <a href="https://github.com/yuanshengorg/myHexoBlog" target="_blank" rel="noopener">myHexoBlog</a>；</li></ul><hr><h2 id="修改主题及压缩css-js"><a href="#修改主题及压缩css-js" class="headerlink" title="修改主题及压缩css/js"></a>修改主题及压缩css/js</h2><blockquote><p>  20191218</p></blockquote><ul><li>修改博客主题的CSS样式；</li><li>增加 pulyfile.js 压缩 html/css/js；（放弃）</li><li>增加 hexo-neat 插件压缩 css/js；（html未能压缩）</li></ul><p><img src="http://mdimg.95408.com/201912182118_637.png?imageView2/2/w/1200/h/1200" alt="修改后的3-hexo主题"></p><hr><h2 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h2><blockquote><p>  20191217</p></blockquote><ul><li>本地创建hexo博客：<code>d:/hexo</code> ；</li><li>更换主题：<code>hexo-theme-3-hexo</code> ；</li><li>上传至 <code>github.com</code> ： <a href="https://github.com/yuanshengorg/yuanshengorg.github.io" target="_blank" rel="noopener">yuanshengorg.github.io</a> ；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法CSS表现测试</title>
      <link href="/2019/12/18/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/18/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>下载： <code>$ npm install hexo-cli -g</code> 。</p><p>列表： <code>1.</code></p><ol><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ol><p>列表： <code>-</code></p><ul><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ul><p>链接：<code>[]()</code></p><p><a href="http://www.halfbamboo.com" target="_blank" rel="noopener">半根竹子的官方网站</a></p><p>块引用： <code>&gt;</code></p><blockquote><p>  回归20年，背靠<code>祖国</code>、面向世界的澳门特区迎来一次次发展机遇；脚踏实地、开拓进取的澳门创业者站上更为广阔的发展舞台。</p></blockquote><p>水平分割线：<code>------</code></p><hr><p>代码块： </p><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});   // 注释</code></pre><p>图片：</p><p><img src="http://mdimg.95408.com/20191218121717.png" alt="图片说明文字"></p><p>表格：</p><table><thead><tr><th>标题</th><th>标题2</th><th>标题2</th></tr></thead><tbody><tr><td>一</td><td>二</td><td>三</td></tr><tr><td>hello,hello,hello</td><td>python,python,python</td><td>js,js,js</td></tr><tr><td>css,css,css</td><td>html,html,html</td><td>node,node,node</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 vs code 命令快捷键</title>
      <link href="/2019/12/17/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/"/>
      <url>/2019/12/17/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、光标移动到行尾-行首"><a href="#1、光标移动到行尾-行首" class="headerlink" title="1、光标移动到行尾/行首"></a>1、光标移动到行尾/行首</h3><p>当软件自动补全时，我们常常会需要将光标移动到行尾，可以使用 <code>end</code> 键，或者自定义一个更方便的键，比如：<code>Ctrl + ;</code> 。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>END</td><td>cursorEnd   光标移动到行尾</td><td>/</td></tr><tr><td>HOME</td><td>cursorHome   光标移动到行首</td><td>Ctrl + Shift + ;</td></tr><tr><td>无</td><td>cursorLineEnd   光标移动到行尾</td><td>Ctrl + ;</td></tr><tr><td>无</td><td>cursorLineStart   光标移动到行首</td><td>/</td></tr></tbody></table><h3 id="2、选择当前单词"><a href="#2、选择当前单词" class="headerlink" title="2、选择当前单词"></a>2、选择当前单词</h3><p>连续按展开选择，第一次选中当前单词，第二次选择当前行；继续选择当前块；只按一次的话，就是选择当前单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Shift + Alt + Right</td><td>展开选择</td><td>Alt + I</td></tr><tr><td>Shift + Alt + Left</td><td>收起选择</td><td>Alt + O</td></tr></tbody></table><h3 id="3、光标移动到下-上一个单词"><a href="#3、光标移动到下-上一个单词" class="headerlink" title="3、光标移动到下/上一个单词"></a>3、光标移动到下/上一个单词</h3><p>我们需要将光标跳转到下一个单词或者上一个单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Ctrl + Right</td><td>cursorWordEndRight   光标移动到右边单词结尾</td><td>Alt + ;</td></tr><tr><td>Ctrl + Left</td><td>cursorWordStartLeft   光标移动到左边单词开关</td><td>Alt + L</td></tr></tbody></table><h3 id="4、不使用方向键上下移动"><a href="#4、不使用方向键上下移动" class="headerlink" title="4、不使用方向键上下移动"></a>4、不使用方向键上下移动</h3><p>我们要将光标上下移动时，使用上、下按键也是不方便，所以 vim 中使用了 <code>h j k l</code> ；</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>DOWN</td><td>cursorDown   向下移动光标</td><td>Alt + J</td></tr><tr><td>UP</td><td>cursorUp   向上移动光标</td><td>Alt + K</td></tr><tr><td>LEFT</td><td>cursorLeft   向左移动光标</td><td>/</td></tr><tr><td>RIGTH</td><td>cursorRight   向右移动光标</td><td>/</td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912111130_513.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code>![1575993392487](D:\Markdown\css-js-blog\assets\1575993392487.png)</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（一）</title>
      <link href="/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1、数组是一种特殊的变量，它能够一次存放一个以上的值。</p><p>2、数组是一种特殊类型的对象，在 JavaScript 中对数组使用 typeof 运算符会返回 “object”。JavaScript 数组最好以数组来描述。</p><p>4、数组使用数字来访问其“元素”，对象使用名称来访问其“成员”。数组和对象的区别：数组使用数字索引、象使用命名索引。数组是特殊类型的对象，具有数字索引。</p><p><code>var person = [&quot;Bill&quot;, &quot;Gates&quot;, 62];</code> 使用： <code>person[0]</code> </p><p><code>var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:46};</code> 使用： <code>person.firstName</code> </p><p>5、如果希望元素名为字符串（文本）则应该使用对象、如果希望元素名为数字则应该使用数组。</p><p>6、可以在数组保存对象、函数、甚至是数组；</p><p><code>myArray[0] = Date.now;  myArray[1] = myFunction;  myArray[2] = myCars;</code> </p><h3 id="1、定义数组"><a href="#1、定义数组" class="headerlink" title="1、定义数组"></a>1、定义数组</h3><pre><code class="js">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 以逗号隔开；// 最后不要加逗号；// var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);// 尽量不要使用 new Array() ，执行效率更低；</code></pre><h3 id="2、-识别数组"><a href="#2、-识别数组" class="headerlink" title="2、 识别数组"></a>2、 识别数组</h3><pre><code class="js">typeof cars; // 返回 object// typeof 运算符返回 &quot;object&quot;，因为 JavaScript 数组属于对象。Array.isArray(cars); // 返回 true</code></pre><h3 id="3、访问数组元素"><a href="#3、访问数组元素" class="headerlink" title="3、访问数组元素"></a>3、访问数组元素</h3><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);console.log(cars[0]); // Saab</code></pre><h3 id="4、改变数组元素"><a href="#4、改变数组元素" class="headerlink" title="4、改变数组元素"></a>4、改变数组元素</h3><p>通过使用它们的索引号来访问、更改数组元素</p><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);cars[0] = &#39;abc&#39;console.log(cars[0]); // abc</code></pre><h3 id="5、访问完整数组"><a href="#5、访问完整数组" class="headerlink" title="5、访问完整数组"></a>5、访问完整数组</h3><pre><code class="js">var cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars; &lt;p id = &quot;demo&quot; &gt; &lt; /p&gt;//&lt;p id=&quot;demo&quot;&gt;Audi,BMW,porsche&lt;/p&gt;</code></pre><h2 id="数组属性方法"><a href="#数组属性方法" class="headerlink" title="数组属性方法"></a>数组属性方法</h2><h3 id="1、length-属性"><a href="#1、length-属性" class="headerlink" title="1、length 属性"></a>1、length 属性</h3><p>返回数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.length; // 4</code></pre><h3 id="2、length-访问最后一个元素"><a href="#2、length-访问最后一个元素" class="headerlink" title="2、length 访问最后一个元素"></a>2、length 访问最后一个元素</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var first = fruits[0]; // 访问第一个元素var last = fruits[fruits.length - 1]; // Mango// str.length 为长度4，减1表示是索引3（索引从0开始）</code></pre><h3 id="3、push-、length添加元素"><a href="#3、push-、length添加元素" class="headerlink" title="3、push()、length添加元素"></a>3、push()、length添加元素</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// str.length是数组长度，比索引大1（索引从0开始）// 等于在原来最大索引+1的位置添加元素</code></pre><h3 id="4、添加元素时的空位"><a href="#4、添加元素时的空位" class="headerlink" title="4、添加元素时的空位"></a>4、添加元素时的空位</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[6] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// Banana// Orange// Apple// Mango// undefined 添加最高索引的元素可在数组中创建未定义的“洞”：// undefined// Lemon</code></pre><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="1、toString-转为字符串"><a href="#1、toString-转为字符串" class="headerlink" title="1、toString() 转为字符串"></a>1、toString() 转为字符串</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.toString()); // Banana,Orange,Apple,Mangoconsole.log(fruits); // 也可以直接调用// 所有 JavaScript 对象都拥有 toString() 方法。</code></pre><h3 id="2、join-转字符串"><a href="#2、join-转字符串" class="headerlink" title="2、join() 转字符串"></a>2、join() 转字符串</h3><p>类似 toString()，但是您还可以规定分隔符</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.join(&#39;*&#39;)); // Banana*Orange*Apple*Mango</code></pre><h3 id="3、pop-删除最后元素"><a href="#3、pop-删除最后元素" class="headerlink" title="3、pop() 删除最后元素"></a>3、pop() 删除最后元素</h3><p>1、pop() 删除最后元素，返回被删除元素</p><p>2、push() 在最后增加元素，返回数组长度</p><p>3、shift() 删除开始元素，返回被删除元素</p><p>4、unshift() 在开始增加元素，返回数组长度</p><p>返回被删除的值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop()// console.log(fruits.pop()); // Mango// console.log(fruits); // Banana,Orange,Apple</code></pre><h3 id="4、push-在最后增加元素"><a href="#4、push-在最后增加元素" class="headerlink" title="4、push() 在最后增加元素"></a>4、push() 在最后增加元素</h3><p>返回新数组的长度值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var f = fruits.push(&#39;Kiwi&#39;);// console.log(f); // 5// console.log(fruits); // Banana Orange Apple Mango Kiwi</code></pre><h3 id="5、shift-删除第一个元素"><a href="#5、shift-删除第一个元素" class="headerlink" title="5、shift() 删除第一个元素"></a>5、shift() 删除第一个元素</h3><p>返回被“位移出”的字符串</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 返回 &quot;Banana&quot;</code></pre><h3 id="6、unshift-在最前面增加元素"><a href="#6、unshift-在最前面增加元素" class="headerlink" title="6、unshift() 在最前面增加元素"></a>6、unshift() 在最前面增加元素</h3><p>返回新数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 返回 5</code></pre><h3 id="7、delete-删除元素"><a href="#7、delete-删除元素" class="headerlink" title="7、delete 删除元素"></a>7、delete 删除元素</h3><p>使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // 把 fruits 中的首个元素改为 undefined</code></pre><h3 id="8、splice-向数组添加新项"><a href="#8、splice-向数组添加新项" class="headerlink" title="8、splice() 向数组添加新项"></a>8、splice() 向数组添加新项</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi,Apple,Mango</code></pre><p>第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>第二个参数（0）定义应删除多少元素。</p><p>其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>splice() 方法返回一个包含已删除项的数组：</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi// 已删除项： Apple,Mango</code></pre><h3 id="8、splice-删除元素"><a href="#8、splice-删除元素" class="headerlink" title="8、splice() 删除元素"></a>8、splice() 删除元素</h3><p>第一个参数（0）定义新元素应该被添加（接入）的位置。</p><p>第二个参数（1）定义应该删除多个元素。</p><p>其余参数被省略。没有新元素将被添加。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 Banana// 原数组： Banana,Orange,Apple,Mango// 新数组： Orange,Apple,Mangofruits.splice(1, 2); // Banana,Mango</code></pre><h3 id="9、concat-合并、连接数组"><a href="#9、concat-合并、连接数组" class="headerlink" title="9、concat() 合并、连接数组"></a>9、concat() 合并、连接数组</h3><p>concat() 方法不会更改现有数组。它总是返回一个新数组。</p><p>concat() 方法可以使用任意数量的数组参数：</p><p>concat() 方法也可以将值作为参数：</p><pre><code class="js">var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var arr2 = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var arr3 = [&quot;Robin&quot;, &quot;Morgan&quot;];arr1.concat(arr2); // 将arr1 与 arr2 连接在一起arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起arr1.concat([&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]); // 也可以将值作为参数</code></pre><h3 id="10、slice-裁剪新数组"><a href="#10、slice-裁剪新数组" class="headerlink" title="10、slice() 裁剪新数组"></a>10、slice() 裁剪新数组</h3><p>slice() 方法创建新数组。它不会从源数组中删除任何元素。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.slice(1); // Orange,Lemon,Apple,Mangofruits.slice(3); // Apple,Mango</code></pre><p>slice() 可接受两个参数，从开始参数选取元素，直到结束参数（不包括）为止。</p><p>第2个参数可省略，表示从第1个参数往后所有的元素；</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // Orange,Lemon</code></pre><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（二）</title>
      <link href="/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/17/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h2><h3 id="1、for循环遍历数组"><a href="#1、for循环遍历数组" class="headerlink" title="1、for循环遍历数组"></a>1、for循环遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (var i = 0; i &lt; fruits.length; i++) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="2、for-in-遍历数组"><a href="#2、for-in-遍历数组" class="headerlink" title="2、for in 遍历数组"></a>2、for in 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (i in fruits) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="3、forEach-遍历数组"><a href="#3、forEach-遍历数组" class="headerlink" title="3、forEach() 遍历数组"></a>3、forEach() 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});// Banana// Orange// Apple// Mango  fruits.forEach(v =&gt; {    console.log(v);});// Banana// Orange// Apple// Mango  </code></pre><p>数组元素和元素索引</p><pre><code class="js">var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    console.log(&#39;数组元素&#39; + value);    console.log(&#39;数组元素索引号&#39; + index);})// 数组元素1// 数组元素索引号0// 数组元素2// 数组元素索引号1// 数组元素3// 数组元素索引号2</code></pre><p>求数组的和</p><pre><code class="js">var sum = 0;var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    sum += value;})console.log(sum); // 6</code></pre><h2 id="二、数组迭代"><a href="#二、数组迭代" class="headerlink" title="二、数组迭代"></a>二、数组迭代</h2><h3 id="1、filter-筛选数组"><a href="#1、filter-筛选数组" class="headerlink" title="1、filter() 筛选数组"></a>1、filter() 筛选数组</h3><p>返回一个新数组，接受 3 个参数：项目值、项目索引、数组本身</p><p>返回大于50的元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value) {    return value &gt;= 50;})console.log(newArr); // [66, 88]</code></pre><p>返回偶数元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr2 = arr.filter(function(value) {    return value % 2 === 0;})console.log(newArr2); // [12, 66, 4, 88]</code></pre><h3 id="2、some-查找满足条件的元素是否存在"><a href="#2、some-查找满足条件的元素是否存在" class="headerlink" title="2、some() 查找满足条件的元素是否存在"></a>2、some() 查找满足条件的元素是否存在</h3><p>filter() 查找满足条件的元素 返回一个 <code>新数组</code> </p><p>some() 查找满足条件的元素是否存在 返回一个 <code>布尔值</code> </p><p>接受 3 个参数： <code>项目值</code> 、 <code>项目索引</code> 、 <code>数组本身</code> </p><p>sonme() 如果查找到第一个满足条件的元素就终止循环，效率更高</p><pre><code class="js">var arr = [10, 30, 4];var flag = arr.some(function(value) {    return value &lt; 3;});console.log(flag); // falsevar arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;];var flag1 = arr1.some(function(value) {    return value == &#39;pink&#39;;});console.log(flag1); // true</code></pre><h3 id="3、forEach-和-some-的区别"><a href="#3、forEach-和-some-的区别" class="headerlink" title="3、forEach() 和 some() 的区别"></a>3、forEach() 和 some() 的区别</h3><p>如果查询数组中唯一的元素, 用some方法更合适</p><p>在 some 里面 遇到 return true 就是终止遍历 迭代效率更高</p><p>在forEach 里面 return 不会终止迭代</p><pre><code class="js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];arr.some(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在 some 里面 return true 就终止遍历 迭代效率更高        return true;    }    console.log(11);    // 11    // 找到了该元素});var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];// 1. forEach迭代 遍历arr.forEach(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在forEach 里面 return 不会终止迭代        return true;    }    console.log(11);})// 11// 找到了该元素// 11// 11</code></pre><h3 id="4、indexOf"><a href="#4、indexOf" class="headerlink" title="4、indexOf()"></a>4、indexOf()</h3><p>在数组中搜索元素值并返回其位置</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); // 0</code></pre><h3 id="5、lastIndexOf"><a href="#5、lastIndexOf" class="headerlink" title="5、lastIndexOf()"></a>5、lastIndexOf()</h3><p>在数组中搜索元素值并返回其位置，从数组结尾开始搜索</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); // 2</code></pre><h3 id="6、find"><a href="#6、find" class="headerlink" title="6、find()"></a>6、find()</h3><p>返回通过测试函数的第一个数组元素的值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.find(function(value) {    return value &gt; 18;})console.log(first); // 25 第一个比18大的值</code></pre><h3 id="7、findIndex"><a href="#7、findIndex" class="headerlink" title="7、findIndex()"></a>7、findIndex()</h3><p>返回通过测试函数的第一个数组元素的索引</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(function(value) {    return value &gt; 18;})console.log(first); // 3 第一个比18大的值的索引号是3</code></pre><h3 id="8、map"><a href="#8、map" class="headerlink" title="8、map()"></a>8、map()</h3><p>对每个数组元素执行函数来创建新数组，不会更改原始数组。</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.map(function(value) {    return value * 2;})console.log(first); // [2, 4, 6] 将每个数组值乘以2</code></pre><h3 id="9、reduce-reduceRight"><a href="#9、reduce-reduceRight" class="headerlink" title="9、reduce() reduceRight()"></a>9、reduce() reduceRight()</h3><p>在每个数组元素上运行函数，以生成（减少它）单个值</p><p>reduceRight() 方法在数组中从左到右工作</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.reduce(function(total, value) {    return total + value;})console.log(first); // 6 总和为6</code></pre><h3 id="10、every"><a href="#10、every" class="headerlink" title="10、every()"></a>10、every()</h3><p>检查所有数组值是否通过测试，返回布尔值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.every(function(value) {    return value &gt; 18;})console.log(first); // false(并非所有元素都大于18)</code></pre><h2 id="三、数组排序"><a href="#三、数组排序" class="headerlink" title="三、数组排序"></a>三、数组排序</h2><h3 id="1、reverse-反转数组"><a href="#1、reverse-反转数组" class="headerlink" title="1、reverse() 反转数组"></a>1、reverse() 反转数组</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // Mango,Apple,Orange,Banana</code></pre><h3 id="2、sort-以字母方式排序"><a href="#2、sort-以字母方式排序" class="headerlink" title="2、sort() 以字母方式排序"></a>2、sort() 以字母方式排序</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // Apple,Banana,Mango,Orange</code></pre><h3 id="3、sort-以数字方式排序"><a href="#3、sort-以数字方式排序" class="headerlink" title="3、sort() 以数字方式排序"></a>3、sort() 以数字方式排序</h3><p>如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b}); // 1,5,10,25,40,100</code></pre><p>通过一个比值函数，对数组进行降序排序。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a}); // 100,40,25,10,5,1</code></pre><h3 id="4、sort-随机排序"><a href="#4、sort-随机排序" class="headerlink" title="4、sort() 随机排序"></a>4、sort() 随机排序</h3><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return 0.5 - Math.random()});// 40,10,5,100,1,25  随机生成排序// 5,40,100,25,1,10</code></pre><h3 id="5、sort-查找最高-最低数组值"><a href="#5、sort-查找最高-最低数组值" class="headerlink" title="5、sort() 查找最高/最低数组值"></a>5、sort() 查找最高/最低数组值</h3><p>升序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b});// 现在 points[0] 包含最低值// 而 points[points.length-1] 包含最高值</code></pre><p>降序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a});// 现在 points[0] 包含最高值// 而 points[points.length-1] 包含最低值</code></pre><h3 id="6、Math-max-apply-查找最高数组值"><a href="#6、Math-max-apply-查找最高数组值" class="headerlink" title="6、Math.max.apply() 查找最高数组值"></a>6、Math.max.apply() 查找最高数组值</h3><p>apply() 第二个参数须是数组，与 <code>Math.max</code> 相结合使用。</p><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> .</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.max.apply(Math, points)var a = Math.max.apply(null, points) // null 也可以console.log(a); // 100</code></pre><h3 id="7、Math-min-apply-查找最低数组值"><a href="#7、Math-min-apply-查找最低数组值" class="headerlink" title="7、Math.min.apply() 查找最低数组值"></a>7、Math.min.apply() 查找最低数组值</h3><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> 。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.min.apply(Math, points)console.log(a); // 1</code></pre><p><img src="http://mdimg.95408.com/20191213144049.png" alt="20191213144049"></p><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github</title>
      <link href="/2019/12/17/tools/git%E5%92%8Cgithub/"/>
      <url>/2019/12/17/tools/git%E5%92%8Cgithub/</url>
      
        <content type="html"><![CDATA[<h1 id="git-本地仓库"><a href="#git-本地仓库" class="headerlink" title="git 本地仓库"></a>git 本地仓库</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>Git 使用前配置</strong></p><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名： <code>git config --global user.name 提交人姓名</code> </li><li>配置提交人姓名： <code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息： <code>git config --list</code> </li></ol><p><strong>提交步骤</strong></p><ol><li><code>git init</code> 初始化git仓库</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件/提交到暂存区</li><li><code>git commit -m 提交信息</code> 向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><p><strong>撤销</strong></p><ul><li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code> </li><li>将文件从暂存区中删除： <code>git rm --cached 文件</code> </li><li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录： <code>git rest --hard commitID</code> （ID号可以通过 <code>git log</code> 查看） </li></ul><p><strong>分支命令</strong></p><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 来源分支</code> 合并分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><p><strong>暂时保存更改</strong></p><ul><li>存储临时改动： <code>git stash</code> </li><li>恢复改动： <code>git stash pop</code> </li></ul><h2 id="创建-git-init"><a href="#创建-git-init" class="headerlink" title="创建 git init"></a>创建 git init</h2><p>进入到一个目标管理文件夹，输入 <code>init</code> 命令创建完成；</p><pre><code class="git">$ git init  // 初始化工作区，创建.git的隐藏文件夹</code></pre><h2 id="保存-git-add-commit"><a href="#保存-git-add-commit" class="headerlink" title="保存 git add / commit"></a>保存 git add / commit</h2><p>保存一个文件的版本：</p><pre><code class="git">$ git add code1.py   // 保存到暂存区$ git commit -m &#39;这是第一个版本&#39;   // 保存到本地文件库</code></pre><p>再保存一个文件的另一个版本：</p><pre><code class="git">$ git add code1.py$ git commit -m &#39;这是第二个版本&#39;</code></pre><p>将工作区所有文件保存到暂存区：</p><pre><code class="git">$ git add .</code></pre><h2 id="查看版本-git-log"><a href="#查看版本-git-log" class="headerlink" title="查看版本 git log"></a>查看版本 git log</h2><p>查看文件多个版本：</p><pre><code class="git">$ git logcommit 699977fa2a89db2dabc8bf9c1d2e17f23dc4a73f (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 15:02:37 2019 +0800    &#39;这是第二个版本。&#39;commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>以简短形式显示：</p><pre><code class="git">$ git log --pretty=oneline</code></pre><p>ps.win窗口使用命令行<strong>不能显示中文字符</strong>：</p><p>使用 <code>Git Bash</code> 窗口，右键设置–文本设置为 <code>zh_ch UTF-8</code> 退出重新进入即可。</p><h2 id="回退-git-reset"><a href="#回退-git-reset" class="headerlink" title="回退 git reset"></a>回退 git reset</h2><p>回到第一个版本：</p><p>HEAD^ 前一个版本；HEAD^^ 前两个版本；HEAD<del>1 前一个版本；HEAD</del>100 前100个版本；</p><pre><code class="git">$ git reset --hard HEAD^commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154 (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>通过版本号回到第二个版本：</p><pre><code class="git">$ git reset --hard 6999HEAD is now at 699977f &#39;这是第二个版本。&#39;</code></pre><p>如果退回到第一版本记录后，即出终端就找不到第二版本的版本号时，我们可以使用 <code>git reflog</code> 查看操作记录，得到最前面的版本号；如下， <code>699977f</code> 就是第二个版本的版本号。</p><pre><code class="git">$ git reflog699977f (HEAD -&gt; master) HEAD@{0}: reset: moving to 6999325e516 HEAD@{1}: reset: moving to HEAD^699977f (HEAD -&gt; master) HEAD@{2}: commit: &#39;这是第二个版本。&#39;325e516 HEAD@{3}: commit (initial): &#39;这是第一个版本。&#39;</code></pre><h2 id="工作区-暂存区"><a href="#工作区-暂存区" class="headerlink" title="工作区 暂存区"></a>工作区 暂存区</h2><p>保存文件的 git_test 是工作区；</p><p>git_test 文件夹下的 .git 文件夹是版本库；其中包含暂存区；</p><p>git add 将文件添加到暂存区； git commit 把暂存区所有内容提交到当前分支，创建版本记录；</p><pre><code class="git">$ git add XXX$ git commit -m 保存到本地文件库要增加的说明文字</code></pre><p>查看未处理提交的文件状态：</p><pre><code class="git">$ git status</code></pre><h2 id="撤销修改-git-checkout"><a href="#撤销修改-git-checkout" class="headerlink" title="撤销修改 git checkout"></a>撤销修改 git checkout</h2><p>文件没有保存到暂存区时，取消修改：</p><pre><code class="git">git checkout -- code2.txt</code></pre><p>文件通过git add code2.txt 保存到了暂存区，取消修改：</p><pre><code class="git">git reset HEAD code2.txt  # 先取消暂存git checkout -- code2.txt # 和上一步一样，取消修改</code></pre><p>如果已经提交到了版本库（git commit -m ‘版本4’），就通过版本回退</p><pre><code class="git">$ git reset --hard HEAD^</code></pre><h2 id="查看不同-git-diff"><a href="#查看不同-git-diff" class="headerlink" title="查看不同 git diff"></a>查看不同 git diff</h2><p>查看工作区与之前版本的不同：</p><pre><code class="git">$ git diff HEAD -- code1.py</code></pre><p>查看上个版本和上上个版本的不同：</p><pre><code class="git">$ git diff Head HEAD^ -- code1.py</code></pre><h2 id="删除文件-git-rm"><a href="#删除文件-git-rm" class="headerlink" title="删除文件 git rm"></a>删除文件 git rm</h2><pre><code class="git">git add code2.txt  # 文件提交到了暂存区rm code2.txt  # 工作区删除文件git rm code2.txt # 将删除提交到暂存区git commit -m &#39;删除后提交的版本&#39;  # 将删除后提交一个版本# 删除后恢复与撤销修改相同</code></pre><h2 id="切换分支-git-branch"><a href="#切换分支-git-branch" class="headerlink" title="切换分支 git branch"></a>切换分支 git branch</h2><p>查看当前所有分支：git branch</p><pre><code class="git">$ git branch* master</code></pre><p>创建分支：git branch dev</p><pre><code class="git">// 创建新分支后：$ git branch* master  // 当前分支  dev  // 新创建的分支</code></pre><p>切换分支：git checkout dev</p><pre><code class="git">// 切换分支后：$ git branch  master* dev  // 当前分支为dev</code></pre><p>创建并切换分支：git checkout -b dev</p><pre><code class="git">$ git checkout -b dev$ git branch* dev  master</code></pre><p>切换回master分支：git checkout master</p><pre><code class="git">$ git checkout master$ git branch  dev* master</code></pre><p>在dev分支上做修改并提交后，可以切换到master分支，并使用以下方式合并dev分支；</p><h2 id="合并分支-git-merge"><a href="#合并分支-git-merge" class="headerlink" title="合并分支 git merge"></a>合并分支 git merge</h2><p>回到主分支master上，合并dev分支：git merge dev</p><pre><code class="git">$ git merge dev</code></pre><h2 id="删除分支-git-branch"><a href="#删除分支-git-branch" class="headerlink" title="删除分支 git branch"></a>删除分支 git branch</h2><p>分支上所有内容都合并到主分支时，可以删除分支：git branch -d dev</p><pre><code class="git">$ git branch -d dev// 如果没有合并子分支上的内容，并需要强制合并，改成大写 -D</code></pre><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>当切换到dev分支修改code.txt并提交add、commit；</p><p>又切换回master分支修改code.txt并提交add、commit；</p><p>将dev分支合并到master时（git merge dev），会出现冲突；</p><p>（现在在master分支当中），手动修改code.txt冲突文件，并再次add、commit提交；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>当在dev分支修改一个文件，并提交commit；</p><p>又在master分支增加一个新文件，并提交commit；</p><p>此时，在两个不同分支下有两个不同的提交；</p><p>此时合并时，git会提示输入一个分支注释文字，并自动创建一个新的分支；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="禁用快速合并-–no-ff"><a href="#禁用快速合并-–no-ff" class="headerlink" title="禁用快速合并 –no-ff"></a>禁用快速合并 –no-ff</h2><p>在dev分支上做了修改并提交一个分支为“dev分支”；</p><p>切换回master分支，将dev分支合并：</p><pre><code class="git">$ git merge dev</code></pre><p>无冲突时，git会使用快速合并 <code>Fast forward</code> ，如果我们要保存分支信息时，需要禁止快速合并；</p><pre><code class="git">$ git merge --no-ff -m &#39;禁用fast forward版本&#39; dev</code></pre><p>此时，原来dev创建的“dev分支”会保留下来，</p><p>并会创建一个新的分支：“禁用fast forward版本”；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p><strong>禁用快速合并的情况</strong></p><p>当我们在dev分支进行工作时，需要临时进入一个临时分支进行bug处理；</p><p>可以先将当前分支存储起来：</p><pre><code class="git">git stash</code></pre><p>此时我们使用 <code>git status</code> 查看，变成了干净的工作区；</p><p>切换回master分支：git checkout master</p><p>创建一个临时分支：bug-001；</p><p>修改bug完成，提交commit一个“修改bug-001版本”；</p><p>切换回master分支；</p><p>此时如果直接合并分支，就没有修改bug-001版本的记录；</p><p>我们就采用禁用快速合并的处理方式；</p><p>合并临时分支：bug-001；</p><pre><code class="git">git merge --no-ff -m &quot;修复bug后的版本&quot; bug-001</code></pre><h2 id="存储工作现场-git-stash-暂时保存更改"><a href="#存储工作现场-git-stash-暂时保存更改" class="headerlink" title="存储工作现场 git stash 暂时保存更改"></a>存储工作现场 git stash 暂时保存更改</h2><p>当我们在dev分支上工作时，需要临时进入master分支上做修改，</p><p>只需在分支上临时保存，再进入master分支操作保存。</p><p>返回dev分支上重新开始工作。</p><pre><code class="git">git stash  // 当前在dev分支，暂存文件$ git statusOn branch dev  // 当前在dev分支nothing to commit, working tree clean  // 暂存文件后，分支变干净了</code></pre><p>回到master分支，进行bug修改，保存：</p><pre><code class="git">git checkout master</code></pre><p>查看存储的工作记录：</p><pre><code class="git">git stash list</code></pre><p>在master分支上完成操作后，返回到dev分支上，恢复工作记录：</p><pre><code class="git">git checkout dev   // 返回dev分支git stash pop   // 恢复工作记录</code></pre><h1 id="github-远程仓库"><a href="#github-远程仓库" class="headerlink" title="github 远程仓库"></a>github 远程仓库</h1><p><img src="http://mdimg.95408.com/201912171203_333.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="1、-A-将新项目-push-至-github"><a href="#1、-A-将新项目-push-至-github" class="headerlink" title="1、  A 将新项目 push 至 github"></a>1、  A 将新项目 push 至 github</h2><p>(1)、A 将地址文件夹1215_git中的项目修改完成，保存到本地仓库；</p><p>(2)、A 在 github.com 上创建一个新项目：1215_git；并得到了项目远程地址： <code>https://github.com/yuanshengorg/1215_git.git</code> 。</p><p>(3)、A 将本地项目 push 至远程仓库：master 表示本地仓库的分支；</p><pre><code class="git">$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>将远程地址改为简短别名：</p><pre><code class="git">$ git remote add origin https://github.com/yuanshengorg/1215_git.gitorigin 表示将远程地址改为的别名</code></pre><p>通过别名推送到远程仓库：</p><pre><code class="git">$ git push origin master</code></pre><p>在第一次推送时，加上 -u 记录：</p><pre><code class="git">$ git push -u origin master</code></pre><p>下一次推送可以更简单：</p><pre><code class="git">$ git push</code></pre><h2 id="2、-B-将项目-clone-到-本地"><a href="#2、-B-将项目-clone-到-本地" class="headerlink" title="2、 B 将项目 clone 到 本地"></a>2、 B 将项目 clone 到 本地</h2><p>在网站上获取 Clone 地址：</p><p><img src="http://mdimg.95408.com/201912171139_943.png?imageView2/2/w/1200/h/1200" alt=""></p><p>克隆远端数据仓库到本地： <code>git clone 仓库地址</code> </p><pre><code class="git">git clone https://github.com/yuanshengorg/1215_git.git</code></pre><h2 id="3、-B-将项目修改后-push-至-github"><a href="#3、-B-将项目修改后-push-至-github" class="headerlink" title="3、 B 将项目修改后 push 至 github"></a>3、 B 将项目修改后 push 至 github</h2><p>B 将项目克隆到本地后，直接在本地修改，add 至暂存区，commit 至本地仓库；</p><p>完成修改，上传到 A 创建的项目远程仓库：</p><pre><code class="git">$ git push origin master   // A 创建的远程地址别名 B 也可以使用或者：$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>B 如果想摄推送内容至 A 的仓库，需要 A 设置一下：邀请 B 为团队成员。</p><p><img src="http://mdimg.95408.com/201912171157_660.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="4、-A-拉取远程仓库中最新的版本"><a href="#4、-A-拉取远程仓库中最新的版本" class="headerlink" title="4、 A 拉取远程仓库中最新的版本"></a>4、 A 拉取远程仓库中最新的版本</h2><p>拉取远程仓库中最新的版本： <code>git pull 远程仓库地址 分支名称</code> </p><pre><code class="git">$ git pull origin master或者：$ git pull https://github.com/yuanshengorg/1215_git.git master</code></pre><p>git clone 是完全克隆；</p><p>git pull 是本地已有项目，只拉取远程仓库中更新的内容；</p><h2 id="SSH-推送"><a href="#SSH-推送" class="headerlink" title="SSH 推送"></a>SSH 推送</h2><p><img src="http://mdimg.95408.com/201912171137_313.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code class="git">$ ssh-keygen</code></pre><p>会在本地（/c/Users/用户名/.ssh/）生成：id_rsa 文件和 id_rsa.pub 文件；</p><p>将 <code>id_rsa.pub</code> 文件打开复制内容设置到 github.com 网站上，即可。</p><p>github.com ——右上角个人中心——settings——SSH and GPG keys——SSH keys，新增保存即可。</p><p><img src="http://mdimg.95408.com/201912171135_162.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="跨团队合作："><a href="#跨团队合作：" class="headerlink" title="跨团队合作："></a>跨团队合作：</h2><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h2 id="忽略清单文件创建："><a href="#忽略清单文件创建：" class="headerlink" title="忽略清单文件创建："></a>忽略清单文件创建：</h2><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>git忽略清单文件名称：<strong>.gitignore</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo创建博客</title>
      <link href="/2019/12/17/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/17/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912180011_408.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="node-js-和-npm"><a href="#node-js-和-npm" class="headerlink" title="node.js 和 npm"></a>node.js 和 npm</h3><p>Hexo是基于nodejs的静态博客，首先需要安装nodejs，并且需要nodejs中的重要工具：<code>npm</code> ；</p><p>查看 nodejs 版本：<code>node -V</code> ；</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>有了nodejs，其他就简单了！安装hexo： <code>npm install -g hexo</code> ；</p><p>查看 hexo 版本： <code>hexo -v</code> ；</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>你也可以安装一个必备的代码管理工具：<code>git</code> ；这样我们就可以使用 <code>git bash</code> 这个工具了；</p><p>查看 git 版本： <code>git version</code> ；</p><h2 id="创建-hexo"><a href="#创建-hexo" class="headerlink" title="创建 hexo"></a>创建 hexo</h2><p>我们在本地创建一个文件夹 <code>d\hexo</code> 做为博客的目录；</p><p>只需3步，完成博客的搭建：</p><p>1、在 <code>d\hexo</code>目录下，执行以下命令，创建 hexo 完成；</p><pre><code class="git">hexo init</code></pre><p>2、开始书写文章：</p><pre><code class="git">hexo new &#39;我的第一篇hexo博客文章&#39;</code></pre><p>3、运行本地博客服务器：</p><pre><code class="git">$ hexo s    INFO  Start processing    INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>此时，我们在浏览器当中输入：<code>http://local:4000</code> 即可查看网站。</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>使用以下命令创建文章，我们就可以通过 <code>D:\hexo\source\_posts</code> 查看创建的文件，开始创作即可。</p><pre><code class="git">$ hexo new [layout] &lt;title&gt;</code></pre><p>或者直接将md文章放入到 <code>D:\hexo\source\_posts</code> 目录下；</p><h2 id="文章预定义参数"><a href="#文章预定义参数" class="headerlink" title="文章预定义参数"></a>文章预定义参数</h2><p>我们在md文章形状，使用yaml定义标题、分类、标签、日期等等，可以自己增减。</p><pre><code class="yaml">---title: 文章标题date： 日期categories: 分类tags: 标签---</code></pre><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">官方文档：更多预先定义的参数</a></p><p>如果是有子分类：</p><pre><code class="yaml">categories: [父分类， 子分类]</code></pre><p>如果是有多个标签：</p><pre><code class="yaml">tags: [标签1， 标签2]</code></pre><h2 id="搭建到-github"><a href="#搭建到-github" class="headerlink" title="搭建到 github"></a>搭建到 github</h2><p>1、创建 github 账号，并创建 ssh （参考：<a href="https://yuanshengorg.github.io/2019/12/17/tools/git%E5%92%8Cgithub/#SSH-%E6%8E%A8%E9%80%81" target="_blank" rel="noopener">git和github：SSH</a>）； </p><p>2、在自己的账号下，新建一个repo：<code>New repository</code> （github右上角 + 号——New repository）；</p><p>3、项目名称（Repository name）为：<code>你的名称.github.io</code> ，如 <code>yuansheng.github.io</code>；</p><p><img src="http://mdimg.95408.com/201912172352_728.png?imageView2/2/w/1200/h/1200" alt=""></p><p>4、回到本地文件夹：<code>d/hexo</code> ，修改文件： <code>_config.yml</code> ：</p><pre><code class="git">deploy:  type: git  repo: https://github.com/yuansheng/yuansheng.github.io.git  branch: master</code></pre><p>repo 请修改为你创建的地址。</p><p>5、安装工具：hexo-deployer-git</p><pre><code class="git">npm install hexo-deployer-git --save</code></pre><p>6、回到命令行工具运行：</p><pre><code class="git">hexo clean // 清除之前生成的文件hexo generate   // 生成新的静态文件hexo depoly   // 部署网站</code></pre><p>执行 <code>hexo depoly</code> 时，第一次可能会需要注册 github.com 的账号及密码；</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>输入 <code>yuansheng.github.io</code> ，即你设置的项目文件名，即可访问网站；</p><p>你也可以绑定自己的域名，如 <code>www.yuanblogname.com</code>；</p><h2 id="增-改文章"><a href="#增-改文章" class="headerlink" title="增/改文章"></a>增/改文章</h2><p>上面的三个命令 <code>hexo clean / generate / depoly</code> 可简写为：</p><pre><code class="git">hexo cleanhexo ghexo d</code></pre><p>以后每次在文件夹中增加、修改了 md 文章后，执行这三个命令即可；</p><p>所有在本地电脑上修改的文档，远程博客也就修改了。</p><h2 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo官方文档：指令</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档：中文</a></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
