<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS移动布局之flex布局（图示）</title>
      <link href="/2019/12/26/css/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E4%B9%8Bflex%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%BE%E7%A4%BA%EF%BC%89/"/>
      <url>/2019/12/26/css/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E4%B9%8Bflex%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%BE%E7%A4%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><h3 id="速查"><a href="#速查" class="headerlink" title="速查"></a>速查</h3><p><strong>父项常见属性</strong></p><ul><li>flex-direction：设置主轴的方向   <ul><li>row； row-reverse； column； column-reverse； </li></ul></li><li>justify-content：设置主轴上的子元素排列方式   <ul><li>fles-start； flex-end； center； space-around； space-between； </li></ul></li><li>flex-wrap：设置子元素是否换行  <ul><li>nowrap； wrap； </li></ul></li><li>align-items：设置侧轴上的子元素排列方式（单行）<ul><li>flex-start； flex-end； center； stretch； </li></ul></li><li>align-content：设置侧轴上的子元素的排列方式（多行）<ul><li>flex-start； flex-end； center； space-around； space-between； stretch； </li></ul></li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><p><strong>子项常见属性</strong></p><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="flex-弹性布局"><a href="#flex-弹性布局" class="headerlink" title="flex 弹性布局"></a>flex 弹性布局</h3><ul><li>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局；</li><li>又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局；</li><li>通过给父盒子添加 <code>flex</code> 属性，来控制子盒子的位置和排列方式；</li></ul><blockquote><p>小试牛刀：</p></blockquote><p><img src="http://mdimg.95408.com/web_2019122602.gif" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* flex布局 */        display: flex;        /* 平分剩余空间 */        justify-content: space-around;        width: 80%;        height: 400px;        border: 2px solid red;        margin: 0 auto;    }    div span {        width: 200px;        height: 200px;        border: 1px solid blue;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;        &lt;span&gt;1&lt;/span&gt;        &lt;span&gt;2&lt;/span&gt;        &lt;span&gt;3&lt;/span&gt;    &lt;/div&gt;</code></pre><h2 id="父项常见属性"><a href="#父项常见属性" class="headerlink" title="父项常见属性"></a>父项常见属性</h2><ul><li>flex-direction：设置主轴的方向</li><li>justify-content：设置主轴上的子元素排列方式</li><li>flex-wrap：设置子元素是否换行  </li><li>align-content：设置侧轴上的子元素的排列方式（多行）</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="flex-direction主轴方向"><a href="#flex-direction主轴方向" class="headerlink" title="flex-direction主轴方向"></a>flex-direction主轴方向</h3><ul><li>row   默认值，从左到右</li><li>row-reverse   从右到左</li><li>column   从上到下</li><li>column-reverse   从下到上</li></ul><blockquote><p>以 X 轴为主轴（左）及以 Y 轴为主轴（右）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262137_368.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 左图：以x轴为主轴： */    /* 为默认值，可以不写 */    flex-direction: row;    /* 右图：以Y轴为主轴： */    flex-direction: column;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}</code></pre><h3 id="justify-content-主轴子元素排列"><a href="#justify-content-主轴子元素排列" class="headerlink" title="justify-content 主轴子元素排列"></a>justify-content 主轴子元素排列</h3><ul><li>fles-start   默认值，从头部开始；如果x轴是主轴则从左到右</li><li>flex-end   从尾部开始</li><li>center   在<strong>主轴居中对齐</strong>；如果x轴是主轴则水平居中</li><li>space-around   平分剩余空间</li><li>space-between   <strong>先两边靠边，再平分剩余空间</strong></li></ul><blockquote><p>当主轴为 X 轴（默认）时，主轴上 子元素 的排列方式：</p></blockquote><p><img src="http://mdimg.95408.com/201912262150_216.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 从左往右排列 */    justify-content: flex-start;    /* 从右往左排列 左上图 */    justify-content: flex-end;    /* 居中排列 右上图 */    justify-content: center;    /* 平分剩余空间 左下图 */    justify-content: space-around;    /* 先两边靠齐，再平分剩余空间 右下图 */    justify-content: space-between;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}</code></pre><blockquote><p>X 轴为主轴时（左）和 Y 轴为主轴时 <code>flex-direction: column;</code> 对比（其他排序方式类似）:</p></blockquote><p><img src="http://mdimg.95408.com/201912262202_745.png?null" alt=""></p><h3 id="flex-wrap-是否换行"><a href="#flex-wrap-是否换行" class="headerlink" title="flex-wrap 是否换行"></a>flex-wrap 是否换行</h3><ul><li>nowrap   默认值，不换行</li><li>wrap   换行</li></ul><blockquote><p>当主轴为 X 轴（默认）时，子元素 压缩不换行（左）及换行（右）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262155_924.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 不换行 默认值 可不写  左图 */    flex-wrap: nowrap;    /* 换行  右图 */    flex-wrap: wrap;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}</code></pre><blockquote><p>当设置 Y 轴为主轴时 <code>flex-direction: column;</code> :</p></blockquote><p><img src="http://mdimg.95408.com/201912262159_917.png?null" alt=""></p><h3 id="align-items-侧轴子元素排列（单行-）"><a href="#align-items-侧轴子元素排列（单行-）" class="headerlink" title="align-items 侧轴子元素排列（单行 ）"></a>align-items 侧轴子元素排列（单行 ）</h3><ul><li>flex-start   默认值，从头部开始</li><li>flex-end   从尾部开始</li><li>center   居中显示</li><li>stretch   拉伸</li></ul><blockquote><p>当主轴为 X 轴（默认）时，子元素 在侧轴上 的排列方式（单行 ）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262210_634.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912262211_79.png?null" alt=""></p><pre><code class="css">div {    display: flex;    /* 从头部开始 上右图*/    align-items: flex-start;    /* 从尾部开始 上右图*/    align-items: flex-end;    /* 居中 下左图*/    align-items: center;    /* 拉伸 下右图*/    align-items: stretch;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    /* 拉伸stretch时，高度不要写 */    height: 100px;    border: 1px solid blue;}</code></pre><h3 id="align-content-侧轴子元素排列（多行）"><a href="#align-content-侧轴子元素排列（多行）" class="headerlink" title="align-content  侧轴子元素排列（多行）"></a>align-content  侧轴子元素排列（多行）</h3><ul><li>flex-start   默认值，在侧轴的头部开始排列</li><li>flex-end   尾部开始</li><li>center   在侧轴中间显示</li><li>space-around   在侧轴平分剩余空间</li><li>space-between   在侧轴先靠两边，再平分剩余空间</li><li>stretch   高度平分父元素高度</li></ul><blockquote><p>当主轴为 X 轴（默认）时，子元素 在侧轴上 的排列方式（多行 ）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262216_131.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912262218_39.png?null" alt=""></p><p><img src="http://mdimg.95408.com/201912262219_508.png?null" alt=""></p><pre><code class="css">div {    display: flex;    flex-wrap: wrap;    /* 从头开始 */    align-content: flex-start;    /* 从尾开始 */    align-content: flex-end;    /* 居中 */    align-content: center;    /* 平分剩余空间 */    align-content: space-around;    /* 两侧靠边，再平分剩余空间 */    align-content: space-between;    /* 平分父元素高度 */    align-content: stretch;    width: 400px;    height: 400px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    /* 拉伸stretch时，高度不要写 */    height: 100px;    border: 1px solid blue;}</code></pre><h3 id="align-content-和-align-items-区别"><a href="#align-content-和-align-items-区别" class="headerlink" title="align-content 和 align-items 区别"></a>align-content 和 align-items 区别</h3><ul><li>align-items  适用于单行， 只有上对齐、下对齐、居中和 拉伸</li><li>align-content 适应于换行（多行）（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 </li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><ul><li>是 flex-direction 和 flex-wrap 属性的复合属性</li><li>如：同时设置为 X 轴为主轴 + 换行：</li></ul><pre><code class="css">flex-flow:row wrap;</code></pre><h2 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a>子项常见属性</h2><ul><li>flex子项目占的份数</li><li>align-self控制子项自己在侧轴的排列方式</li><li>order属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</p><blockquote><p>父盒子800px，span1和span3各固定100px，span2分配剩余的空间：</p></blockquote><p><img src="http://mdimg.95408.com/201912262231_433.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div {        display: flex;        width: 800px;        height: 100px;        border: 2px solid red;        margin: 0 auto;    }    /* span1固定宽度 */    div span:nth-child(1) {        width: 100px;        height: 100px;        background-color: aquamarine;    }    /* span2分配除了span1和span3之外的所有空间 */    div span:nth-child(2) {        flex: 1;        background-color: #ccc;    }    /* span3固定宽度 */    div span:nth-child(3) {        width: 100px;        height: 100px;        background-color: aquamarine;    }&lt;/style&gt;&lt;div&gt;    &lt;span&gt;1&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;</code></pre><blockquote><p>span1、span2 和 span3 平均分配父盒子所有剩余空间（各占1份）：</p></blockquote><p><img src="http://mdimg.95408.com/201912262236_351.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 800px;    height: 100px;    border: 2px solid red;    margin: 0 auto;}div span {    flex: 1;    border: 1px solid blue;}</code></pre><blockquote><p>span1、span2 各分配1份，span3 分配 2 份：</p></blockquote><p><img src="http://mdimg.95408.com/201912262239_353.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 800px;    height: 100px;    border: 2px solid red;    margin: 0 auto;}div span {    flex: 1;    border: 1px solid blue;}div span:nth-child(3) {    flex: 2;    border: 1px solid blue;}</code></pre><h3 id="align-self-子项自己在侧轴排列"><a href="#align-self-子项自己在侧轴排列" class="headerlink" title="align-self 子项自己在侧轴排列"></a>align-self 子项自己在侧轴排列</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</p><blockquote><p>将 span2 与总体相异：独自底对齐（其他默认对齐方式）；</p></blockquote><p><img src="http://mdimg.95408.com/201912262245_389.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 400px;    height: 300px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    height: 100px;    border: 1px solid blue;}div span:nth-child(2) {    align-self: flex-end;}</code></pre><h3 id="order-定义项目排序"><a href="#order-定义项目排序" class="headerlink" title="order 定义项目排序"></a>order 定义项目排序</h3><p>数值越小，排列越靠前，默认为0。</p><blockquote><p>所有 span 默认都是 0 ，将 span3 改成 -1，就排到第一了：</p></blockquote><p><img src="http://mdimg.95408.com/201912262248_317.png?null" alt=""></p><pre><code class="css">div {    display: flex;    width: 400px;    height: 300px;    border: 2px solid red;    margin: 0 auto;}div span {    width: 100px;    height: 100px;    border: 1px solid blue;}div span:nth-child(3) {    order: -1;}</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS移动布局基础、流式布局</title>
      <link href="/2019/12/26/css/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>/2019/12/26/css/CSS%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口 viewport"></a>视口 viewport</h2><h3 id="理想视口-ideal-viewport"><a href="#理想视口-ideal-viewport" class="headerlink" title="理想视口 ideal viewport"></a>理想视口 ideal viewport</h3><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口。</p><ul><li>布局视口 layout viewport</li><li>视觉视口 visual viewport</li><li>理想视口 ideal viewport<ul><li>meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽；</li><li>我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口；</li></ul></li></ul><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;</code></pre><p><img src="http://mdimg.95408.com/201912261921_804.png?null" alt=""></p><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h3 id="物理像素-amp-物理像素比"><a href="#物理像素-amp-物理像素比" class="headerlink" title="物理像素&amp;物理像素比"></a>物理像素&amp;物理像素比</h3><p>1、iphone 6/7/8 的物理像素宽度：750px，但我们制作一个375px宽度的盒子，就填充满了；</p><p>2、那是因为iphone的<strong>物理像素比</strong>为2，即1px能显示2个物理像素；</p><p><img src="http://mdimg.95408.com/201912261940_282.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    - {        margin: 0;        padding: 0;    }    div {        width: 375px;        height: 375px;        background-color: pink;    }&lt;/style&gt;&lt;div&gt;div&lt;/div&gt;</code></pre><h3 id="二倍图-图片"><a href="#二倍图-图片" class="headerlink" title="二倍图 图片"></a>二倍图 图片</h3><p>1、我们制作一个50px的图标，因为手机的常用物理像素比为 2，那么在iphone上就会放大变成100px，图片会变模糊；</p><p>2、那我们直接使用一张100px的图片，缩小至50px；</p><p>3、当在移动端放大2倍时，还是正常清晰度；</p><p><img src="http://mdimg.95408.com/201912261953_668.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    img:nth-child(2) {        width: 50px;        height: 50px;    }&lt;/style&gt;&lt;!-- 模糊的 --&gt;&lt;img src=&quot;images/apple50.jpg&quot; alt=&quot;&quot;&gt;&lt;!-- 采取2倍图 --&gt;&lt;img src=&quot;images/apple100.jpg&quot; alt=&quot;&quot;&gt;</code></pre><h3 id="二倍图-背景-background-size"><a href="#二倍图-背景-background-size" class="headerlink" title="二倍图 背景 background-size"></a>二倍图 背景 background-size</h3><pre><code class="css">background-size: 背景图片宽度 背景图片高度;* 单位： 长度|百分比|cover|contain； - cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域； - contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域；</code></pre><p>同上例，图片能用二倍图，CSS3 中我们也可以使用 <code>background-size</code> 缩放背景图：</p><p><img src="http://mdimg.95408.com/201912262038_528.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    .px50 {        width: 50px;        height: 50px;        background: url(images/apple50.jpg) no-repeat;    }    .px100 {        width: 50px;        height: 50px;        background: url(images/apple100.jpg) no-repeat;        background-size: 50px 50px;    }&lt;/style&gt;&lt;div class=&quot;px50&quot;&gt;&lt;/div&gt;&lt;div class=&quot;px100&quot;&gt;&lt;/div&gt;</code></pre><h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><h3 id="移动端-PC端"><a href="#移动端-PC端" class="headerlink" title="移动端+PC端"></a>移动端+PC端</h3><p>PC端和移动端为两套网站，pc端是pc端的样式，移动端在写一套，专门针对移动端适配的一套网站；</p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配；</p><h2 id="移动端技术"><a href="#移动端技术" class="headerlink" title="移动端技术"></a>移动端技术</h2><h3 id="移动端公共样式"><a href="#移动端公共样式" class="headerlink" title="移动端公共样式"></a>移动端公共样式</h3><p>移动端 CSS 初始化推荐使用 <code>normalize.css</code> </p><pre><code class="html">官网地址： http://necolas.github.io/normalize.css/</code></pre><p><a href="http://mdimg.95408.com/web_normalize.css" target="_blank" rel="noopener">本地备份</a></p><h3 id="CSS3盒子模型box-sizing"><a href="#CSS3盒子模型box-sizing" class="headerlink" title="CSS3盒子模型box-sizing"></a>CSS3盒子模型box-sizing</h3><p>CSS3盒子模型， padding 和 border 不会撑大盒子；</p><pre><code class="css">box-sizing: border-box;</code></pre><p><img src="http://mdimg.95408.com/201912262045_716.png?null" alt=""></p><pre><code class="html">&lt;style&gt;    div:nth-child(1) {        /* 传统盒子模型 = width + border + padding */        width: 200px;        height: 200px;        background-color: pink;        padding: 10px;        border: 10px solid red;    }    div:nth-child(2) {        /* box-sizing: border-box; 有了这句话就让盒子变成CSS3盒子模型 */        /* padding 和 border 不会再撑大盒子了 */        box-sizing: border-box;        width: 200px;        height: 200px;        padding: 10px;        border: 10px solid blue;    }&lt;/style&gt;</code></pre><h3 id="移动端特殊样式"><a href="#移动端特殊样式" class="headerlink" title="移动端特殊样式"></a>移动端特殊样式</h3><pre><code class="css">/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除清除  设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a {    -webkit-touch-callout: none;}</code></pre><h2 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h2><h3 id="移动端单独制作"><a href="#移动端单独制作" class="headerlink" title="移动端单独制作"></a>移动端单独制作</h3><ul><li>流式布局（百分比布局）</li><li>flex 弹性布局（强烈推荐）</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul><h3 id="响应式-1"><a href="#响应式-1" class="headerlink" title="响应式"></a>响应式</h3><ul><li>媒体查询</li><li>bootstarp</li></ul><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(1)HTML5+Css3基础</title>
      <link href="/2019/12/23/css/(1)HTML5+Css3%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/23/css/(1)HTML5+Css3%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML新增"><a href="#HTML新增" class="headerlink" title="HTML新增"></a>HTML新增</h2><h2 id="1-1、语义化标签"><a href="#1-1、语义化标签" class="headerlink" title="1.1、语义化标签"></a>1.1、语义化标签</h2><ul><li><code>header</code> —  头部标签</li><li><code>nav</code> —  导航标签</li><li><code>article</code> —   内容标签</li><li><code>section</code> —   块级标签</li><li><code>aside</code> —   侧边栏标签</li><li><code>footer</code> —   尾部标签</li></ul><blockquote><p>在 <code>IE9</code> 浏览器中，需要把语义化标签都转换为块级元素语义化标签；</p><p>在移动端支持比较友好；</p></blockquote><h2 id="1-2、多媒体音频标签"><a href="#1-2、多媒体音频标签" class="headerlink" title="1.2、多媒体音频标签"></a>1.2、多媒体音频标签</h2><h3 id="1-2-1、audio"><a href="#1-2-1、audio" class="headerlink" title="1.2.1、audio"></a>1.2.1、audio</h3><p><img src="http://mdimg.95408.com/201912191818_942.png" alt="audio 的参数"></p><blockquote><p>注意：在 chrome 浏览器中已经禁用了 autoplay 属性</p></blockquote><h3 id="1-2-2、video"><a href="#1-2-2、video" class="headerlink" title="1.2.2、video"></a>1.2.2、video</h3><pre><code class="html">&lt;body&gt;    &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;    &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;    &lt;!-- 多个视频格式支持不同浏览器 --&gt;    &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;        &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;        &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;    &lt;/video&gt;&lt;/body&gt;</code></pre><blockquote><p>谷歌浏览器禁用了自动播放功能，解决办法：需要添加 <strong>muted</strong> 属性</p></blockquote><p><img src="http://mdimg.95408.com/201912191820_561.png?null" alt="video 参数"></p><h2 id="1-3、input-标签"><a href="#1-3、input-标签" class="headerlink" title="1.3、input 标签"></a>1.3、input 标签</h2><p>tel只能输入电话；search能直接删除搜索数据；</p><p><img src="http://mdimg.95408.com/201912191824_8.png?null" alt="新增 input 标签"></p><h2 id="1-4、表单属性"><a href="#1-4、表单属性" class="headerlink" title="1.4、表单属性"></a>1.4、表单属性</h2><p>placeholder：表单中增加一行提示文本，获得焦点时消失；</p><p><img src="http://mdimg.95408.com/201912191826_338.png?null" alt="新增表单属性"></p><h2 id="Css3-新增"><a href="#Css3-新增" class="headerlink" title="Css3 新增"></a>Css3 新增</h2><h2 id="2-1、属性选择器"><a href="#2-1、属性选择器" class="headerlink" title="2.1、属性选择器"></a>2.1、属性选择器</h2><p><img src="http://mdimg.95408.com/201912191830_587.png?null" alt=""></p><p>1）</p><pre><code class="css">button {    /* 选择所有的button元素 */}button[disabled] {    /* 选择标签中带有disabled属性的button元素 */}</code></pre><p>2）</p><pre><code class="css">input[type=search] {    /* 选择type属性=search的input元素 */}span[class^=black] {    /* 选择class属性 以black开头的 span元素 */}span[class$=black] {    /* 选择class属性 以black结尾的 span元素 */}span[class*=black] {    /* 选择class属性 包含black的 span元素 */}</code></pre><h2 id="2-2、结构伪类选择器"><a href="#2-2、结构伪类选择器" class="headerlink" title="2.2、结构伪类选择器"></a>2.2、结构伪类选择器</h2><p><img src="http://mdimg.95408.com/201912191838_395.png" alt="结构伪类选择器属性列表"></p><h3 id="2-2-1、first-child-last-child"><a href="#2-2-1、first-child-last-child" class="headerlink" title="2.2.1、first-child / last-child"></a>2.2.1、first-child / last-child</h3><pre><code class="css">ul li:first-child {    /* 选择第一个li元素 */}ul li:last-child {    /* 选择最后一个li元素 */}ul li:nth-child(3) {    /* 选择第3个li元素 */}</code></pre><h3 id="2-2-2、nth-child"><a href="#2-2-2、nth-child" class="headerlink" title="2.2.2、nth-child( )"></a>2.2.2、nth-child( )</h3><table><thead><tr><th>选择符</th><th>简介</th></tr></thead><tbody><tr><td>ul li:nth-child(<strong>even</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>odd</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>2n</strong>) { }</td><td>偶数</td></tr><tr><td>ul li:nth-child(<strong>2n+1</strong>) { }</td><td>奇数</td></tr><tr><td>ul li:nth-child(<strong>5n</strong>) { }</td><td>第5、10、15个</td></tr><tr><td>ul li:nth-child(<strong>3n</strong>) { }</td><td>第3、6、9个</td></tr><tr><td>ul li:nth-child(<strong>n+5</strong>) { }</td><td>从第5个到最后</td></tr><tr><td>ul li:nth-child(<strong>-n+5</strong>) { }</td><td>前面5个</td></tr></tbody></table><blockquote><p>有时需要将2排各5个div中的最右边2个去除 <code>margin-right</code> 时，可以用 <code>ul li:nth-child(5)</code> 来选择第 5、10个div元素。</p></blockquote><h3 id="2-2-3、nth-child-和-nt-of-type-的区别"><a href="#2-2-3、nth-child-和-nt-of-type-的区别" class="headerlink" title="2.2.3、nth-child 和 nt-of-type 的区别"></a>2.2.3、nth-child 和 nt-of-type 的区别</h3><ul><li>ul中只有li元素时，两都选择相同；</li><li>ul中第一个是p元素，后面是li元素时：<ul><li>nth-child 选择父元素里面的第几个子元素，只要是子元素即可，不管是什么类型；</li><li>nth-of-type 是选择父元素的某一种子元素的第几个；</li></ul></li></ul><pre><code class="css">&lt;body&gt;&lt;ul&gt;&lt;p&gt;p&lt;/p&gt;&lt;li&gt;li 1&lt;/li&gt;&lt;li&gt;li 2&lt;/li&gt;&lt;li&gt;li 3&lt;/li&gt;&lt;li&gt;li 4&lt;/li&gt;&lt;li&gt;li 5&lt;/li&gt;&lt;li&gt;li 6&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;style&gt;ul :nth-child(1) {    background-color: red;    /* 选择p */}ul li:nth-child(3) {    background-color: blue;    /* 选择li 2 */    /* 虽然选择的是li的第3个，但是从第一个子元素p就开始计算 */}ul li:nth-of-type(3) {    background-color: green;    /* 选择li 3 */}ul li:nth-of-type(1) {    background-color: hotpink;    /* 选择li 1 */}&lt;/style&gt;</code></pre><h2 id="2-3、伪元素选择器"><a href="#2-3、伪元素选择器" class="headerlink" title="2.3、伪元素选择器"></a>2.3、伪元素选择器</h2><p><img src="http://mdimg.95408.com/201912191916_205.png?null" alt="伪类选择器"></p><h3 id="2-3-1、注意事项"><a href="#2-3-1、注意事项" class="headerlink" title="2.3.1、注意事项"></a>2.3.1、注意事项</h3><ul><li><code>before</code> 和 <code>after</code> 必须有 <code>content</code> 属性</li><li><code>before</code> 在内容前面， <code>after</code> 在内容后面</li><li><code>before</code> 和 <code>after</code> 创建的是一个元素，但是属于行内元素</li><li>创建出来的元素在 <code>Dom</code> 中查找不到，所以称为伪元素</li><li>伪元素和标签选择器一样，权重为 1</li></ul><h3 id="2-3-2、增加字体图标"><a href="#2-3-2、增加字体图标" class="headerlink" title="2.3.2、增加字体图标"></a>2.3.2、增加字体图标</h3><pre><code class="css">p {    width: 220px;    height: 22px;    border: 1px solid lightseagreen;    margin: 60px;    position: relative;}p::after {    content: &#39;\ea50&#39;;    font-family: &#39;icomoon&#39;;    position: absolute;    top: -1px;    right: 10px;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(2)Css3动画、2D、3D</title>
      <link href="/2019/12/23/css/(2)Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/"/>
      <url>/2019/12/23/css/(2)Css3%E5%8A%A8%E7%94%BB%E3%80%812D%E3%80%813D/</url>
      
        <content type="html"><![CDATA[<h2 id="2D转换-transform"><a href="#2D转换-transform" class="headerlink" title="2D转换 transform"></a>2D转换 transform</h2><p>2D 转换是改变标签在二维平面上的位置和形状</p><ul><li>移动： <code>translate</code> </li><li>旋转： <code>rotate</code> </li><li>缩放： <code>scale</code> </li></ul><h3 id="translate-移动"><a href="#translate-移动" class="headerlink" title="translate 移动"></a>translate 移动</h3><ul><li><code>translate</code> 最大的优点就是不影响其他元素的位置</li><li><code>translate</code> 中的100%单位，是相对于本身的宽度和高度来进行计算的</li></ul><pre><code class="css">transform: translate(x, y) transform: translateX(n) transfrom: translateY(n)</code></pre><ul><li>行内标签没有效果</li></ul><pre><code class="css">div {    background-color: lightseagreen;    width: 200px;    height: 100px;    /* 水平垂直移动 100px */    /* transform: translate(100px, 100px); */    /* 水平移动 100px */    /* transform: translate(100px, 0) */    /* 垂直移动 100px */    /* transform: translate(0, 100px) */    /* 水平移动 100px */    /* transform: translateX(100px); */    /* 垂直移动 100px */    transform: translateY(100px)}</code></pre><h3 id="例：让盒子水平垂直居中"><a href="#例：让盒子水平垂直居中" class="headerlink" title="例：让盒子水平垂直居中"></a>例：让盒子水平垂直居中</h3><pre><code class="html">&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;style&gt;    div {        position: relative;        width: 500px;        height: 500px;        background-color: red;    }    p {        position: absolute;        top: 50%;        left: 50%;        /* 原来的办法：计算返回原元素的一半 */        /* margin-top: -100px; */        /* margin-left: -100px; */        /* translate(-50%, -50%)  盒子往上走自己高度的一半 */        transform: translate(-50%, -50%);        width: 200px;        height: 200px;        background-color: burlywood;    }&lt;/style&gt;</code></pre><h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><pre><code class="css">/* 单位是：deg */transform: rotate(度数如180deg)</code></pre><ul><li><code>rotate</code> 里面跟度数，单位是 <code>deg</code> </li><li>角度为正时，顺时针，角度为负时，逆时针</li><li>默认旋转的中心点是元素的中心点</li></ul><pre><code class="html">&lt;style&gt;    div {        width: 200px;        height: 100px;        background-color: red;    }    div:hover {        transform: rotate(90deg);        /* 鼠标移动时顺时针转90度 */    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h3 id="例：图标360度旋转"><a href="#例：图标360度旋转" class="headerlink" title="例：图标360度旋转"></a>例：图标360度旋转</h3><p><img src="http://mdimg.95408.com/web_2019121903.gif" alt="图标360度旋转"></p><pre><code class="html">&lt;style&gt;    img {        width: 200px;        height: 200px;        background-color: pink;        border: pink solid 1px;        border-radius: 50%;        transition: all 0.3s;    }    img:hover {        transform: rotate(180deg);    }&lt;/style&gt;&lt;body&gt;    &lt;img src=&quot;media/pic.jpg&quot; alt=&quot;&quot;&gt;&lt;/body&gt;</code></pre><h3 id="例：制作上下-gt-符号"><a href="#例：制作上下-gt-符号" class="headerlink" title="例：制作上下  &gt; 符号"></a>例：制作上下  &gt; 符号</h3><p><img src="http://mdimg.95408.com/web_2019121902.gif" alt="上下  &gt; 符号"></p><pre><code class="html">&lt;style&gt;    div {        position: relative;        width: 249px;        height: 35px;        border: 1px solid #333;    }    div::after {        content: &quot;&quot;;        position: absolute;        top: 10px;        right: 10px;        /* 创建一个只有两边边框的方形 */        width: 10px;        height: 10px;        border-right: 1px solid #333;        border-bottom: 1px solid #333;        /* 将方形旋转45度 */        transform: rotate(45deg);        transition: all .2s;    }    /* 是鼠标经过div时，::after变动效果 */    div:hover::after {        transform: rotate(225deg);        top: 15px;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="旋转中心点-transform-origin"><a href="#旋转中心点-transform-origin" class="headerlink" title="旋转中心点 transform-origin"></a>旋转中心点 transform-origin</h3><pre><code class="css">transform-origin: x y;div {    width: 200px;    height: 200px;    background-color: pink;    margin: 100px auto;    transition: all 1s;    /* 1.可以跟方位名词 */    /* transform-origin: left bottom; */    /* 2. 默认的是 50%  50%  等价于 center  center */    /* 3. 可以是px 像素 */    transform-origin: 50px 50px;}</code></pre><ul><li>注意后面的参数 x 和 y 用空格隔开</li><li>x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 <code>center</code>  <code>center</code> </li><li>还可以给 x y 设置像素或者方位名词( <code>top</code> 、 <code>bottom</code> 、 <code>left</code> 、 <code>right</code> 、 <code>center</code> )</li></ul><h3 id="例：图片从左下角旋转上升"><a href="#例：图片从左下角旋转上升" class="headerlink" title="例：图片从左下角旋转上升"></a>例：图片从左下角旋转上升</h3><p><img src="http://mdimg.95408.com/2019121901.gif" alt=""></p><pre><code class="html">&lt;style&gt;    div {        /* 隐藏div外的after中的内容 */        overflow: hidden;        position: relative;        width: 300px;        height: 200px;        border: 1px solid #333;        margin: 10px;        float: left;    }    img {        position: absolute;        top: 0;        left: 0;        width: 300px;        height: 200px;        /* 以左 下 角为基点，旋转180度，看不看的状态 */        transform: rotate(100deg);        transform-origin: left bottom;        transition: all .2s;    }    div:hover img {        /* 鼠标移动，图片旋转到div内 */        transform: rotate(0deg);    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;    &lt;div&gt;&lt;img src=&quot;./media/dog.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><pre><code class="css">transform: scale(x, y) div:hover {    /* 注意，数字是倍数的含义，所以不需要加单位 */    /* transform: scale(2, 2) */    /* 实现等比缩放，同时修改宽与高 */    /* transform: scale(2) */    /* 小于 1 就等于缩放*/    transform: scale(0.5, 0.5)}</code></pre><ul><li>x 与 y 之间使用逗号进行分隔</li><li><code>transform: scale(1, 1)</code> : 宽高都放大一倍，相当于没有放大</li><li><code>transform: scale(2, 2)</code> : 宽和高都放大了二倍</li><li><code>transform: scale(2)</code> : 如果只写了一个参数，第二个参数就和第一个参数一致</li><li><code>transform:scale(0.5, 0.5)</code> : 缩小</li><li>优势：可以设置转换中心点缩放，默认以中心点缩放，而且<strong>不影响其他盒子</strong></li></ul><h3 id="例：图片放大"><a href="#例：图片放大" class="headerlink" title="例：图片放大"></a>例：图片放大</h3><p><img src="http://mdimg.95408.com/web_2019121905.gif" alt="图片放大"></p><h3 id="例：分类按钮放大"><a href="#例：分类按钮放大" class="headerlink" title="例：分类按钮放大"></a>例：分类按钮放大</h3><p><img src="http://mdimg.95408.com/web_2019121906.gif" alt="分类按钮放大"></p><h3 id="2D-转换综合写法-及-顺序"><a href="#2D-转换综合写法-及-顺序" class="headerlink" title="2D 转换综合写法 及 顺序"></a>2D 转换综合写法 及 顺序</h3><ul><li>顺序会影响到转换的效果；</li><li>同时有位置或者其他属性的时候，要将<strong>位移放到最前面</strong> ；</li></ul><pre><code class="css">div:hover {    transform: translate(200px, 0) rotate(360deg) scale(1.2)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css3 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（二）</title>
      <link href="/2019/12/23/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/12/23/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、遍历数组"><a href="#一、遍历数组" class="headerlink" title="一、遍历数组"></a>一、遍历数组</h2><h3 id="1、for循环遍历数组"><a href="#1、for循环遍历数组" class="headerlink" title="1、for循环遍历数组"></a>1、for循环遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (var i = 0; i &lt; fruits.length; i++) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="2、for-in-遍历数组"><a href="#2、for-in-遍历数组" class="headerlink" title="2、for in 遍历数组"></a>2、for in 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for (i in fruits) {    console.log(fruits[i]);}// Banana// Orange// Apple// Mango  </code></pre><h3 id="3、forEach-遍历数组"><a href="#3、forEach-遍历数组" class="headerlink" title="3、forEach() 遍历数组"></a>3、forEach() 遍历数组</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);});// Banana// Orange// Apple// Mango  fruits.forEach(v =&gt; {    console.log(v);});// Banana// Orange// Apple// Mango  </code></pre><p>数组元素和元素索引</p><pre><code class="js">var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    console.log(&#39;数组元素&#39; + value);    console.log(&#39;数组元素索引号&#39; + index);})// 数组元素1// 数组元素索引号0// 数组元素2// 数组元素索引号1// 数组元素3// 数组元素索引号2</code></pre><p>求数组的和</p><pre><code class="js">var sum = 0;var arr = [1, 2, 3];arr.forEach(function(value, index, array) {    sum += value;})console.log(sum); // 6</code></pre><h2 id="二、数组迭代"><a href="#二、数组迭代" class="headerlink" title="二、数组迭代"></a>二、数组迭代</h2><h3 id="1、filter-筛选数组"><a href="#1、filter-筛选数组" class="headerlink" title="1、filter() 筛选数组"></a>1、filter() 筛选数组</h3><p>返回一个新数组，接受 3 个参数：项目值、项目索引、数组本身</p><p>返回大于50的元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value) {    return value &gt;= 50;})console.log(newArr); // [66, 88]</code></pre><p>返回偶数元素组成的一个新数组</p><pre><code class="js">var arr = [12, 66, 4, 88, 3, 7];var newArr2 = arr.filter(function(value) {    return value % 2 === 0;})console.log(newArr2); // [12, 66, 4, 88]</code></pre><h3 id="2、some-查找满足条件的元素是否存在"><a href="#2、some-查找满足条件的元素是否存在" class="headerlink" title="2、some() 查找满足条件的元素是否存在"></a>2、some() 查找满足条件的元素是否存在</h3><p>filter() 查找满足条件的元素 返回一个 <code>新数组</code> </p><p>some() 查找满足条件的元素是否存在 返回一个 <code>布尔值</code> </p><p>接受 3 个参数： <code>项目值</code> 、 <code>项目索引</code> 、 <code>数组本身</code> </p><p>sonme() 如果查找到第一个满足条件的元素就终止循环，效率更高</p><pre><code class="js">var arr = [10, 30, 4];var flag = arr.some(function(value) {    return value &lt; 3;});console.log(flag); // falsevar arr1 = [&#39;red&#39;, &#39;pink&#39;, &#39;blue&#39;];var flag1 = arr1.some(function(value) {    return value == &#39;pink&#39;;});console.log(flag1); // true</code></pre><h3 id="3、forEach-和-some-的区别"><a href="#3、forEach-和-some-的区别" class="headerlink" title="3、forEach() 和 some() 的区别"></a>3、forEach() 和 some() 的区别</h3><p>如果查询数组中唯一的元素, 用some方法更合适</p><p>在 some 里面 遇到 return true 就是终止遍历 迭代效率更高</p><p>在forEach 里面 return 不会终止迭代</p><pre><code class="js">var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];arr.some(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在 some 里面 return true 就终止遍历 迭代效率更高        return true;    }    console.log(11);    // 11    // 找到了该元素});var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];// 1. forEach迭代 遍历arr.forEach(function(value) {    if (value == &#39;green&#39;) {        console.log(&#39;找到了该元素&#39;);        // 在forEach 里面 return 不会终止迭代        return true;    }    console.log(11);})// 11// 找到了该元素// 11// 11</code></pre><h3 id="4、indexOf"><a href="#4、indexOf" class="headerlink" title="4、indexOf()"></a>4、indexOf()</h3><p>在数组中搜索元素值并返回其位置</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.indexOf(&quot;Apple&quot;); // 0</code></pre><h3 id="5、lastIndexOf"><a href="#5、lastIndexOf" class="headerlink" title="5、lastIndexOf()"></a>5、lastIndexOf()</h3><p>在数组中搜索元素值并返回其位置，从数组结尾开始搜索</p><pre><code class="js">var fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;); // 2</code></pre><h3 id="6、find"><a href="#6、find" class="headerlink" title="6、find()"></a>6、find()</h3><p>返回通过测试函数的第一个数组元素的值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.find(function(value) {    return value &gt; 18;})console.log(first); // 25 第一个比18大的值</code></pre><h3 id="7、findIndex"><a href="#7、findIndex" class="headerlink" title="7、findIndex()"></a>7、findIndex()</h3><p>返回通过测试函数的第一个数组元素的索引</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(function(value) {    return value &gt; 18;})console.log(first); // 3 第一个比18大的值的索引号是3</code></pre><h3 id="8、map"><a href="#8、map" class="headerlink" title="8、map()"></a>8、map()</h3><p>对每个数组元素执行函数来创建新数组，不会更改原始数组。</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.map(function(value) {    return value * 2;})console.log(first); // [2, 4, 6] 将每个数组值乘以2</code></pre><h3 id="9、reduce-reduceRight"><a href="#9、reduce-reduceRight" class="headerlink" title="9、reduce() reduceRight()"></a>9、reduce() reduceRight()</h3><p>在每个数组元素上运行函数，以生成（减少它）单个值</p><p>reduceRight() 方法在数组中从左到右工作</p><pre><code class="js">var numbers = [1, 2, 3];var first = numbers.reduce(function(total, value) {    return total + value;})console.log(first); // 6 总和为6</code></pre><h3 id="10、every"><a href="#10、every" class="headerlink" title="10、every()"></a>10、every()</h3><p>检查所有数组值是否通过测试，返回布尔值</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.every(function(value) {    return value &gt; 18;})console.log(first); // false(并非所有元素都大于18)</code></pre><h2 id="三、数组排序"><a href="#三、数组排序" class="headerlink" title="三、数组排序"></a>三、数组排序</h2><h3 id="1、reverse-反转数组"><a href="#1、reverse-反转数组" class="headerlink" title="1、reverse() 反转数组"></a>1、reverse() 反转数组</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse(); // Mango,Apple,Orange,Banana</code></pre><h3 id="2、sort-以字母方式排序"><a href="#2、sort-以字母方式排序" class="headerlink" title="2、sort() 以字母方式排序"></a>2、sort() 以字母方式排序</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.sort(); // Apple,Banana,Mango,Orange</code></pre><h3 id="3、sort-以数字方式排序"><a href="#3、sort-以数字方式排序" class="headerlink" title="3、sort() 以数字方式排序"></a>3、sort() 以数字方式排序</h3><p>如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b}); // 1,5,10,25,40,100</code></pre><p>通过一个比值函数，对数组进行降序排序。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a}); // 100,40,25,10,5,1</code></pre><h3 id="4、sort-随机排序"><a href="#4、sort-随机排序" class="headerlink" title="4、sort() 随机排序"></a>4、sort() 随机排序</h3><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return 0.5 - Math.random()});// 40,10,5,100,1,25  随机生成排序// 5,40,100,25,1,10</code></pre><h3 id="5、sort-查找最高-最低数组值"><a href="#5、sort-查找最高-最低数组值" class="headerlink" title="5、sort() 查找最高/最低数组值"></a>5、sort() 查找最高/最低数组值</h3><p>升序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return a - b});// 现在 points[0] 包含最低值// 而 points[points.length-1] 包含最高值</code></pre><p>降序排序</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b) {    return b - a});// 现在 points[0] 包含最高值// 而 points[points.length-1] 包含最低值</code></pre><h3 id="6、Math-max-apply-查找最高数组值"><a href="#6、Math-max-apply-查找最高数组值" class="headerlink" title="6、Math.max.apply() 查找最高数组值"></a>6、Math.max.apply() 查找最高数组值</h3><p>apply() 第二个参数须是数组，与 <code>Math.max</code> 相结合使用。</p><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> .</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.max.apply(Math, points)var a = Math.max.apply(null, points) // null 也可以console.log(a); // 100</code></pre><h3 id="7、Math-min-apply-查找最低数组值"><a href="#7、Math-min-apply-查找最低数组值" class="headerlink" title="7、Math.min.apply() 查找最低数组值"></a>7、Math.min.apply() 查找最低数组值</h3><p><code>Math.max.apply([1, 2, 3])</code> 等于 <code>Math.max(1, 2, 3)</code> 。</p><pre><code class="js">var points = [40, 100, 1, 5, 25, 10];var a = Math.min.apply(Math, points)console.log(a); // 1</code></pre><p><img src="http://mdimg.95408.com/20191213144049.png" alt="20191213144049"></p><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数组（一）</title>
      <link href="/2019/12/23/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/23/js/JavaScript%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1、数组是一种特殊的变量，它能够一次存放一个以上的值。</p><p>2、数组是一种特殊类型的对象，在 JavaScript 中对数组使用 typeof 运算符会返回 “object”。JavaScript 数组最好以数组来描述。</p><p>4、数组使用数字来访问其“元素”，对象使用名称来访问其“成员”。数组和对象的区别：数组使用数字索引、象使用命名索引。数组是特殊类型的对象，具有数字索引。</p><p><code>var person = [&quot;Bill&quot;, &quot;Gates&quot;, 62];</code> 使用： <code>person[0]</code> </p><p><code>var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:46};</code> 使用： <code>person.firstName</code> </p><p>5、如果希望元素名为字符串（文本）则应该使用对象、如果希望元素名为数字则应该使用数组。</p><p>6、可以在数组保存对象、函数、甚至是数组；</p><p><code>myArray[0] = Date.now;  myArray[1] = myFunction;  myArray[2] = myCars;</code> </p><h3 id="1、定义数组"><a href="#1、定义数组" class="headerlink" title="1、定义数组"></a>1、定义数组</h3><pre><code class="js">var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];// 以逗号隔开；// 最后不要加逗号；// var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);// 尽量不要使用 new Array() ，执行效率更低；</code></pre><h3 id="2、-识别数组"><a href="#2、-识别数组" class="headerlink" title="2、 识别数组"></a>2、 识别数组</h3><pre><code class="js">typeof cars; // 返回 object// typeof 运算符返回 &quot;object&quot;，因为 JavaScript 数组属于对象。Array.isArray(cars); // 返回 true</code></pre><h3 id="3、访问数组元素"><a href="#3、访问数组元素" class="headerlink" title="3、访问数组元素"></a>3、访问数组元素</h3><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);console.log(cars[0]); // Saab</code></pre><h3 id="4、改变数组元素"><a href="#4、改变数组元素" class="headerlink" title="4、改变数组元素"></a>4、改变数组元素</h3><p>通过使用它们的索引号来访问、更改数组元素</p><pre><code class="js">var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);cars[0] = &#39;abc&#39;console.log(cars[0]); // abc</code></pre><h3 id="5、访问完整数组"><a href="#5、访问完整数组" class="headerlink" title="5、访问完整数组"></a>5、访问完整数组</h3><pre><code class="js">var cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;];document.getElementById(&quot;demo&quot;).innerHTML = cars; &lt;p id = &quot;demo&quot; &gt; &lt; /p&gt;//&lt;p id=&quot;demo&quot;&gt;Audi,BMW,porsche&lt;/p&gt;</code></pre><h2 id="数组属性方法"><a href="#数组属性方法" class="headerlink" title="数组属性方法"></a>数组属性方法</h2><h3 id="1、length-属性"><a href="#1、length-属性" class="headerlink" title="1、length 属性"></a>1、length 属性</h3><p>返回数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.length; // 4</code></pre><h3 id="2、length-访问最后一个元素"><a href="#2、length-访问最后一个元素" class="headerlink" title="2、length 访问最后一个元素"></a>2、length 访问最后一个元素</h3><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var first = fruits[0]; // 访问第一个元素var last = fruits[fruits.length - 1]; // Mango// str.length 为长度4，减1表示是索引3（索引从0开始）</code></pre><h3 id="3、push-、length添加元素"><a href="#3、push-、length添加元素" class="headerlink" title="3、push()、length添加元素"></a>3、push()、length添加元素</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Lemon&quot;); // 向 fruits 添加一个新元素 (Lemon)var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[fruits.length] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// str.length是数组长度，比索引大1（索引从0开始）// 等于在原来最大索引+1的位置添加元素</code></pre><h3 id="4、添加元素时的空位"><a href="#4、添加元素时的空位" class="headerlink" title="4、添加元素时的空位"></a>4、添加元素时的空位</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits[6] = &quot;Lemon&quot;; // 向 fruits 添加一个新元素 (Lemon)// Banana// Orange// Apple// Mango// undefined 添加最高索引的元素可在数组中创建未定义的“洞”：// undefined// Lemon</code></pre><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="1、toString-转为字符串"><a href="#1、toString-转为字符串" class="headerlink" title="1、toString() 转为字符串"></a>1、toString() 转为字符串</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.toString()); // Banana,Orange,Apple,Mangoconsole.log(fruits); // 也可以直接调用// 所有 JavaScript 对象都拥有 toString() 方法。</code></pre><h3 id="2、join-转字符串"><a href="#2、join-转字符串" class="headerlink" title="2、join() 转字符串"></a>2、join() 转字符串</h3><p>类似 toString()，但是您还可以规定分隔符</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.join(&#39;*&#39;)); // Banana*Orange*Apple*Mango</code></pre><h3 id="3、pop-删除最后元素"><a href="#3、pop-删除最后元素" class="headerlink" title="3、pop() 删除最后元素"></a>3、pop() 删除最后元素</h3><p>1、pop() 删除最后元素，返回被删除元素</p><p>2、push() 在最后增加元素，返回数组长度</p><p>3、shift() 删除开始元素，返回被删除元素</p><p>4、unshift() 在开始增加元素，返回数组长度</p><p>返回被删除的值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.pop()// console.log(fruits.pop()); // Mango// console.log(fruits); // Banana,Orange,Apple</code></pre><h3 id="4、push-在最后增加元素"><a href="#4、push-在最后增加元素" class="headerlink" title="4、push() 在最后增加元素"></a>4、push() 在最后增加元素</h3><p>返回新数组的长度值</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var f = fruits.push(&#39;Kiwi&#39;);// console.log(f); // 5// console.log(fruits); // Banana Orange Apple Mango Kiwi</code></pre><h3 id="5、shift-删除第一个元素"><a href="#5、shift-删除第一个元素" class="headerlink" title="5、shift() 删除第一个元素"></a>5、shift() 删除第一个元素</h3><p>返回被“位移出”的字符串</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift(); // 返回 &quot;Banana&quot;</code></pre><h3 id="6、unshift-在最前面增加元素"><a href="#6、unshift-在最前面增加元素" class="headerlink" title="6、unshift() 在最前面增加元素"></a>6、unshift() 在最前面增加元素</h3><p>返回新数组的长度</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Lemon&quot;); // 返回 5</code></pre><h3 id="7、delete-删除元素"><a href="#7、delete-删除元素" class="headerlink" title="7、delete 删除元素"></a>7、delete 删除元素</h3><p>使用 delete 会在数组留下未定义的空洞。请使用 pop() 或 shift() 取而代之。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];delete fruits[0]; // 把 fruits 中的首个元素改为 undefined</code></pre><h3 id="8、splice-向数组添加新项"><a href="#8、splice-向数组添加新项" class="headerlink" title="8、splice() 向数组添加新项"></a>8、splice() 向数组添加新项</h3><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi,Apple,Mango</code></pre><p>第一个参数（2）定义了应添加新元素的位置（拼接）。</p><p>第二个参数（0）定义应删除多少元素。</p><p>其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。</p><p>splice() 方法返回一个包含已删除项的数组：</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(2, 2, &quot;Lemon&quot;, &quot;Kiwi&quot;);// 原数组： Banana,Orange,Apple,Mango// 新数组： Banana,Orange,Lemon,Kiwi// 已删除项： Apple,Mango</code></pre><h3 id="8、splice-删除元素"><a href="#8、splice-删除元素" class="headerlink" title="8、splice() 删除元素"></a>8、splice() 删除元素</h3><p>第一个参数（0）定义新元素应该被添加（接入）的位置。</p><p>第二个参数（1）定义应该删除多个元素。</p><p>其余参数被省略。没有新元素将被添加。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.splice(0, 1); // 删除 fruits 中的第一个元素 Banana// 原数组： Banana,Orange,Apple,Mango// 新数组： Orange,Apple,Mangofruits.splice(1, 2); // Banana,Mango</code></pre><h3 id="9、concat-合并、连接数组"><a href="#9、concat-合并、连接数组" class="headerlink" title="9、concat() 合并、连接数组"></a>9、concat() 合并、连接数组</h3><p>concat() 方法不会更改现有数组。它总是返回一个新数组。</p><p>concat() 方法可以使用任意数量的数组参数：</p><p>concat() 方法也可以将值作为参数：</p><pre><code class="js">var arr1 = [&quot;Cecilie&quot;, &quot;Lone&quot;];var arr2 = [&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;];var arr3 = [&quot;Robin&quot;, &quot;Morgan&quot;];arr1.concat(arr2); // 将arr1 与 arr2 连接在一起arr1.concat(arr2, arr3); // 将arr1、arr2 与 arr3 连接在一起arr1.concat([&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;]); // 也可以将值作为参数</code></pre><h3 id="10、slice-裁剪新数组"><a href="#10、slice-裁剪新数组" class="headerlink" title="10、slice() 裁剪新数组"></a>10、slice() 裁剪新数组</h3><p>slice() 方法创建新数组。它不会从源数组中删除任何元素。</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.slice(1); // Orange,Lemon,Apple,Mangofruits.slice(3); // Apple,Mango</code></pre><p>slice() 可接受两个参数，从开始参数选取元素，直到结束参数（不包括）为止。</p><p>第2个参数可省略，表示从第1个参数往后所有的元素；</p><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(1, 3); // Orange,Lemon</code></pre><p><img src="http://mdimg.95408.com/201912130047_162.png?imageView2/2/w/1200/h/1200" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github</title>
      <link href="/2019/12/23/tools/git%E5%92%8Cgithub/"/>
      <url>/2019/12/23/tools/git%E5%92%8Cgithub/</url>
      
        <content type="html"><![CDATA[<h1 id="git-本地仓库"><a href="#git-本地仓库" class="headerlink" title="git 本地仓库"></a>git 本地仓库</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>Git 使用前配置</strong></p><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li>配置提交人姓名： <code>git config --global user.name 提交人姓名</code> </li><li>配置提交人姓名： <code>git config --global user.email 提交人邮箱</code> </li><li>查看git配置信息： <code>git config --list</code> </li></ol><p><strong>提交步骤</strong></p><ol><li><code>git init</code> 初始化git仓库</li><li><code>git status</code> 查看文件状态</li><li><code>git add 文件列表</code> 追踪文件/提交到暂存区</li><li><code>git commit -m 提交信息</code> 向仓库中提交代码</li><li><code>git log</code> 查看提交记录</li></ol><p><strong>撤销</strong></p><ul><li>用暂存区中的文件覆盖工作目录中的文件： <code>git checkout 文件</code> </li><li>将文件从暂存区中删除： <code>git rm --cached 文件</code> </li><li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录： <code>git rest --hard commitID</code> （ID号可以通过 <code>git log</code> 查看） </li></ul><p><strong>分支命令</strong></p><ul><li><code>git branch</code> 查看分支</li><li><code>git branch 分支名称</code> 创建分支</li><li><code>git checkout 分支名称</code> 切换分支</li><li><code>git merge 来源分支</code> 合并分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支被合并后才允许删除）（-D 强制删除）</li></ul><p><strong>暂时保存更改</strong></p><ul><li>存储临时改动： <code>git stash</code> </li><li>恢复改动： <code>git stash pop</code> </li></ul><h2 id="创建-git-init"><a href="#创建-git-init" class="headerlink" title="创建 git init"></a>创建 git init</h2><p>进入到一个目标管理文件夹，输入 <code>init</code> 命令创建完成；</p><pre><code class="git">$ git init  // 初始化工作区，创建.git的隐藏文件夹</code></pre><h2 id="保存-git-add-commit"><a href="#保存-git-add-commit" class="headerlink" title="保存 git add / commit"></a>保存 git add / commit</h2><p>保存一个文件的版本：</p><pre><code class="git">$ git add code1.py   // 保存到暂存区$ git commit -m &#39;这是第一个版本&#39;   // 保存到本地文件库</code></pre><p>再保存一个文件的另一个版本：</p><pre><code class="git">$ git add code1.py$ git commit -m &#39;这是第二个版本&#39;</code></pre><p>将工作区所有文件保存到暂存区：</p><pre><code class="git">$ git add .</code></pre><h2 id="查看版本-git-log"><a href="#查看版本-git-log" class="headerlink" title="查看版本 git log"></a>查看版本 git log</h2><p>查看文件多个版本：</p><pre><code class="git">$ git logcommit 699977fa2a89db2dabc8bf9c1d2e17f23dc4a73f (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 15:02:37 2019 +0800    &#39;这是第二个版本。&#39;commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>以简短形式显示：</p><pre><code class="git">$ git log --pretty=oneline</code></pre><p>ps.win窗口使用命令行<strong>不能显示中文字符</strong>：</p><p>使用 <code>Git Bash</code> 窗口，右键设置–文本设置为 <code>zh_ch UTF-8</code> 退出重新进入即可。</p><h2 id="回退-git-reset"><a href="#回退-git-reset" class="headerlink" title="回退 git reset"></a>回退 git reset</h2><p>回到第一个版本：</p><p>HEAD^ 前一个版本；HEAD^^ 前两个版本；HEAD<del>1 前一个版本；HEAD</del>100 前100个版本；</p><pre><code class="git">$ git reset --hard HEAD^commit 325e516e92d3c14a9a4e0208fc89a967c7ae9154 (HEAD -&gt; master)Author: yuan &lt;740040915@qq.com&gt;Date:   Wed Oct 16 14:59:45 2019 +0800    &#39;这是第一个版本。&#39;</code></pre><p>通过版本号回到第二个版本：</p><pre><code class="git">$ git reset --hard 6999HEAD is now at 699977f &#39;这是第二个版本。&#39;</code></pre><p>如果退回到第一版本记录后，即出终端就找不到第二版本的版本号时，我们可以使用 <code>git reflog</code> 查看操作记录，得到最前面的版本号；如下， <code>699977f</code> 就是第二个版本的版本号。</p><pre><code class="git">$ git reflog699977f (HEAD -&gt; master) HEAD@{0}: reset: moving to 6999325e516 HEAD@{1}: reset: moving to HEAD^699977f (HEAD -&gt; master) HEAD@{2}: commit: &#39;这是第二个版本。&#39;325e516 HEAD@{3}: commit (initial): &#39;这是第一个版本。&#39;</code></pre><h2 id="工作区-暂存区"><a href="#工作区-暂存区" class="headerlink" title="工作区 暂存区"></a>工作区 暂存区</h2><p>保存文件的 git_test 是工作区；</p><p>git_test 文件夹下的 .git 文件夹是版本库；其中包含暂存区；</p><p>git add 将文件添加到暂存区； git commit 把暂存区所有内容提交到当前分支，创建版本记录；</p><pre><code class="git">$ git add XXX$ git commit -m 保存到本地文件库要增加的说明文字</code></pre><p>查看未处理提交的文件状态：</p><pre><code class="git">$ git status</code></pre><h2 id="撤销修改-git-checkout"><a href="#撤销修改-git-checkout" class="headerlink" title="撤销修改 git checkout"></a>撤销修改 git checkout</h2><p>文件没有保存到暂存区时，取消修改：</p><pre><code class="git">git checkout -- code2.txt</code></pre><p>文件通过git add code2.txt 保存到了暂存区，取消修改：</p><pre><code class="git">git reset HEAD code2.txt  # 先取消暂存git checkout -- code2.txt # 和上一步一样，取消修改</code></pre><p>如果已经提交到了版本库（git commit -m ‘版本4’），就通过版本回退</p><pre><code class="git">$ git reset --hard HEAD^</code></pre><h2 id="查看不同-git-diff"><a href="#查看不同-git-diff" class="headerlink" title="查看不同 git diff"></a>查看不同 git diff</h2><p>查看工作区与之前版本的不同：</p><pre><code class="git">$ git diff HEAD -- code1.py</code></pre><p>查看上个版本和上上个版本的不同：</p><pre><code class="git">$ git diff Head HEAD^ -- code1.py</code></pre><h2 id="删除文件-git-rm"><a href="#删除文件-git-rm" class="headerlink" title="删除文件 git rm"></a>删除文件 git rm</h2><pre><code class="git">git add code2.txt  # 文件提交到了暂存区rm code2.txt  # 工作区删除文件git rm code2.txt # 将删除提交到暂存区git commit -m &#39;删除后提交的版本&#39;  # 将删除后提交一个版本# 删除后恢复与撤销修改相同</code></pre><h2 id="切换分支-git-branch"><a href="#切换分支-git-branch" class="headerlink" title="切换分支 git branch"></a>切换分支 git branch</h2><p>查看当前所有分支：git branch</p><pre><code class="git">$ git branch* master</code></pre><p>创建分支：git branch dev</p><pre><code class="git">// 创建新分支后：$ git branch* master  // 当前分支  dev  // 新创建的分支</code></pre><p>切换分支：git checkout dev</p><pre><code class="git">// 切换分支后：$ git branch  master* dev  // 当前分支为dev</code></pre><p>创建并切换分支：git checkout -b dev</p><pre><code class="git">$ git checkout -b dev$ git branch* dev  master</code></pre><p>切换回master分支：git checkout master</p><pre><code class="git">$ git checkout master$ git branch  dev* master</code></pre><p>在dev分支上做修改并提交后，可以切换到master分支，并使用以下方式合并dev分支；</p><h2 id="合并分支-git-merge"><a href="#合并分支-git-merge" class="headerlink" title="合并分支 git merge"></a>合并分支 git merge</h2><p>回到主分支master上，合并dev分支：git merge dev</p><pre><code class="git">$ git merge dev</code></pre><h2 id="删除分支-git-branch"><a href="#删除分支-git-branch" class="headerlink" title="删除分支 git branch"></a>删除分支 git branch</h2><p>分支上所有内容都合并到主分支时，可以删除分支：git branch -d dev</p><pre><code class="git">$ git branch -d dev// 如果没有合并子分支上的内容，并需要强制合并，改成大写 -D</code></pre><h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>当切换到dev分支修改code.txt并提交add、commit；</p><p>又切换回master分支修改code.txt并提交add、commit；</p><p>将dev分支合并到master时（git merge dev），会出现冲突；</p><p>（现在在master分支当中），手动修改code.txt冲突文件，并再次add、commit提交；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>当在dev分支修改一个文件，并提交commit；</p><p>又在master分支增加一个新文件，并提交commit；</p><p>此时，在两个不同分支下有两个不同的提交；</p><p>此时合并时，git会提示输入一个分支注释文字，并自动创建一个新的分支；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="禁用快速合并-–no-ff"><a href="#禁用快速合并-–no-ff" class="headerlink" title="禁用快速合并 –no-ff"></a>禁用快速合并 –no-ff</h2><p>在dev分支上做了修改并提交一个分支为“dev分支”；</p><p>切换回master分支，将dev分支合并：</p><pre><code class="git">$ git merge dev</code></pre><p>无冲突时，git会使用快速合并 <code>Fast forward</code> ，如果我们要保存分支信息时，需要禁止快速合并；</p><pre><code class="git">$ git merge --no-ff -m &#39;禁用fast forward版本&#39; dev</code></pre><p>此时，原来dev创建的“dev分支”会保留下来，</p><p>并会创建一个新的分支：“禁用fast forward版本”；</p><p>可以通过 <code>git log  --pretty=oneline --graph</code> 查看两个分支的合并情况；</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p><strong>禁用快速合并的情况</strong></p><p>当我们在dev分支进行工作时，需要临时进入一个临时分支进行bug处理；</p><p>可以先将当前分支存储起来：</p><pre><code class="git">git stash</code></pre><p>此时我们使用 <code>git status</code> 查看，变成了干净的工作区；</p><p>切换回master分支：git checkout master</p><p>创建一个临时分支：bug-001；</p><p>修改bug完成，提交commit一个“修改bug-001版本”；</p><p>切换回master分支；</p><p>此时如果直接合并分支，就没有修改bug-001版本的记录；</p><p>我们就采用禁用快速合并的处理方式；</p><p>合并临时分支：bug-001；</p><pre><code class="git">git merge --no-ff -m &quot;修复bug后的版本&quot; bug-001</code></pre><h2 id="存储工作现场-git-stash-暂时保存更改"><a href="#存储工作现场-git-stash-暂时保存更改" class="headerlink" title="存储工作现场 git stash 暂时保存更改"></a>存储工作现场 git stash 暂时保存更改</h2><p>当我们在dev分支上工作时，需要临时进入master分支上做修改，</p><p>只需在分支上临时保存，再进入master分支操作保存。</p><p>返回dev分支上重新开始工作。</p><pre><code class="git">git stash  // 当前在dev分支，暂存文件$ git statusOn branch dev  // 当前在dev分支nothing to commit, working tree clean  // 暂存文件后，分支变干净了</code></pre><p>回到master分支，进行bug修改，保存：</p><pre><code class="git">git checkout master</code></pre><p>查看存储的工作记录：</p><pre><code class="git">git stash list</code></pre><p>在master分支上完成操作后，返回到dev分支上，恢复工作记录：</p><pre><code class="git">git checkout dev   // 返回dev分支git stash pop   // 恢复工作记录</code></pre><h1 id="github-远程仓库"><a href="#github-远程仓库" class="headerlink" title="github 远程仓库"></a>github 远程仓库</h1><p><img src="http://mdimg.95408.com/201912171203_333.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="1、-A-将新项目-push-至-github"><a href="#1、-A-将新项目-push-至-github" class="headerlink" title="1、  A 将新项目 push 至 github"></a>1、  A 将新项目 push 至 github</h2><p>(1)、A 将地址文件夹1215_git中的项目修改完成，保存到本地仓库；</p><p>(2)、A 在 github.com 上创建一个新项目：1215_git；并得到了项目远程地址： <code>https://github.com/yuanshengorg/1215_git.git</code> 。</p><p>(3)、A 将本地项目 push 至远程仓库：master 表示本地仓库的分支；</p><pre><code class="git">$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>将远程地址改为简短别名：</p><pre><code class="git">$ git remote add origin https://github.com/yuanshengorg/1215_git.gitorigin 表示将远程地址改为的别名</code></pre><p>通过别名推送到远程仓库：</p><pre><code class="git">$ git push origin master</code></pre><p>在第一次推送时，加上 -u 记录：</p><pre><code class="git">$ git push -u origin master</code></pre><p>下一次推送可以更简单：</p><pre><code class="git">$ git push</code></pre><h2 id="2、-B-将项目-clone-到-本地"><a href="#2、-B-将项目-clone-到-本地" class="headerlink" title="2、 B 将项目 clone 到 本地"></a>2、 B 将项目 clone 到 本地</h2><p>在网站上获取 Clone 地址：</p><p><img src="http://mdimg.95408.com/201912171139_943.png?imageView2/2/w/1200/h/1200" alt=""></p><p>克隆远端数据仓库到本地： <code>git clone 仓库地址</code> </p><pre><code class="git">git clone https://github.com/yuanshengorg/1215_git.git</code></pre><h2 id="3、-B-将项目修改后-push-至-github"><a href="#3、-B-将项目修改后-push-至-github" class="headerlink" title="3、 B 将项目修改后 push 至 github"></a>3、 B 将项目修改后 push 至 github</h2><p>B 将项目克隆到本地后，直接在本地修改，add 至暂存区，commit 至本地仓库；</p><p>完成修改，上传到 A 创建的项目远程仓库：</p><pre><code class="git">$ git push origin master   // A 创建的远程地址别名 B 也可以使用或者：$ git push https://github.com/yuanshengorg/1215_git.git master</code></pre><p>B 如果想摄推送内容至 A 的仓库，需要 A 设置一下：邀请 B 为团队成员。</p><p><img src="http://mdimg.95408.com/201912171157_660.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="4、-A-拉取远程仓库中最新的版本"><a href="#4、-A-拉取远程仓库中最新的版本" class="headerlink" title="4、 A 拉取远程仓库中最新的版本"></a>4、 A 拉取远程仓库中最新的版本</h2><p>拉取远程仓库中最新的版本： <code>git pull 远程仓库地址 分支名称</code> </p><pre><code class="git">$ git pull origin master或者：$ git pull https://github.com/yuanshengorg/1215_git.git master</code></pre><p>git clone 是完全克隆；</p><p>git pull 是本地已有项目，只拉取远程仓库中更新的内容；</p><h2 id="SSH-推送"><a href="#SSH-推送" class="headerlink" title="SSH 推送"></a>SSH 推送</h2><p><img src="http://mdimg.95408.com/201912171137_313.png?imageView2/2/w/1200/h/1200" alt=""></p><pre><code class="git">$ ssh-keygen</code></pre><p>会在本地（/c/Users/用户名/.ssh/）生成：id_rsa 文件和 id_rsa.pub 文件；</p><p>将 <code>id_rsa.pub</code> 文件打开复制内容设置到 github.com 网站上，即可。</p><p>github.com ——右上角个人中心——settings——SSH and GPG keys——SSH keys，新增保存即可。</p><p><img src="http://mdimg.95408.com/201912171135_162.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="跨团队合作："><a href="#跨团队合作：" class="headerlink" title="跨团队合作："></a>跨团队合作：</h2><ol><li>程序员 C fork仓库</li><li>程序员 C 将仓库克隆在本地进行修改</li><li>程序员 C 将仓库推送到远程</li><li>程序员 C 发起pull reqest</li><li>原仓库作者审核</li><li>原仓库作者合并代码</li></ol><h2 id="忽略清单文件创建："><a href="#忽略清单文件创建：" class="headerlink" title="忽略清单文件创建："></a>忽略清单文件创建：</h2><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。</p><p>git忽略清单文件名称：<strong>.gitignore</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo创建博客</title>
      <link href="/2019/12/23/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/23/tools/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912180011_408.png?imageView2/2/w/1200/h/1200" alt=""></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="node-js-和-npm"><a href="#node-js-和-npm" class="headerlink" title="node.js 和 npm"></a>node.js 和 npm</h3><p>Hexo是基于nodejs的静态博客，首先需要安装nodejs，并且需要nodejs中的重要工具： <code>npm</code> ；</p><p>查看 nodejs 版本： <code>node -V</code> ；</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>有了nodejs，其他就简单了！安装hexo： <code>npm install -g hexo</code> ；</p><p>查看 hexo 版本： <code>hexo -v</code> ；</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>你也可以安装一个必备的代码管理工具： <code>git</code> ；这样我们就可以使用 <code>git bash</code> 这个工具了；</p><p>查看 git 版本： <code>git version</code> ；</p><h2 id="创建-hexo"><a href="#创建-hexo" class="headerlink" title="创建 hexo"></a>创建 hexo</h2><p>我们在本地创建一个文件夹 <code>d\hexo</code> 做为博客的目录；</p><p>只需3步，完成博客的搭建：</p><p>1、在 <code>d\hexo</code> 目录下，执行以下命令，创建 hexo 完成；</p><pre><code class="git">hexo init</code></pre><p>2、开始书写文章：</p><pre><code class="git">hexo new &#39;我的第一篇hexo博客文章&#39;</code></pre><p>3、运行本地博客服务器：</p><pre><code class="git">$ hexo s    INFO  Start processing    INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>此时，我们在浏览器当中输入： <code>http://local:4000</code> 即可查看网站。</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>使用以下命令创建文章，我们就可以通过 <code>D:\hexo\source\_posts</code> 查看创建的文件，开始创作即可。</p><pre><code class="git">$ hexo new [layout] &lt;title&gt;</code></pre><p>或者直接将md文章放入到 <code>D:\hexo\source\_posts</code> 目录下；</p><h2 id="文章预定义参数"><a href="#文章预定义参数" class="headerlink" title="文章预定义参数"></a>文章预定义参数</h2><p>我们在md文章形状，使用yaml定义标题、分类、标签、日期等等，可以自己增减。</p><pre><code class="yaml">---title: 文章标题date： 日期categories: 分类tags: 标签---</code></pre><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">官方文档：更多预先定义的参数</a></p><p>如果是有子分类：</p><pre><code class="yaml">categories: [父分类， 子分类]</code></pre><p>如果是有多个标签：</p><pre><code class="yaml">tags: [标签1， 标签2]</code></pre><h2 id="搭建到-github"><a href="#搭建到-github" class="headerlink" title="搭建到 github"></a>搭建到 github</h2><p>1、创建 github 账号，并创建 ssh （参考：<a href="https://yuanshengorg.github.io/2019/12/17/tools/git%E5%92%8Cgithub/#SSH-%E6%8E%A8%E9%80%81" target="_blank" rel="noopener">git和github：SSH</a>）； </p><p>2、在自己的账号下，新建一个repo： <code>New repository</code> （github右上角 + 号——New repository）；</p><p>3、项目名称（Repository name）为： <code>你的名称.github.io</code> ，如 <code>yuansheng.github.io</code> ；</p><p><img src="http://mdimg.95408.com/201912172352_728.png?imageView2/2/w/1200/h/1200" alt=""></p><p>4、回到本地文件夹： <code>d/hexo</code> ，修改文件： <code>_config.yml</code> ：</p><pre><code class="git">deploy:  type: git  repo: https://github.com/yuansheng/yuansheng.github.io.git  branch: master</code></pre><p>repo 请修改为你创建的地址。</p><p>5、安装工具：hexo-deployer-git</p><pre><code class="git">npm install hexo-deployer-git --save</code></pre><p>6、回到命令行工具运行：</p><pre><code class="git">hexo clean // 清除之前生成的文件hexo generate   // 生成新的静态文件hexo depoly   // 部署网站</code></pre><p>执行 <code>hexo depoly</code> 时，第一次可能会需要注册 github.com 的账号及密码；</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>输入 <code>yuansheng.github.io</code> ，即你设置的项目文件名，即可访问网站；</p><p>你也可以绑定自己的域名，如 <code>www.yuanblogname.com</code> ；</p><h2 id="增-改文章"><a href="#增-改文章" class="headerlink" title="增/改文章"></a>增/改文章</h2><p>上面的三个命令 <code>hexo clean / generate / depoly</code> 可简写为：</p><pre><code class="git">hexo cleanhexo ghexo d</code></pre><p>以后每次在文件夹中增加、修改了 md 文章后，执行这三个命令即可；</p><p>所有在本地电脑上修改的文档，远程博客也就修改了。</p><h2 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h2><p><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo官方文档：指令</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档：中文</a></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo折腾记录更新</title>
      <link href="/2019/12/23/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/12/23/tools/Hexo%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新中 …</p></blockquote><hr><h2 id="不能出现双大括号"><a href="#不能出现双大括号" class="headerlink" title="不能出现双大括号"></a>不能出现双大括号</h2><blockquote><p>20191223</p></blockquote><p>不能生成markdown格式：</p><pre><code class="git">D:\hexo&gt;hexo s (line number probably different from source)</code></pre><p>原因：不在在非代码块之外显示：</p><pre><code class="js">{    {}}</code></pre><hr><h2 id="增加域名，备份git仓库"><a href="#增加域名，备份git仓库" class="headerlink" title="增加域名，备份git仓库"></a>增加域名，备份git仓库</h2><blockquote><p>20191218</p></blockquote><ul><li>绑定独立域名： <code>halfbamboo.com</code> ；</li><li>文件备份到 <code>git</code> 仓库；</li></ul><hr><h2 id="修改主题及压缩css-js"><a href="#修改主题及压缩css-js" class="headerlink" title="修改主题及压缩css/js"></a>修改主题及压缩css/js</h2><blockquote><p>20191218</p></blockquote><ul><li>修改博客主题的CSS样式；</li><li>增加 pulyfile.js 压缩 html/css/js；（放弃）</li><li>增加 hexo-neat 插件压缩 css/js；（html未能压缩）</li></ul><p><img src="http://mdimg.95408.com/201912182118_637.png?imageView2/2/w/1200/h/1200" alt="修改后的3-hexo主题"></p><hr><h2 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h2><blockquote><p>20191217</p></blockquote><ul><li>本地创建hexo博客： <code>d:/hexo</code> ；</li><li>更换主题： <code>hexo-theme-3-hexo</code> ；</li><li>上传至 ` github.com；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法CSS表现测试</title>
      <link href="/2019/12/23/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/12/23/tools/Markdown%E8%AF%AD%E6%B3%95CSS%E8%A1%A8%E7%8E%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p><strong>代码：</strong> <code>``</code></p><p><code>$ npm install hexo-cli -g</code> </p><pre><code class="shell">$ npm install hexo-cli -g</code></pre><p><strong>列表：</strong> <code>1.</code> </p><ol><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ol><p><strong>列表：</strong> <code>-</code> </p><ul><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li><li>脚踏实地、开拓进取</li></ul><p><strong>链接：</strong> <code>[]()</code> </p><p><a href="http://www.halfbamboo.com" target="_blank" rel="noopener">半根竹子的官方网站</a></p><p><strong>块引用：</strong> <code>&gt;</code> </p><blockquote><p>回归20年，背靠 <code>祖国</code> 、面向世界的澳门特区迎来一次次发展机遇；脚踏实地、开拓进取的澳门创业者站上更为广阔的发展舞台。</p></blockquote><p><strong>水平分割线：</strong> <code>------</code> </p><hr><p><strong>代码块：</strong> </p><pre><code class="js">fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.forEach(function(v) {    console.log(v);}); // 注释</code></pre><p><strong>图片：</strong></p><p><img src="http://mdimg.95408.com/20191218121717.png" alt="图片说明文字"></p><p><strong>表格：</strong></p><table><thead><tr><th>标题1</th><th>标题2</th><th>标题2</th></tr></thead><tbody><tr><td>一</td><td>二</td><td>三</td></tr><tr><td>html, html, html</td><td>python, python, python</td><td>js, js, js</td></tr><tr><td>css, css, css</td><td>Django, Django, Django</td><td>node, node, node</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 vs code 命令快捷键</title>
      <link href="/2019/12/23/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/"/>
      <url>/2019/12/23/tools/vscode%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1、光标移动到行尾-行首"><a href="#1、光标移动到行尾-行首" class="headerlink" title="1、光标移动到行尾/行首"></a>1、光标移动到行尾/行首</h3><p>当软件自动补全时，我们常常会需要将光标移动到行尾，可以使用 <code>end</code> 键，或者自定义一个更方便的键，比如：<code>Ctrl + ;</code> 。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>END</td><td>cursorEnd   光标移动到行尾</td><td>/</td></tr><tr><td>HOME</td><td>cursorHome   光标移动到行首</td><td><strong>Ctrl + Shift + ;</strong></td></tr><tr><td>无</td><td>cursorLineEnd   光标移动到行尾</td><td><strong>Ctrl + ;</strong></td></tr><tr><td>无</td><td>cursorLineStart   光标移动到行首</td><td>/</td></tr></tbody></table><h3 id="2、选择当前单词"><a href="#2、选择当前单词" class="headerlink" title="2、选择当前单词"></a>2、选择当前单词</h3><p>连续按展开选择，第一次选中当前单词，第二次选择当前行；继续选择当前块；只按一次的话，就是选择当前单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Shift + Alt + Right</td><td>展开选择</td><td><strong>Alt + I</strong></td></tr><tr><td>Shift + Alt + Left</td><td>收起选择</td><td><strong>Alt + O</strong></td></tr></tbody></table><h3 id="3、光标移动到下-上一个单词（取消）"><a href="#3、光标移动到下-上一个单词（取消）" class="headerlink" title="3、光标移动到下/上一个单词（取消）"></a>3、光标移动到下/上一个单词（取消）</h3><p>我们需要将光标跳转到下一个单词或者上一个单词。</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>Ctrl + Right</td><td>cursorWordEndRight   光标移动到右边单词结尾</td><td>/</td></tr><tr><td>Ctrl + Left</td><td>cursorWordStartLeft   光标移动到左边单词开关</td><td>/</td></tr></tbody></table><h3 id="4、不使用方向键上下移动"><a href="#4、不使用方向键上下移动" class="headerlink" title="4、不使用方向键上下移动"></a>4、不使用方向键上下移动</h3><p>我们要将光标上下移动时，使用上、下按键也是不方便，所以 vim 中使用了 <code>h j k l</code> ；</p><table><thead><tr><th>键</th><th>命令</th><th>我的修改</th></tr></thead><tbody><tr><td>DOWN</td><td>cursorDown   向下移动光标</td><td><strong>Alt + J</strong></td></tr><tr><td>UP</td><td>cursorUp   向上移动光标</td><td><strong>Alt + K</strong></td></tr><tr><td>LEFT</td><td>cursorLeft   向左移动光标</td><td><strong>Alt + L</strong></td></tr><tr><td>RIGTH</td><td>cursorRight   向右移动光标</td><td><strong>Alt + ;</strong></td></tr></tbody></table><p><img src="http://mdimg.95408.com/201912251933_357.png?null" alt="自定义vs快捷键"></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="/2019/12/23/vue/Vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/23/vue/Vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h2 id="Vue-模板语法"><a href="#Vue-模板语法" class="headerlink" title="Vue 模板语法"></a>Vue 模板语法</h2><ul><li>原生js拼接字符串</li><li>前端模板引擎（art-template）缺：没有专门提供事件机制</li><li>Vue模板语法</li></ul><p>差值表达式<br>指令<br>事件绑定<br>属性绑定<br>样式绑定<br>分支循环结构</p><h3 id="差值表达式-v-cloak"><a href="#差值表达式-v-cloak" class="headerlink" title="差值表达式 v-cloak"></a>差值表达式 v-cloak</h3><p><strong>什么是指令？</strong></p><p>指令的本质就是自定义属性；以 <code>v-</code> 开头；</p><p><strong>闪动</strong>：html页面被刷新时，会先显示 <code>大括号</code> ，再显示数据；</p><p><strong>v-clack</strong>：先通过样式隐藏内容，然后在内存中进行值的替换，替换完成之后再显示最终的结果；</p><pre><code class="html">&lt;style&gt;    [v-cloak] {        display: none;    }&lt;/style&gt;&lt;body&gt;    &lt;div v-cloak&gt; {{msg}} &lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="更多指令："><a href="#更多指令：" class="headerlink" title="更多指令："></a>更多指令：</h4><blockquote><p>官网：<a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">vuejs.org</a></p></blockquote><p><strong>数据绑定指令：</strong></p><p>v-text、v-html、v-pre</p><h4 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h4><p>没有闪动问题；</p><pre><code class="html">&lt;div v-text=&#39;msg&#39;&gt;&lt;/div&gt;</code></pre><h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>永不用在用户提交的内容上，只适合本网站内部数据；</p><pre><code class="html">&lt;div v-html=&#39;msg1&#39;&gt;&lt;/div&gt;</code></pre><h4 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h4><p>显示原始信息，路过Vue编译过程</p><pre><code class="html">// 直接显示出{{msg}}这个字符串，而不是msg数据的内容&lt;div v-pre&gt;    {{msg}}&lt;/div&gt;</code></pre><h4 id="数据响应式-和-v-once"><a href="#数据响应式-和-v-once" class="headerlink" title="数据响应式 和 v-once"></a>数据响应式 和 v-once</h4><p>数据响应式：数据的变化导致页面内容的变化；</p><p>数据绑定：将数据填充到标签中；</p><p>v-once：只编译一次，显示内容之后不再有响应式的功能；</p><h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h4><p>如果显示的信息后续不需要再修改，可以使用v-once；可以提高性能；</p><pre><code class="html">&lt;div v-once&gt;    {{info}} // info数据只编译一次，不能再改&lt;/div&gt;</code></pre><h4 id="v-model-双向数据绑定"><a href="#v-model-双向数据绑定" class="headerlink" title="v-model 双向数据绑定"></a>v-model 双向数据绑定</h4><p>数据改变，页面内容改变；</p><p>页面内容改变，数据改变；</p><pre><code class="html">&lt;div&gt;{{msg}}&lt;/div&gt;&lt;input type=&#39;text&#39; v-model=&#39;msg&#39; /&gt;</code></pre><h3 id="MVVM-设计思想"><a href="#MVVM-设计思想" class="headerlink" title="MVVM 设计思想"></a>MVVM 设计思想</h3><p>M    ——model</p><p>V    ——view</p><p>VM    ——view-model</p><p>页面input改变数据，通过<strong>事件监听</strong>DOM Listeners改变数据库Model；</p><p>数据通过<strong>数据绑定</strong>Data Bindings传递到View；</p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="v-on-处理事件"><a href="#v-on-处理事件" class="headerlink" title="v-on 处理事件"></a>v-on 处理事件</h4><pre><code class="html">v-on:click=&#39;num++&#39;@click=&#39;num++&#39;</code></pre><p>点击加1：</p><pre><code class="html">&lt;div id=&#39;app&#39;&gt;    &lt;div&gt;{{num}}&lt;/div&gt; // num=1    &lt;button v-on:click=&#39;num++&#39;&gt;点击加1&lt;/button&gt;&lt;/div&gt;</code></pre><h4 id="事件函数调用"><a href="#事件函数调用" class="headerlink" title="事件函数调用"></a>事件函数调用</h4><p>事件绑定-参数传递</p><p>如果事件直接绑定函数名称，默认会传递事件对象作为事件函数的第一个参数；</p><p>如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，名称为：event；</p><pre><code class="html">&lt;div id=&#39;app&#39;&gt;    &lt;div&gt;{{num}}&lt;/div&gt; // num=1    &lt;button @:click=&#39;handle&#39;&gt;点击加1&lt;/button&gt;    &lt;button @:click=&#39;handle(11, 22, $envnt)&#39;&gt;点击加1&lt;/button&gt;    // 可以传参数，事件对象放在最后一个&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: &#39;#app&#39;,        data: {            num: 0        },        methods: {            handle: function(a, b.event) {                //this是Vue的实例对象                console.log(this === vm);                console.log(a, b);                console.log(event.target.innerHTML)                this.num++;            }        }    })&lt;/script&gt;</code></pre><h4 id="事件修饰符-stop-prevent"><a href="#事件修饰符-stop-prevent" class="headerlink" title="事件修饰符 stop prevent"></a>事件修饰符 stop prevent</h4><h4 id="stop阻止冒泡"><a href="#stop阻止冒泡" class="headerlink" title=".stop阻止冒泡"></a>.stop阻止冒泡</h4><pre><code class="html">&lt;a v-on:click.stop=&#39;handle&#39;&gt;跳转&lt;/a&gt;</code></pre><h4 id="prevent-阻止默认行为"><a href="#prevent-阻止默认行为" class="headerlink" title=".prevent 阻止默认行为"></a>.prevent 阻止默认行为</h4><pre><code class="html">&lt;a v-on:click.prvevnet=&#39;handle&#39;&gt;跳转&lt;/a&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（7）博客项目</title>
      <link href="/2019/12/07/node/Untitled/"/>
      <url>/2019/12/07/node/Untitled/</url>
      
        <content type="html"><![CDATA[<h3 id="加密-bcrypt"><a href="#加密-bcrypt" class="headerlink" title="加密 bcrypt"></a>加密 bcrypt</h3><pre><code class="js">python 2. Xnpm install - g node - gypnpm install--global--production windows - build - tools重启命令行工具npm install bcrypt</code></pre><p><strong>加密：</strong></p><pre><code class="js">    // 生成随机字符串    const salt = await bcrypt.genSalt(10);    // 将原密码加密    const password = await bcrypt.hash(req.body.password, salt);    // 将req.body中的password替换成加密后的密码password    req.body.password = password;    // res.send(req.body.password) // 生成加密后的密码    // 将用户信息添加到数据库    await User.create(req.body);    // 添加成功后，重定向到用户页/admin/user    res.redirect(&#39;/admin/user&#39;);</code></pre><p><strong>验证：</strong></p><pre><code class="js">    // 查询用户集合中此email数据是否存在    let user = await User.findOne({        email    });    // 如果查询到了用户,再对比密码    if (user) {        // 对比密码        // compare(传递来的明文密码，数据为的加密密码)的对比        // 返回布尔值        let isValid = await bcrypt.compare(password, user.password)        if (isValid) {            // 登陆成功            // 重定向到列表页            res.redirect(&#39;/admin/user&#39;);        } else {            // 密码错误不成功            res.status(400).render(&#39;admin/error&#39;, {                msg: &#39;密码错误&#39;            });        }</code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><pre><code class="js">npm install express - session</code></pre><h3 id="登陆验证-joi"><a href="#登陆验证-joi" class="headerlink" title="登陆验证 joi"></a>登陆验证 joi</h3><pre><code class="js">npm install joi</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（6）Express框架</title>
      <link href="/2019/12/06/node/Node.js%EF%BC%886%EF%BC%89Express%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/12/06/node/Node.js%EF%BC%886%EF%BC%89Express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Express-框架"><a href="#Express-框架" class="headerlink" title="Express 框架"></a>Express 框架</h2><p>Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。</p><p><strong>下载</strong>：</p><pre><code class="js">npm install express</code></pre><p><strong>特性</strong>：</p><ul><li>提供了方便简洁的路由定义方式</li><li>对获取HTTP请求参数进行了简化处理</li><li>对模板引擎支持程度高，方便渲染动态HTML页面</li><li>提供了中间件机制有效控制HTTP请求</li><li>有大量第三方中间件对功能进行扩展</li></ul><h3 id="原生Node-js与Express对比"><a href="#原生Node-js与Express对比" class="headerlink" title="原生Node.js与Express对比"></a>原生Node.js与Express对比</h3><p><strong>路由：</strong></p><pre><code class="js"> app.on(&#39;request&#39;, (req, res) =&gt; {     // 获取客户端的请求路径     let {         pathname     } = url.parse(req.url);     // 对请求路径进行判断 不同的路径地址响应不同的内容     if (pathname == &#39;/&#39; || pathname == &#39;index&#39;) {         res.end(&#39;欢迎来到首页&#39;);     } else if (pathname == &#39;/list&#39;) {         res.end(&#39;欢迎来到列表页页&#39;);     } else if (pathname == &#39;/about&#39;) {         res.end(&#39;欢迎来到关于我们页面&#39;)     } else {         res.end(&#39;抱歉, 您访问的页面出游了&#39;);     } }); // Express // 当客户端以get方式访问/时 app.get(&#39;/&#39;, (req, res) =&gt; {     // 对客户端做出响应     res.send(&#39;Hello Express&#39;); }); // 当客户端以post方式访问/add路由时 app.post(&#39;/add&#39;, (req, res) =&gt; {     res.send(&#39;使用post方式请求了/add路由&#39;); });</code></pre><p><strong>获取请求参数：</strong></p><pre><code class="js"> app.on(&#39;request&#39;, (req, res) =&gt; {     // 获取GET参数     let {         query     } = url.parse(req.url, true);     // 获取POST参数     let postData = &#39;&#39;;     req.on(&#39;data&#39;, (chunk) =&gt; {         postData += chunk;     });     req.on(&#39;end&#39;, () =&gt; {         console.log(querystring.parse(postData)         })); }); // Express app.get(&#39;/&#39;, (req, res) =&gt; {     // 获取GET参数     console.log(req.query); }); app.post(&#39;/&#39;, (req, res) =&gt; {     // 获取POST参数     console.log(req.body); })</code></pre><h3 id="Express基本使用"><a href="#Express基本使用" class="headerlink" title="Express基本使用"></a>Express基本使用</h3><pre><code class="js"> // 引入Express框架 const express = require(&#39;express&#39;); // 使用框架创建web服务器 const app = express(); // 当客户端以get方式访问/路由时 app.get(&#39;/&#39;, (req, res) =&gt; {     // 对客户端做出响应 send方法会根据内容的类型自动设置请求头     res.send(&#39;Hello Express&#39;); // &lt;h2&gt;Hello Express&lt;/h2&gt; {say: &#39;hello&#39;} }); // 程序监听3000端口 app.listen(3000);</code></pre><p>不再使用res.end，而是使用res.send方法：</p><ul><li>send方法会自动检测响应内容的类型</li><li>自动设置http状态码</li><li>自动设置响应内容类型及编码</li></ul><pre><code class="js">// 引入express框架const express = require(&#39;express&#39;);// 创建网站服务器const app = express();app.get(&#39;/&#39;, (req, res) =&gt; {    res.send(&#39;Hello Express&#39;);})// 监听端口app.listen(3000);console.log(&#39;网站服务器启动成功：localhost:3000&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912231402_279.png?null" alt="Hello Express"></p><h2 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h2><p>中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。</p><p>比如：通过中间件，确认用户是否登陆，登陆后跳转到个人页；</p><p>比如：路由、GET、POST；</p><p><img src="http://mdimg.95408.com/201912231405_838.png?null" alt="中间件"></p><p>中间件主要由两部分构成，中间件方法以及请求处理函数。</p><p>中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。</p><pre><code class="js">app.get(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理get请求app.post(&#39;请求路径&#39;, &#39;处理函数&#39;) // 接收并处理post请求</code></pre><h3 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h3><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。</p><p>默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。</p><p>可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。</p><pre><code class="js">app.get(&#39;/&#39;, (req, res, next) =&gt; {    req.name = &#39;lisi&#39;;    next();});app.get(&#39;/&#39;, (req, res) =&gt; {    res.send(req.name);})// 输出：lisi</code></pre><h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><p>app.use 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。</p><p>app.use 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。</p><pre><code class="js">// 接收所有请求的中间件app.use((req, res, next) =&gt; {    console.log(&#39;请求走了app.use&#39;);    next();})// 客户访问/list请求app.use(&#39;/list&#39;, (req, res, next) =&gt; {    console.log(&#39;请求走了app.use/list&#39;);    next();})// 请求走了app.use// 请求走了app.use / list// /admin请求app.get(&#39;/amin&#39;, (req, res) =&gt; {    res.send(&#39;ok&#39;)})// 请求走了app.use</code></pre><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><p><strong>路由保护</strong></p><p>客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。</p><pre><code class="js">// 设置一个变量，如果为false表示没有登陆// 如果登陆，使用next，请求继续向下执行app.use(&#39;/admin&#39;, (req, res, next) =&gt; {    let isLogin = true;    if (isLogin) {        // 如果用户登陆，请求继续向下执行        next();    } else {        res.send(&#39;您还没有登陆&#39;)    }})// isLogin为true时，才能进入app.get(&#39;/admin&#39;, (req, res) =&gt; {    res.send(&#39;您已登陆，可以访问后台&#39;)})</code></pre><p><strong>网站维护公告</strong></p><p>在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。</p><pre><code class="js">// 在最开始调用，并且不加next方法// 就不能往后执行app.use((req, res, next) =&gt; {    res.send(&#39;网站维护，禁止访问&#39;);})// 其他页面统统不能访问app.get(&#39;/admin&#39;, (req, res) =&gt; {    res.send(&#39;后台&#39;);})app.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;首页&#39;);})</code></pre><p><strong>自定义404页面</strong></p><pre><code class="js">app.get(&#39;/admin&#39;, (req, res) =&gt; {    res.send(&#39;后台&#39;);})app.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;首页&#39;);})// 前面所有的都存在，执行404app.use((req, res, next) =&gt; {    // 为客户端响应404状态码及提示信息    res.status(404).send(&#39;404页面&#39;);})</code></pre><p><img src="http://mdimg.95408.com/201912231447_808.png?null" alt="404页面"></p><h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><pre><code class="js">app.get(&#39;/index&#39;, (req, res) =&gt; {    // 创建一个错误实例：throw抛出错误    throw new Error(&#39;程序发生了XX错误&#39;);    // 如果取消throw错误，正常执行    // 就不会执行错误处理中间件    // res.send(&#39;正常执行&#39;);})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.status(500).send(err.message);})</code></pre><p><img src="http://mdimg.95408.com/201912231458_653.png?null" alt="错误处理中间件"></p><pre><code class="js">app.get(&#39;/index&#39;, (req, res, next) =&gt; {    fs.readFile(&#39;./file-not-exist.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {        if (err != null) {            // 错误，通过app.get()中的next传递            next(err);        } else {            // 正常执行，输出值            res.send(result);        }    });})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.status(500).send(err.message);});// 输出：ENOENT: no such file or directory, open &#39;D:\doc\1221express\no-file.txt&#39;</code></pre><h3 id="异步函数-捕获错误"><a href="#异步函数-捕获错误" class="headerlink" title="异步函数 捕获错误"></a>异步函数 捕获错误</h3><p>在node.js中，异步API的错误信息都是通过回调函数获取的；<strong>异步函数</strong>执行如果发生错误要如何捕获错误呢？</p><p>try catch 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。</p><pre><code class="js"> app.get(&quot;/&quot;, async (req, res, next) =&gt; {     try {         await User.find({             name: &#39;张三&#39;         })     } catch (ex) {         next(ex);     } });</code></pre><p>读取一个不存在的文件：</p><pre><code class="js">// 引入express框架const express = require(&#39;express&#39;);const fs = require(&#39;fs&#39;);const promisify = require(&#39;util&#39;).promisify;// 创建网站服务器const app = express();app.get(&#39;/index&#39;, async (req, res, next) =&gt; {    try {        await readFile(&#39;./not-file.js&#39;);    } catch (ex) {        next(ex);    }})// 错误处理中间件app.use((err, req, res, next) =&gt; {    res.status(500).send(err.message);});// 输出：readFile is not defined// 监听端口app.listen(3000);console.log(&#39;网站服务器启动成功：localhost:3000&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912231631_341.png?null" alt=""></p><h2 id="Express框架请求处理"><a href="#Express框架请求处理" class="headerlink" title="Express框架请求处理"></a>Express框架请求处理</h2><h3 id="构建模块化路由"><a href="#构建模块化路由" class="headerlink" title="构建模块化路由"></a>构建模块化路由</h3><pre><code class="js">// 引入express框架const express = require(&#39;express&#39;);// 创建网站服务器const app = express();// 创建路由对象const home = express.Router();// 为路由对象匹配请求路径app.use(&#39;/home&#39;, home);// 创建二级路由home.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;欢迎来到博客首页/home/index&#39;)})// 监听端口app.listen(3000);console.log(&#39;网站服务器启动成功：localhost:3000&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912231647_415.png?null" alt=""></p><p>创建一个route路由目录，将不同的路由分文件存放：</p><pre><code class="js">route 目录admin.jshome.jsapp.js// ---------------------------------------// ./route/admin.jsconst express = require(&#39;express&#39;);const admin = express.Router();admin.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;博客后台首页/admin/index&#39;);})module.exports = admin;// ---------------------------------------// ./route/home.jsconst express = require(&#39;express&#39;);const home = express.Router();home.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;博客前台首页/home/index&#39;)});module.exports = home;// ---------------------------------------// ./app.jsconst express = require(&#39;express&#39;);const app = express();const home = require(&#39;./route/home&#39;);const admin = require(&#39;./route/admin&#39;);app.get(&#39;/index&#39;, (req, res) =&gt; {    res.send(&#39;index&#39;)})app.use(&#39;./home&#39;, home);app.use(&#39;./admin&#39;, admin);app.listen(3000);console.log(&#39;localhost:3000&#39;);// 访问：// http://localhost:3000/home/index :  博客前台首页/home/index// http://localhost:3000/admin/index : 博客前台首页/home/index</code></pre><h3 id="获取GET参数"><a href="#获取GET参数" class="headerlink" title="获取GET参数"></a>获取GET参数</h3><p>Express框架中使用<strong>req.query</strong>即可获取GET参数，框架内部会将GET参数转换为对象并返回。</p><pre><code class="js">const express = require(&#39;express&#39;);const app = express();app.get(&#39;/index&#39;, (req, res) =&gt; {    // 获取get请求参数    res.send(req.query);})app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231734_419.png?null" alt=""></p><h3 id="获取POST参数"><a href="#获取POST参数" class="headerlink" title="获取POST参数"></a>获取POST参数</h3><p>Express中接收post请求参数需要借助第三方包 body-parser。</p><p>Express官方模块；安装：</p><pre><code class="js">npm install body - parser</code></pre><p>使用：</p><pre><code class="js">// ./post.html&lt;body &gt;    &lt;    form action = &quot;http://localhost:3000/add&quot;method = &quot;POST&quot; &gt;    &lt;    input type = &quot;text&quot;name = &quot;username&quot; &gt;    &lt;    input type = &quot;password&quot;name = &quot;password&quot; &gt;    &lt;    input type = &quot;submit&quot; &gt;    &lt;    /form&gt; &lt;    /body&gt;// ./app.jsconst express = require(&#39;express&#39;);const bodyParser = require(&#39;body-parser&#39;);const app = express();// 拦截所有请求// extended: false 方法内部使用querystring模块处理请求参数的格式// extended: true 方法内部使用第三方模块qs处理请求参数的格式app.use(bodyParser.urlencoded({    extended: false}));app.post(&#39;/add&#39;, (req, res) =&gt; {    // 接收post请求参数    res.send(req.body);})app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231753_382.png?null" alt="获取POST参数"></p><h3 id="params路由参数"><a href="#params路由参数" class="headerlink" title="params路由参数"></a>params路由参数</h3><pre><code class="js">const express = require(&#39;express&#39;);// const bodyParser = require(&#39;body-parser&#39;);const app = express();app.get(&#39;/index/:id/:name&#39;, (req, res) =&gt; {    //接收post参数    res.send(req.params);})// 请求：http://localhost:3000/index/188/zhangsan// 响应：{&quot;id&quot;:&quot;188&quot;,&quot;name&quot;:&quot;李四&quot;}app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231808_219.png?null" alt=""></p><h2 id="静态资源static"><a href="#静态资源static" class="headerlink" title="静态资源static"></a>静态资源static</h2><p>通过Express内置的<strong>express.static</strong>可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。</p><pre><code class="js"> app.use(express.static(&#39;public&#39;));</code></pre><p>将项目根目录下的public目录的文件，做为静态资源：</p><pre><code class="js">const express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();// 实现静态资源访问功能app.use(express.static(path.join(__dirname, &#39;public&#39;)));app.listen(3000);</code></pre><p>此时，我们直接访问： <code>http://localhost:3000/css/base.css</code> ；</p><p>如果要要前缀 <code>files</code> 的话 <code>http://localhost:3000/files/css/base.css</code> ：</p><pre><code class="js">// 实现静态资源访问功能app.use(&#39;/files&#39;, express.static(path.join(__dirname, &#39;public&#39;)));app.listen(3000);</code></pre><p><img src="http://mdimg.95408.com/201912231819_717.png?null" alt=""></p><p><strong>注意</strong>：</p><p>html、art模板文件中的静态资源相对路径，是相对于请求路径的；</p><p>模板文件中，外链资源要写绝对路径，就是以 <code>/</code> 开关；</p><pre><code class="js">&lt; link rel = &quot;stylesheet&quot;href = &quot;/admin/css/base.css&quot; &gt;</code></pre><p>子模板的相对路径，是相对当前文件；</p><p>引入的模板文件，由模板引擎解析，写相对路径；</p><pre><code class="js">{    {        include &#39;./common/header&#39;    }}</code></pre><h2 id="模板引擎express-art-template"><a href="#模板引擎express-art-template" class="headerlink" title="模板引擎express-art-template"></a>模板引擎express-art-template</h2><p>安装</p><pre><code class="js">npm install art - template express - art - template</code></pre><p>为了使 <code>art-template</code> 模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了 <code>express-art-template</code> 。</p><pre><code class="js">// views 目录//    /views/index.art 模板文件// app.js// ---------------------------------------// ./app.jsconst express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();// engine(模板后缀，模板引擎)app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;));// 设置模板文件路径app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));// 设置模板文件默认后缀app.set(&#39;view engine&#39;, &#39;art&#39;);// 客户端访问/index路由app.get(&#39;/index&#39;, (req, res) =&gt; {    // render(&#39;index&#39;)这里的index就是    // 引用的./views目录下的模板文件    // res.render将拼接的模板响应给客户端    res.render(&#39;index&#39;, {        msg: &#39;我是msg的值&#39;,        name: &#39;张三&#39;,        age: &#39;18&#39;    })})app.listen(3000);// ---------------------------------------// ./views/index.art&lt;body &gt; {        {            msg        }    } {        {            name        }    } {        {            age        }    } &lt;    /body&gt;</code></pre><p><img src="http://mdimg.95408.com/201912232016_357.png?null" alt=""></p><h2 id="locals对象"><a href="#locals对象" class="headerlink" title="locals对象"></a>locals对象</h2><p>当有一些公共数据在每个页面都需要加载，而不希望在每个app.get()中查询，可以定义到 <code>locals</code> 中；</p><pre><code class="js">// views 模板目录//        /views/index.art//        /views/list.art// app.js// ---------------------------------------// app.jsconst express = require(&#39;express&#39;);const path = require(&#39;path&#39;);const app = express();app.engine(&#39;art&#39;, require(&#39;express-art-template&#39;));app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;));app.set(&#39;view engine&#39;, &#39;art&#39;);app.locals.users = [{    name: &#39;张三&#39;,    age: 20}, {    name: &#39;李四&#39;,    age: 30}]app.get(&#39;/index&#39;, (req, res) =&gt; {    res.render(&#39;index&#39;, {        msg: &#39;首页msg的值&#39;    })})app.get(&#39;/list&#39;, (req, res) =&gt; {    res.render(&#39;list&#39;, {        msg: &#39;列表页msg的值&#39;    })})app.listen(3000);// ---------------------------------------// /views/index.art&lt;body &gt; {        {            msg        }    } // 首页msg的值    &lt;    ul &gt; {        {            each users        }    } &lt;    li &gt; {        {            $value.name        }    } // 张三 20   李四 30{    {        $value.age    }} &lt;/li&gt; {    {        /each}} &lt;        /ul&gt; &lt;        /body&gt;        // ---------------------------------------        // /views/list.art        &lt;        body &gt; {                {                    msg                }            } //列表页msg的值            &lt;            ul &gt; {                {                    each users                }            } &lt;            li &gt; {                {                    $value.name                }            } // 张三 20   李四 30        {            {                $value.age            }        } &lt;        /li&gt; {            {                /each}} &lt;                /ul&gt; &lt;                /body&gt;</code></pre><p><img src="http://mdimg.95408.com/201912232035_11.png?null" alt=""></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（5）art-Template模板引擎</title>
      <link href="/2019/12/05/node/Node.js%EF%BC%885%EF%BC%89art-Template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2019/12/05/node/Node.js%EF%BC%885%EF%BC%89art-Template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>让开发者以更加友好的方式拼接字符串，使项目代码更加清晰、更加易于维护。</p><p><img src="http://mdimg.95408.com/201912231155_737.png?null" alt="使用模板引擎的写法"></p><h3 id="art-template模板引擎"><a href="#art-template模板引擎" class="headerlink" title="art-template模板引擎"></a>art-template模板引擎</h3><p>安装：</p><pre><code class="js">npm install art - template</code></pre><p>使用：</p><pre><code class="js">// 导入模板引擎模块const template = require(&#39;art-template&#39;);// 将特定模板与特定数据进行拼接const html = template(&#39;./views/index.art&#39;, {    data: {        name: &#39;张三&#39;,        age: 20    }});// 使用：./views/index.art&lt;div &gt;    &lt;    span &gt; {        {            data.name        }    } &lt; /span&gt; &lt;    span &gt; {        {            data.age        }    } &lt; /span&gt; &lt;    /div&gt;</code></pre><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code class="js"> &lt;!-- 标准语法 --&gt; &lt; h2 &gt; {         {             value         }     } &lt; /h2&gt; &lt;     h2 &gt; {         {             a ? b : c         }     } &lt; /h2&gt; &lt;     h2 &gt; {         {             a + b         }     } &lt; /h2&gt;     &lt;     !--原始语法 --&gt;     &lt;     h2 &gt; &lt; %= value % &gt; &lt; /h2&gt; &lt;     h2 &gt; &lt; %= a ? b : c % &gt; &lt; /h2&gt; &lt;     h2 &gt; &lt; %= a + b % &gt; &lt; /h2&gt;</code></pre><h3 id="原文输出"><a href="#原文输出" class="headerlink" title="原文输出"></a>原文输出</h3><p>如果数据中携带HTML标签，默认模板引擎不会解析标签，会将其转义后输出。</p><pre><code class="js">&lt;!-- 标准语法 --&gt;&lt;h2 &gt; {        {            @ value        }    } &lt; /h2&gt; &lt;    !--原始语法 --&gt;    &lt;    h2 &gt; &lt; % -value % &gt; &lt; /h2&gt;</code></pre><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><pre><code class="js"> &lt;!-- 标准语法 --&gt;  {     {         if 条件     } }...{     {         /if}} {             {                 if v1             }         }...{             {                 else if v2             }         }...{             {                 /if}} &lt;                 !--原始语法 --&gt;                     &lt;                     %                     if (value) {                         % &gt; ... &lt; %                     } % &gt;                     &lt;                     %                 if (v1) {                     % &gt; ... &lt; %                 } else if (v2) {                     % &gt; ... &lt; %                 } % &gt;</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code class="js">&lt;!-- 标准语法 --&gt;{    {        each target    }} {    {        $index    }} {    {        $value    }} {    {        /each}} &lt;        !--原始语法 --&gt;            &lt;            %            for (var i = 0; i &lt; target.length; i++) {                % &gt;                &lt;                %= i % &gt; &lt; %= target[i] % &gt;                    &lt;                    %            } % &gt;</code></pre><h3 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h3><p>使用子模板可以将网站公共区块(头部、底部)抽离到单独的文件中。</p><pre><code class="js">  &lt;!-- 标准语法 --&gt;  {      {          include &#39;./header.art&#39;      }  } &lt;  !--原始语法 --&gt;      &lt;      % include(&#39;./header.art&#39;) % &gt;</code></pre><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>使用模板继承可以将网站HTML骨架抽离到单独的文件中，其他页面模板可以继承骨架文件。</p><pre><code class="js">// layout.art文件 &lt;html &gt;    &lt;    head &gt;    &lt;    meta charset = &quot;utf-8&quot; &gt;    &lt;    title &gt; HTML骨架模板 &lt; /title&gt; {        {            block &#39;head&#39;        }    } {        {            /block}} &lt;            /head&gt; &lt;            body &gt; {                    {                        block &#39;content&#39;                    }                } {                    {                        /block}} &lt;                        /body&gt; &lt;                        /html&gt;                        // index.art 文件                        {                            {                                extend &#39;./layout.art&#39;                            }                        } {                            {                                block &#39;head&#39;                            }                        } &lt; link rel = &quot;stylesheet&quot;                        href = &quot;custom.css&quot; &gt; {                            {                                /block}} {                                    {                                        block &#39;content&#39;                                    }                                } &lt; p &gt; This is just an awesome page. &lt; /p&gt; {{/block                            }                        }```### 模板配置1.  向模板中导入变量 template.defaults.imports.变量名 = 变量值;2.  设置模板根目录 template.defaults.root = 模板目录3.  设置模板默认后缀 template.defaults.extname = '.art'``` jsconst template = require('art-template');const path = require('path');const dateFormat = require('dateformat');// 设置模板的根目录template.defaults.root = path.join(__dirname, 'views');// 导入模板变量template.defaults.imports.dateFormat = dateFormat;// 配置模板的默认后缀template.defaults.extname = '.html';const html = template('06.art', {    time: new Date()});console.log(template('07', {}));console.log(html);```## 路由、静态资源模块### router路由模块1.  获取路由对象2.  调用路由对象提供的方法创建路由3.  启用路由，使路由生效``` jsconst getRouter = require('router')const router = getRouter();router.get('/add', (req, res) => {    res.end('Hello World!')})server.on('request', (req, res) => {    router(req, res)})```### serve-static静态资源访问实现静态资源访问服务1.  引入serve-static模块获取创建静态资源服务功能的方法2.  调用方法创建静态资源服务并指定静态资源服务目录3.  启用静态资源服务功能``` jsconst serveStatic = require('serve-static')const serve = serveStatic('public')server.on('request', () => {    serve(req, res)})server.listen(3000)```## 案例``` htmlstudents 学生信息管理项目model 模型connect.js 连接数据库user.js user 集合规则导出public 公共资源css css资源route 路由index.js 路由信息views 模板index.art 详情页list.art 列表页app.js 主文件```![学生档案管理](http://mdimg.95408.com/201912231233_615.png?null)### model/connect.js``` jsconst mongoose = require('mongoose');// 连接数据库mongoose.connect('mongodb://localhost/playground', {        useNewUrlParser: true    })    .then(() => console.log('数据库连接成功'))    .catch(() => console.log('数据库连接失败'))```### model/user.js``` jsconst mongoose = require('mongoose');// 创建学生集合规则const studentsSchema = new mongoose.Schema({    name: {        type: String,        required: true,        minlength: 2,        maxlength: 10    },    age: {        type: Number,        min: 10,        max: 25    },    sex: {        type: String    },    email: String,    hobbies: [String],    collage: String,    enterDate: {        type: Date,        default: Date.now    }});// 创建学生信息集合const Student = mongoose.model('Student', studentsSchema);// 将学生信息集合进行导出module.exports = Student;```### route/index.js``` jsconst mongoose = require('mongoose');// 创建学生集合规则const studentsSchema = new mongoose.Schema({    name: {        type: String,        required: true,        minlength: 2,        maxlength: 10    },    age: {        type: Number,        min: 10,        max: 25    },    sex: {        type: String    },    email: String,    hobbies: [String],    collage: String,    enterDate: {        type: Date,        default: Date.now    }});// 创建学生信息集合const Student = mongoose.model('Student', studentsSchema);// 将学生信息集合进行导出module.exports = Student;```### views/index.art``` jsconst mongoose = require('mongoose');// 创建学生集合规则const studentsSchema = new mongoose.Schema({    name: {        type: String,        required: true,        minlength: 2,        maxlength: 10    },    age: {        type: Number,        min: 10,        max: 25    },    sex: {        type: String    },    email: String,    hobbies: [String],    collage: String,    enterDate: {        type: Date,        default: Date.now    }});// 创建学生信息集合const Student = mongoose.model('Student', studentsSchema);// 将学生信息集合进行导出module.exports = Student;```### views/list.art``` js< !DOCTYPE html >    <    html lang = "en" >    <    head >    <    meta charset = "UTF-8" >    <    title > 学员信息 < /title> <    link rel = "stylesheet"href = "./css/list.css" >    <    /head> <    body >    <    table >    <    caption > 学员信息 < /caption> <    tr >    <    th > 姓名 < /th> <    th > 年龄 < /th> <    th > 性别 < /th> <    th > 邮箱地址 < /th> <    th > 爱好 < /th> <    th > 所属学院 < /th> <    th > 入学时间 < /th> <    /tr> {        {            each students        }    } <    tr >    <    th > {        {            $value.name        }    } < /th> <    th > {        {            $value.age        }    } < /th> <    th > {        {            $value.sex == '0' ? '男' : '女'        }    } < /th> <    th > {        {            $value.email        }    } < /th> <    th > {        {            each $value.hobbies        }    } <    span > {        {            $value        }    } < /span> {        {            /each}} &lt;            /th&gt; &lt;            th &gt; {                    {                        $value.collage                    }                } &lt; /th&gt; &lt;                th &gt; {                    {                        dateformat($value.enterDate, &#39;yyyy-mm-dd&#39;)                    }                } &lt; /th&gt; &lt;                /tr&gt; {                    {                        /each}}                        &lt;                        /table&gt; &lt;                        /body&gt; &lt;                        /html&gt;</code></pre><h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><pre><code class="js">// 引入http模块const http = require(&#39;http&#39;);// 引入模板引擎const template = require(&#39;art-template&#39;);// 引入path模块const path = require(&#39;path&#39;);// 引入静态资源访问模块const serveStatic = require(&#39;serve-static&#39;);// 引入处理日期的第三方模块const dateformat = require(&#39;dateformat&#39;);const router = require(&#39;./route/index&#39;);// 实现静态资源访问服务const serve = serveStatic(path.join(__dirname, &#39;public&#39;))// 配置模板的根目录template.defaults.root = path.join(__dirname, &#39;views&#39;);// 处理日期格式的方法template.defaults.imports.dateformat = dateformat;// 数据库连接require(&#39;./model/connect&#39;);// 创建网站服务器const app = http.createServer();// 当客户端访问服务器端的时候app.on(&#39;request&#39;, (req, res) =&gt; {    // 启用路由功能    router(req, res, () =&gt; {})    // 启用静态资源访问服务功能    serve(req, res, () =&gt; {})});// 端口监听app.listen(80);console.log(&#39;服务器启动成功&#39;);</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（4）Mongodb数据库</title>
      <link href="/2019/12/04/node/Node.js%EF%BC%884%EF%BC%89Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/12/04/node/Node.js%EF%BC%884%EF%BC%89Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>下载：</strong></p><blockquote><p>下载地址：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a></p></blockquote><p><strong>系统环境变量：</strong></p><blockquote><p>将MongoDB的路径 <code>C:\Program Files\MongoDB\Server\4.1\bin</code> 加入系统环境变量。</p></blockquote><p><strong>启动/停止：</strong></p><blockquote><p>启动： <code>net start mongodb</code> </p><p>停止： <code>net stop mongodb</code> </p><p>注意：以管理员身份运行命令提示行</p></blockquote><p><strong>导入数据：</strong></p><blockquote><p>mongoimport –d 数据库名称 –c 集合名称 –file 要导入的数据文件 (注意：是 - - file)</p><p>mongoimport - d playground - c users –file./ user.json</p></blockquote><p><strong>其他：</strong></p><blockquote><p>创建的数据库会自动加 <code>s</code> ；</p><p><code>const User = mongoose.model(&#39;User&#39;, userSchema);</code> 数据库中的集合名称实际为 <code>users</code> ；</p><p><a href="https://www.jianshu.com/p/775088bb8f92" target="_blank" rel="noopener">使用Mongoose查询数据库一直为空数组？</a></p></blockquote><h3 id="MongoDB-Compass-可视化"><a href="#MongoDB-Compass-可视化" class="headerlink" title="MongoDB Compass 可视化"></a>MongoDB Compass 可视化</h3><p><img src="http://mdimg.95408.com/201912202251_415.png" alt=""></p><h3 id="数据库、集合、文档、字段"><a href="#数据库、集合、文档、字段" class="headerlink" title="数据库、集合、文档、字段"></a>数据库、集合、文档、字段</h3><p>在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）。</p><table><thead><tr><th align="center"><strong>术语</strong></th><th align="center"><strong>解释说明</strong></th></tr></thead><tbody><tr><td align="center">database    数据库</td><td align="center">mongoDB数据库软件中可以建立多个数据库</td></tr><tr><td align="center">collection    集合</td><td align="center">一组数据的集合，可以理解为JavaScript中的数组</td></tr><tr><td align="center">document    文档</td><td align="center">一条具体的数据，可以理解为JavaScript中的对象</td></tr><tr><td align="center">field    字段</td><td align="center">文档中的属性名称，可以理解为JavaScript中的对象属性</td></tr></tbody></table><h2 id="Node-js与MongoDB"><a href="#Node-js与MongoDB" class="headerlink" title="Node.js与MongoDB"></a>Node.js与MongoDB</h2><p>使用Node.js操作MongoDB数据库。</p><h3 id="Mongoose模块"><a href="#Mongoose模块" class="headerlink" title="Mongoose模块"></a>Mongoose模块</h3><ul><li>使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose；</li><li>使用 <code>npm install mongoose</code> ；</li></ul><h3 id="Node-js连接MongoDB"><a href="#Node-js连接MongoDB" class="headerlink" title="Node.js连接MongoDB"></a>Node.js连接MongoDB</h3><ul><li>在MongoDB中<strong>不需要显式创建数据库</strong>，如果正在使用的数据库不存在，<strong>MongoDB</strong>会自动创建；</li></ul><pre><code class="js">// 1.jsconst mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// D:\doc\1220&gt;node 1.js// 数据库连接成功</code></pre><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><ul><li>一个集合就是一个数据库表单，如excel中的表单；</li><li>创建集合分为两步，一是对<strong>对集合设定规则</strong>，二是<strong>创建集合</strong>；</li></ul><pre><code class="js">const mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// 创建集合规则// 返回构造函数const courseSchema = new mongoose.Schema({    name: String,    author: String,    isPublished: Boolean});// 使用集合规则创建集合// 创建的集合名为：courses// 参1：集合名称； 参2：集合规则const Course = mongoose.model(&#39;Course&#39;, courseSchema);// 创建集合的文档const course = new Course({    name: &#39;Node.js&#39;,    author: &#39;JavaScript&#39;,    isPublished: true})// 保存，将创建的文档插入到数据库course.save();</code></pre><h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>创建文档实际就是向集合中插入数据。</p><ul><li>只创建了集合，数据库并没有自动创建；</li><li>只有创建了一个文档，并将文件插入到集合中，集合才会自动创建；</li></ul><p><img src="http://mdimg.95408.com/201912202254_525.png" alt="Compass查看数据"></p><p>上一个代码中展示了一种创建数据的方式，以下是另外一种：</p><pre><code class="js">// 创建集合const Course = mongoose.model(&#39;Course&#39;, courseSchema);// 向集合中插入数据Course.create({    &#39;name&#39;: &#39;Django&#39;,    &#39;author&#39;: &#39;Python&#39;,    &#39;isPublished&#39;: true}, (err, result) =&gt; {    console.log(err);    console.log(result);});</code></pre><p><img src="http://mdimg.95408.com/201912202255_890.png" alt=""></p><p>也支持异步函数的方式：</p><pre><code class="js">Course.create({        &#39;name&#39;: &#39;Django&#39;,        &#39;author&#39;: &#39;Python&#39;,        &#39;isPublished&#39;: true    })    .then(result =&gt; {        console.log(result);    })</code></pre><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><pre><code class="js">mongoimport - d playground - c users--file. / user.json</code></pre><p><img src="http://mdimg.95408.com/201912202255_2.png" alt="图片错误：应是users"></p><h3 id="mongoose验证"><a href="#mongoose验证" class="headerlink" title="mongoose验证"></a>mongoose验证</h3><p>在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败；</p><p>获取错误信息：error.errors[‘字段名称’].message</p><ul><li>required: true   必传字段</li><li>minlength：3   字符串最小长度</li><li>maxlength: 20   字符串最大长度</li><li>min: 2   数值最小为2</li><li>max: 100   数值最大为100</li><li>enum: [‘html’<strong>, ** ‘css’</strong>, ** ‘javascript’*<em>, *</em> ‘node.js’]</li><li>trim: true   去除字符串两边的空格</li><li>validate:   自定义验证器</li><li>default:   默认值</li></ul><pre><code class="js">const postSchema = new mongoose.Schema({    title: {        type: String,        // 必选字段        required: [true, &#39;请传入文章标题&#39;],        // 字符串的最小长度        minlength: [2, &#39;文章长度不能小于2&#39;],        // 字符串的最大长度        maxlength: [5, &#39;文章长度最大不能超过5&#39;],        // 去除字符串两边的空格        trim: true    },    age: {        type: Number,        // 数字的最小范围        min: 18,        // 数字的最大范围        max: 100    },    publishDate: {        type: Date,        // 默认值        default: Date.now    },    category: {        type: String,        // 枚举 列举出当前字段可以拥有的值        enum: {            values: [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;, &#39;node.js&#39;],            message: &#39;分类名称要在一定的范围内才可以&#39;        }    },    author: {        type: String,        validate: {            validator: v =&gt; {                // 返回布尔值                // true 验证成功                // false 验证失败                // v 要验证的值                return v &amp;&amp; v.length &gt; 4            },            // 自定义错误信息            message: &#39;传入的值不符合验证规则&#39;        }    }});const Post = mongoose.model(&#39;Post&#39;, postSchema);Post.create({        title: &#39;aa&#39;,        age: 60,        category: &#39;java&#39;,        author: &#39;bd&#39;    })    .then(result =&gt; console.log(result))    .catch(error =&gt; {        // 获取错误信息对象        const err = error.errors;        // 循环错误信息对象        for (var attr in err) {            // 将错误信息打印到控制台中            console.log(err[attr][&#39;message&#39;]);        }    })</code></pre><h3 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h3><p>通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。</p><ul><li>使用id对集合进行关联</li><li>使用populate方法进行关联集合查询</li></ul><pre><code class="js">// 用户集合const User = mongoose.model(&#39;User&#39;, new mongoose.Schema({    name: {        type: String    }}));// 文章集合const Post = mongoose.model(&#39;Post&#39;, new mongoose.Schema({    title: {        type: String    },    // 使用ID将文章集合和作者集合进行关联    author: {        type: mongoose.Schema.Types.ObjectId,        ref: &#39;User&#39;    }}));//联合查询Post.find()    .populate(&#39;author&#39;)    .then((err, result) =&gt; console.log(result));</code></pre><p>文章关联到作者：</p><pre><code class="js">// 引入mongoose第三方模块 用来操作数据库const mongoose = require(&#39;mongoose&#39;);// 数据库连接mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true    })    // 连接成功    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    // 连接失败    .catch(err =&gt; console.log(err, &#39;数据库连接失败&#39;));// 用户集合规则const userSchema = new mongoose.Schema({    name: {        type: String,        required: true    }});// 文章集合规则const postSchema = new mongoose.Schema({    title: {        type: String    },    author: {        type: mongoose.Schema.Types.ObjectId,        ref: &#39;User&#39;    }});// 用户集合const User = mongoose.model(&#39;User&#39;, userSchema);// 文章集合const Post = mongoose.model(&#39;Post&#39;, postSchema);// 创建用户// User.create({name: &#39;itheima&#39;}).then(result =&gt; console.log(result));// 创建文章// Post.create({titile: &#39;123&#39;, author: &#39;5c0caae2c4e4081c28439791&#39;}).then(result =&gt; console.log(result));Post.find().populate(&#39;author&#39;).then(result =&gt; console.log(result))</code></pre><h2 id="查-改-删"><a href="#查-改-删" class="headerlink" title="查/改/删"></a>查/改/删</h2><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>find()不管查询的数据多少，都返回文档（一个数组）；</p><pre><code class="js">//  根据条件查找文档（条件为空则查找所有文档）Course.find().then(result =&gt; console.log(result))// 返回文档集合[{    _id: 5 c0917ed37ec9b03c07cf95f,    name: &#39;张三&#39;,    email: &#39;zhangsan@qq.cn‘}, {    _id: 5 c09dea28acfb814980ff827,    name: &#39;Javascript&#39;,    email: &#39;zhangsan@qq.cn‘}]</code></pre><h4 id="findOne"><a href="#findOne" class="headerlink" title="findOne()"></a>findOne()</h4><p>findOne() 返回单一的对象；</p><pre><code class="js">//  根据条件查找文档Course.findOne({            name: 张三 &#39;}).then(result =&gt; console.log(result))            // 返回文档            {                _id: 5 c0917ed37ec9b03c07cf95f,                name: &#39;张三&#39;,                author: &#39;zhangsan@qq.cn‘            }</code></pre><h4 id="查询之前导入的数据"><a href="#查询之前导入的数据" class="headerlink" title="查询之前导入的数据"></a>查询之前导入的数据</h4><pre><code class="js">const mongoose = require(&#39;mongoose&#39;);mongoose.connect(&#39;mongodb://localhost/playground&#39;, {        useNewUrlParser: true,        useUnifiedTopology: true    })    .then(() =&gt; console.log(&#39;数据库连接成功&#39;))    .catch(err =&gt; console.log(err))// 创建集合规则const userSchema = new mongoose.Schema({    name: String,    age: Number,    email: String,    password: String,    hobbies: [String],});// 创建集合const User = mongoose.model(&#39;User&#39;, userSchema);// 查询所有User.find().then(result =&gt; console.log(result));</code></pre><h4 id="查询符号使用"><a href="#查询符号使用" class="headerlink" title="查询符号使用"></a>查询符号使用</h4><p><img src="http://mdimg.95408.com/201912202359_364.png" alt=""></p><pre><code class="js">// 年龄大于20 小于50User.find({    age: {        $gt: 20,        $lt: 50    }}).then(result =&gt; console.log(result));// 爱好在敲代码中的数据User.find({    hobbies: {        $in: [&#39;敲代码&#39;]    }}).then(result =&gt; console.log(result));// 只查找name email字段的数据 加-表示不显示的字段，_id字段默认显示User.find().select(&#39;name email -_id&#39;).then(result =&gt; console.log(result));// 按年龄字段进行排序 加-为降序User.find().sort(&#39;age&#39;).then((result) =&gt; {    console.log(result)});// skip 跳过2条，limit 限制显示2条User.find().skip(2).limit(2).then(result =&gt; {    console.log(result)});</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><h4 id="findOneAndDelete"><a href="#findOneAndDelete" class="headerlink" title="findOneAndDelete"></a>findOneAndDelete</h4><ul><li>查找一条文档并删除；</li><li>返回删除的文档</li><li>如果查到了多个文档，删除第一条</li></ul><pre><code class="js">// 删除单个User.findOneAndDelete({        _id: &#39;5c09f267aeb04b22f8460968&#39;    })    .then(result =&gt; console.log(result));// 删除了指定_id的‘王五’的数据</code></pre><h4 id="deleteMany"><a href="#deleteMany" class="headerlink" title="deleteMany"></a>deleteMany</h4><ul><li>为空时，删除所有！！！很危险！！！</li><li>返回删除数据条数</li></ul><pre><code class="js">// 删除多个User.deleteMany({}).then(result =&gt; console.log(result))</code></pre><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="updateOne"><a href="#updateOne" class="headerlink" title="updateOne"></a>updateOne</h4><pre><code class="js">// 更新单个User.updateOne({    查询条件}, {    要修改的值}).then(result =&gt; console.log(result))// 将李四这个文档的年龄改成8User.updateOne({        &#39;name&#39;: &#39;李四&#39;    }, {        &#39;age&#39;: 8    })    .then(result =&gt; console.log(result));</code></pre><h4 id="updateMany"><a href="#updateMany" class="headerlink" title="updateMany"></a>updateMany</h4><ul><li>查询条件为空，更改全部文档数据！！！危险！！！</li></ul><pre><code class="js">// 更新多个User.updateMany({    查询条件}, {    要更改的值}).then(result =&gt; console.log(result))// 将所有数据的年龄改成8User.updateMany({}, {        &#39;age&#39;: 8    })    .then(result =&gt; console.log(result));</code></pre>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（3）web服务器、http、async异步编程</title>
      <link href="/2019/12/03/node/Node.js%EF%BC%883%EF%BC%89web%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81http%E3%80%81async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/03/node/Node.js%EF%BC%883%EF%BC%89web%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81http%E3%80%81async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP协议"><a href="#1-HTTP协议" class="headerlink" title="1. HTTP协议"></a>1. HTTP协议</h2><h3 id="1-1-web-服务器模块-http"><a href="#1-1-web-服务器模块-http" class="headerlink" title="1.1 web 服务器模块 http"></a>1.1 web 服务器模块 http</h3><ul><li>创建一个服务器对象app，绑定一个端口号：3000；</li><li>通过后台运行 <code>node app.js</code> ，就创建了一个web服务器；</li><li>浏览器请求这个服务器的地址： <code>localhost:3000</code> 时，服务器就响应一段数据（ <code>res.end</code> ）给浏览器；</li></ul><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // 当浏览器请求时，服务器响应内容给浏览器    res.end(&#39;当你在浏览器输入网址请求本web服务器，就会响应这一些文字&#39;);})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><p>Chrome–F12–Network–Headers：请求和响应报文：</p><p><strong>Request 请求报文</strong></p><ul><li>浏览器客户端告诉服务器端的事件；</li><li>能接收的格式，语言；</li></ul><p><strong>Response 响应报文</strong></p><ul><li>服务器端对浏览器客户端响应的事情；</li><li>服务器端响应给客户端具体的数据：html文件</li></ul><h3 id="1-2-请求报文"><a href="#1-2-请求报文" class="headerlink" title="1.2 请求报文"></a>1.2 请求报文</h3><p>请求方式：</p><ul><li>GET 请求数据</li><li>POST 发送数据</li></ul><h3 id="1-3-req-method"><a href="#1-3-req-method" class="headerlink" title="1.3 req.method"></a>1.3 req.method</h3><p>req.method 获取请求的方式</p><p>浏览器端通过post或get向服务器端发送数据：</p><pre><code class="html">// 表单数据通过post请求发送给localhost:3000服务器&lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;    &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;/form&gt;</code></pre><p>服务器端接收来自浏览器客户端的数据，并响应了一段文字 <code>res.end</code> ：</p><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // req.method 获取请求的方式    console.log(req.method)    if (req.method == &#39;POST&#39;) {        res.end(&#39;来自浏览器的请求方式为POST&#39;);    } else if (req.method == &#39;GET&#39;) {        res.end(&#39;来自浏览器的请求方式为GET&#39;);    }})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h3 id="1-4-req-url"><a href="#1-4-req-url" class="headerlink" title="1.4 req.url"></a>1.4 req.url</h3><p>req.url 客户端请求的url地址</p><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // req.url 客户端面请求的url地址    if (req.url == &#39;/index&#39; || req.url == &#39;/&#39;) {        res.end(&#39;welcome to index page&#39;);    } else if (req.url == &#39;/list&#39;) {        res.end(&#39;welcom to list page&#39;);    } else {        res.end(&#39;404 not found page&#39;);    }})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h3 id="1-5-req-headers"><a href="#1-5-req-headers" class="headerlink" title="1.5 req.headers"></a>1.5 req.headers</h3><p>客户端请求的报文信息</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求报文信息中accept中的值    console.log(req.headers[&#39;accept&#39;]);})</code></pre><h3 id="1-6-响应报文"><a href="#1-6-响应报文" class="headerlink" title="1.6 响应报文"></a>1.6 响应报文</h3><h3 id="1-7-HTTP-响应状态码"><a href="#1-7-HTTP-响应状态码" class="headerlink" title="1.7 HTTP 响应状态码"></a>1.7 HTTP 响应状态码</h3><ul><li>200</li><li>404</li><li>500</li><li>400</li></ul><h3 id="1-8-res-writeHead"><a href="#1-8-res-writeHead" class="headerlink" title="1.8 res.writeHead"></a>1.8 res.writeHead</h3><p>书写服务器端给客户端响应的数据</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    res.writeHead(400);})</code></pre><p><img src="http://mdimg.95408.com/web_1576778412.jpg" alt="设置状态码为 400 时"></p><p>设置状态码、文本格式及编码：</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    // 设置状态码200和html格式及编码utf8    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    });    // req.url 客户端面请求的url地址    if (req.url == &#39;/index&#39; || req.url == &#39;/&#39;) {        res.end(&#39;欢迎来到index首页！&#39;);    } else {        res.end(&#39;404&#39;)    }})</code></pre><h2 id="2-HTTP请求和响应"><a href="#2-HTTP请求和响应" class="headerlink" title="2. HTTP请求和响应"></a>2. HTTP请求和响应</h2><h3 id="2-1-请求参数"><a href="#2-1-请求参数" class="headerlink" title="2.1 请求参数"></a>2.1 请求参数</h3><p>客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。</p><h3 id="2-2-GET请求参数"><a href="#2-2-GET请求参数" class="headerlink" title="2.2 GET请求参数"></a>2.2 GET请求参数</h3><ul><li>参数被放置在浏览器地址栏中，例如：<a href="http://localhost:3000/?name=zhangsan&amp;age=20" target="_blank" rel="noopener">http://localhost:3000/?name=zhangsan&amp;age=20</a></li><li>参数获取需要借助系统模块url<ul><li>之前我们直接使用了 <code>req.url</code> 获得了所有的请求参数，如 <code>/index?name=zhangsan&amp;qq=123456</code> ；</li><li>如果要得到更方便的对象形式的 <code>get参数</code> ，可以使用 <code>url.parse(req.url, true).query;</code> ，将get地址解析成对象形式，如 <code>{ name: &#39;zhangsan&#39;, qq: &#39;123456&#39; }</code> ；</li></ul></li></ul><h4 id="2-2-1-url-parse-query"><a href="#2-2-1-url-parse-query" class="headerlink" title="2.2.1 url.parse( ).query"></a>2.2.1 url.parse( ).query</h4><pre><code class="js">// 引入系统模块urlconst url = require(&#39;url&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求参数    console.log(req.url); // /index?name=zhangsan&amp;qq=123455    // 将请求参数交给url模块进行处理    // parse(参1：要解析的url地址， 参2：将参数解析成对象形式)    let params = url.parse(req.url, true).query;    console.log(params); // { name: &#39;zhangsan&#39;, qq: &#39;123455&#39; }    console.log(params.name); // params.name获取：zhangsan    console.log(params.qq); // params.qq获取：123455})</code></pre><h4 id="2-2-2-url-parse-pathname"><a href="#2-2-2-url-parse-pathname" class="headerlink" title="2.2.2 url.parse( ).pathname"></a>2.2.2 url.parse( ).pathname</h4><p><code>url.parse().pathname</code> 包含的是url地址的 <code>/index</code> 部分，前面通过url的路由没有提取get参数；</p><pre><code class="js">    let query = url.parse(req.url, true).query;    // query:  { name: &#39;zhangsan&#39;, qq: &#39;123455&#39; }    let pathname = url.parse(req.url, true).pathname;    // pathname:  /index    // 等同于：    let {        query,        pathname    } = url.parse(req.url, true);</code></pre><h4 id="2-2-3-get请求响应页面"><a href="#2-2-3-get请求响应页面" class="headerlink" title="2.2.3 get请求响应页面"></a>2.2.3 get请求响应页面</h4><p>通过get请求地址响应不同页面</p><p>修改去除url中的get参数（原来：if (req.url == ‘/index’)，如果url中有参数就无法识别）</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    let {        query,        pathname    } = url.parse(req.url, true);    // 设置状态码200和html格式及编码utf8    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    });    // req.url 客户端面请求的url地址    // 原来：if (req.url == &#39;/index&#39;)，如果url中有参数就无法识别    if (pathname == &#39;/index&#39; || pathname == &#39;/&#39;) {        res.end(&#39;欢迎来到index首页！&#39;);    } else if (pathname == &#39;/list&#39;) {        res.end(&#39;欢迎来到list页面&#39;)    } else {        res.end(&#39;404&#39;)    }})</code></pre><p><img src="http://mdimg.95408.com/201912201246_963.png" alt="url中带get参数"></p><h3 id="2-3-POST请求参数"><a href="#2-3-POST请求参数" class="headerlink" title="2.3 POST请求参数"></a>2.3 POST请求参数</h3><ul><li>参数被放置在请求体中进行传输</li><li>获取POST参数需要使用data事件和end事件</li><li>使用querystring</li></ul><h4 id="2-3-1-form-html"><a href="#2-3-1-form-html" class="headerlink" title="2.3.1 form.html"></a>2.3.1 form.html</h4><p><code>form.html</code> ： html表单通过post参数向服务器传递数据：</p><pre><code class="html">&lt;body&gt;    &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;usename&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><h4 id="2-3-2-提交表单"><a href="#2-3-2-提交表单" class="headerlink" title="2.3.2 提交表单"></a>2.3.2 提交表单</h4><p>使用表单提交数据：</p><p><img src="http://mdimg.95408.com/201912201313_858.png" alt=""></p><h4 id="2-3-3-app-js"><a href="#2-3-3-app-js" class="headerlink" title="2.3.3 app.js"></a>2.3.3 app.js</h4><p><code>app.js</code> ：服务器开启 <code>nodemon app.js</code> 后，接收来自form.html传递的post数据：</p><blockquote><p><code>console.log(postParams);</code> // usename=zhangsan&amp;password=123456；</p><p><code>console.log(querystring.parse(postParams));</code> // { usename: ‘zhangsan’, password: ‘123456’ }；</p></blockquote><pre><code class="js">// 引用http系统模块const http = require(&#39;http&#39;);// 处理请求参数模块 post参数字符串转为对象const querystring = require(&#39;querystring&#39;)// 创建web服务器const app = http.createServer();// 当客户端发送请求时启用的事件函数// req 请求事件  res 响应事件app.on(&#39;request&#39;, (req, res) =&gt; {    // post请求    // 请求参数传输有一定的时间    // post参数是通过事件的方式接收的    // 请求参数传递时触发data事件    // 请求参数传输完成时触发end事件    let postParams = &#39;&#39;;    req.on(&#39;data&#39;, params =&gt; {        postParams += params;    })    req.on(&#39;end&#39;, () =&gt; {        // postParams 为post请求数据的字符串格式        console.log(postParams); // usename=zhangsan&amp;password=123456        // querystring.parse(postParams)         // 通过处理后得到了对象形式的post请求数据        console.log(querystring.parse(postParams));        // { usename: &#39;zhangsan&#39;, password: &#39;123456&#39; }    })})app.listen(3000);// 在node后台输出的文字console.log(&#39;web服务器启动成功，请访问：localhost:3000&#39;);</code></pre><h2 id="3-路由"><a href="#3-路由" class="headerlink" title="3. 路由"></a>3. 路由</h2><p>之前，我们在浏览器输入 <code>localhost:3000/index</code> ，需要响应到 <code>index</code> 页面上的内容；</p><p>输入 <code>localhost:3000/list</code> ，需要响应到 <code>list</code> 上的数据；</p><blockquote><p>路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</p></blockquote><p><img src="http://mdimg.95408.com/201912201325_932.png" alt="路由"></p><p>之前的代码：</p><pre><code class="js">app.on(&#39;request&#39;, (req, res) =&gt; {    let {        query,        pathname    } = url.parse(req.url, true);    if (pathname == &#39;/index&#39; || pathname == &#39;/&#39;) {        res.end(&#39;index页面数据&#39;);    } else if (pathname == &#39;/list&#39;) {        res.end(&#39;list页面数据&#39;)    } else {        res.end(&#39;404&#39;)    }})</code></pre><p>以上是简单的路由代码，但没有体现客户端的get、post请求判断；</p><h4 id="3-1-判断为get请求的路由"><a href="#3-1-判断为get请求的路由" class="headerlink" title="3.1 判断为get请求的路由"></a>3.1 判断为get请求的路由</h4><pre><code class="js">const http = require(&#39;http&#39;);const url = require(&#39;url&#39;);const app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    // 获取请求方式,转小写    const method = req.method.toLowerCase();    // 获取请求地址    const pathname = url.parse(req.url).pathname;    // 响应头设置编码    res.writeHead(200, {        &#39;content-type&#39;: &#39;text/html;charset=utf8&#39;    })    // 判断请求方式是post还是get    if (method == &#39;get&#39;) {        // 判断请求url来响应数据        if (pathname == &#39;/&#39; || pathname == &#39;/index&#39;) {            res.end(&#39;欢迎来到首页&#39;);        } else if (pathname == &#39;/list&#39;) {            res.end(&#39;欢迎来到列表页&#39;);        } else {            res.end(&#39;没有找到你要的页面&#39;)        }    } else if (method == &#39;post&#39;) {        // 请求方式为post时的内容        // 与get判断基本相同    }})app.listen(3000);console.log(&#39;服务器启动成功&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912201346_522.png" alt=""></p><h2 id="4-静态资源"><a href="#4-静态资源" class="headerlink" title="4. 静态资源"></a>4. 静态资源</h2><p>将客户端浏览器请求的路径，转换为服务器实现静态文件路径：</p><pre><code class="js">const http = require(&#39;http&#39;);const url = require(&#39;url&#39;);const path = require(&#39;path&#39;);const app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    // 响应原始url路径    // res.end(req.url);    // 获取请求地址    const pathname = url.parse(req.url).pathname;    // 响应pathname路径    // res.end(pathname);  // /index    const dirpath = path.join(__dirname, &#39;public&#39; + pathname);    // 响应path拼接的绝对路径    res.end(dirpath); // D:\doc\1218\route\public\index})app.listen(3000);console.log(&#39;服务器启动成功&#39;);</code></pre><p><img src="http://mdimg.95408.com/201912201407_769.png" alt=""></p><p>我们通过拼接得到了文件的绝对路径 <code>d:\doc\1218\route\public\index</code> ，可以通过 <code>fs</code> 模块读取，响应给客户端：</p><h3 id="4-1-读取静态-html文件"><a href="#4-1-读取静态-html文件" class="headerlink" title="4.1 读取静态.html文件"></a>4.1 读取静态.html文件</h3><ul><li>客户端发送请求 <code>localhost:3000/index</code> ，得到请求路径 <code>/index</code> ；</li><li>服务器端 <code>path.join()</code> 拼接出服务器本地绝对地址 <code>d:\doc\1218\route\public\index</code> ；</li><li>在绝对地址下有对应的 <code>index.html</code> 文件时，通过 <code>fs.readFile</code> 读取后响应给客户端；</li><li>浏览器就打开了这个 <code>index.html</code> 的首页文件；</li></ul><pre><code class="js">const fs = require(&#39;fs&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    let pathname = url.parse(req.url).pathname;    let realpath = path.join(__dirname, &#39;public&#39; + pathname);    // res.end(realpath);   // d:\doc\1218\route\public\index    fs.readFile(realpath, (err, result) =&gt; {        // 读取失败响应文字        if (err != null) {            res.end(&#39;文件读取失败&#39;);            return;        }        // 读取成功后，将读取到的index.html文件响应给客户端        res.end(result);    })})</code></pre><p><img src="http://mdimg.95408.com/201912201435_163.png" alt=""></p><h3 id="4-2-请求根目录至首页文件"><a href="#4-2-请求根目录至首页文件" class="headerlink" title="4.2 请求根目录至首页文件"></a>4.2 请求根目录至首页文件</h3><p>当客户请求根目录 <code>localhost:3000</code> 时，跳转到 <code>localhost:3000/index</code> ：</p><pre><code class="js">pathname = pathname == &#39;/&#39; ? &#39;/index&#39; : pathname;</code></pre><h3 id="4-3-指定返回资源的类型-mime"><a href="#4-3-指定返回资源的类型-mime" class="headerlink" title="4.3 指定返回资源的类型 mime"></a>4.3 指定返回资源的类型 mime</h3><pre><code class="js">const mime = require(&#39;mime&#39;);app.on(&#39;request&#39;, (req, res) =&gt; {    let pathname = url.parse(req.url).pathname;    pathname = pathname == &#39;/&#39; ? &#39;/index&#39; : pathname;    let realpath = path.join(__dirname, &#39;public&#39;, pathname);    let type = mime.getType(realpath);    fs.readFile(realpath, (err, result) =&gt; {        if (err != null) {            res.end(&#39;文件读取失败&#39;);            return;        }        // 指定资源返回的类型        res.writeHead(200, {            &#39;content-type&#39;: type;        })        res.end(result);    })})</code></pre><p><img src="http://mdimg.95408.com/201912201449_374.png" alt=""></p><h2 id="5-异步API"><a href="#5-异步API" class="headerlink" title="5. 异步API"></a>5. 异步API</h2><h3 id="5-1-同步API-和-异步API"><a href="#5-1-同步API-和-异步API" class="headerlink" title="5.1 同步API 和 异步API"></a>5.1 同步API 和 异步API</h3><p>同步API：只有当前API执行完成后，才能继续执行下一个API；</p><pre><code class="js">console.log(&#39;1&#39;);console.log(&#39;2&#39;);console.log(&#39;3&#39;);</code></pre><p>异步API：当前API的执行不会阻塞后续代码的执行；</p><pre><code class="js">console.log(&#39;1&#39;);setTimeout(    () =&gt; {        console.log(&#39;3&#39;);    }, 2000);console.log(&#39;2&#39;);</code></pre><p>同步API可以<strong>从返回值中拿到API执行的结果</strong>, 但是异步API是不可以的；</p><p>异步API是通过回调函数来完成的。</p><pre><code class="js">// 同步function sum(n1, n2) {    return n1 + n2;}const result = sum(10, 20); // 30// 异步function getMsg() {    setTimeout(function() {        return {            msg: &#39;Hello Node.js&#39;        }    }, 2000);    // 异步不会等待，直接会在此执行 return undefined    // 2秒后才后返回msg，但此时值早已拿到，并输出了}const msg = getMsg(); // undefined</code></pre><p>同步API和异步API的执行顺序不同：</p><p>同步API从上到下依次执行，前面代码会阻塞后面代码的执行；</p><pre><code class="js">// 同步：for (var i = 0; i &lt; 100000; i++) {    console.log(i);}console.log(&#39;for循环后面的代码&#39;);// 先执行10万次，再输出最后一句话// 异步：console.log(&#39;代码开始执行&#39;);setTimeout(() =&gt; {    console.log(&#39;2秒后执行的代码&#39;)}, 2000);setTimeout(() =&gt; {    console.log(&#39;0秒后执行的代码&#39;)}, 0);console.log(&#39;代码结束执行&#39;);// 输出顺序：// 代码开始执行// 代码结束执行// 0秒后执行的代码// 2秒后执行的代码</code></pre><h3 id="5-2-Node-js-异步API-回调函数"><a href="#5-2-Node-js-异步API-回调函数" class="headerlink" title="5.2 Node.js 异步API (回调函数)"></a>5.2 Node.js 异步API (回调函数)</h3><p>我们之前读取文件、服务器请求等都是通过回调函数来实现的；</p><p>要得到读取完成后文件的数据，在回调函数中获取；</p><pre><code class="js">fs.readFile(&#39;./demo.txt&#39;, (err, result) =&gt; {    res.end(result);});var app = http.createServer();app.on(&#39;request&#39;, (req, res) =&gt; {    res.end(req.url);});</code></pre><p><strong>回调地狱</strong></p><p>如果有多层回调函数，需要一层一层的嵌套，影响代码维护；</p><h3 id="5-3-Promise"><a href="#5-3-Promise" class="headerlink" title="5.3 Promise"></a>5.3 Promise</h3><p>Promise解决Node.js异步编程中回调地狱的问题；</p><pre><code class="js">const fs = require(&#39;fs&#39;);function p1() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./1.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}function p2() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./2.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}function p3() {    return new Promise((resolve, reject) =&gt; {        fs.readFile(&#39;./3.txt&#39;, &#39;utf8&#39;, (err, result) =&gt; {            resolve(result);        })    })}p1().then((r1) =&gt; {    console.log(r1);    return p2();}).then((result2) =&gt; {    console.log(result2);    return p3();}).then((result3) =&gt; {    console.log(result3);})</code></pre><p><img src="http://mdimg.95408.com/201912201630_672.png" alt=""></p><h2 id="6-异步函数-async"><a href="#6-异步函数-async" class="headerlink" title="6. 异步函数 async"></a>6. 异步函数 async</h2><pre><code class="js">const fn = async () =&gt; {};async function fn() {}</code></pre><p>让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p><pre><code class="js">async function fn() {    throw &#39;错误信息txt&#39;;    return 123;}// console.log(fn());   // Promise { 123 }fn().then(function(data) {    console.log(data); // 123      // return替代了resolve 用then获取}).catch(function(err) {    console.log(err); // 错误信息txt      // throw替代了reject 用catch获取})</code></pre><h3 id="6-1-async-关键字"><a href="#6-1-async-关键字" class="headerlink" title="6.1 async 关键字"></a>6.1 async 关键字</h3><ol><li>普通函数定义前加async关键字 普通函数变成异步函数</li><li>异步函数默认返回promise对象</li><li>在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法</li><li>在异步函数内部使用throw关键字抛出程序异常</li><li>调用异步函数再链式调用then方法获取异步函数执行结果</li><li>调用异步函数再链式调用catch方法获取异步函数执行的错误信息</li></ol><h3 id="6-2-await-关键字"><a href="#6-2-await-关键字" class="headerlink" title="6.2 await 关键字"></a>6.2 await 关键字</h3><ol><li>await关键字只能出现在异步函数中</li><li>await promise await后面只能写promise对象 写其他类型的API是不不可以的</li><li>await关键字可是暂停异步函数向下执行 直到promise返回结果</li></ol><pre><code class="js">async function p1() {    return &#39;1.txx&#39;;}async function p2() {    return &#39;2.txt&#39;;}async function p3() {    return &#39;3.txt&#39;;}async function run() {    let r1 = await p1(); // 直接调用p1的return的结果    let r2 = await p2();    let r3 = await p3();    console.log(r1);    console.log(r2);    console.log(r3);}run();// D:\doc\1219&gt;node 2.js// 1.txx// 2.txt// 3.txt</code></pre><h3 id="6-3-顺序读取3个文件"><a href="#6-3-顺序读取3个文件" class="headerlink" title="6.3 顺序读取3个文件"></a>6.3 顺序读取3个文件</h3><ul><li>使用async异步函数的方法按顺序读取3个文件：</li><li>const readFile = promisify(fs.readFile)   // 调用promisify方法改造了现有的异步API，让其返回promise对象；</li><li>从而支持异步函数语法；</li></ul><pre><code class="js">const fs = require(&#39;fs&#39;);// 改造现有的异步函数api，让其返回promise对象，从而支持异步函数语法const promisify = require(&#39;util&#39;).promisify;// 调用promisify方法改造了现有的异步API，让其返回promise对象const readFile = promisify(fs.readFile);async function run() {    let r1 = await readFile(&#39;./1.txt&#39;, &#39;utf8&#39;);    // 通过promisify处理的新reafFile方法，不用写回调函数，直接使用await    let r2 = await readFile(&#39;./2.txt&#39;, &#39;utf8&#39;);    let r3 = await readFile(&#39;./3.txt&#39;, &#39;utf8&#39;);    console.log(r1);    console.log(r2);    console.log(r3);}run();// D: \doc\1219 &gt; node 2.js// 1.txt内容// 2.txt内容// 3.txt内容</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（2）fs、path、gulp模块</title>
      <link href="/2019/12/02/node/Node.js%EF%BC%882%EF%BC%89fs%E3%80%81path%E3%80%81gulp%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/02/node/Node.js%EF%BC%882%EF%BC%89fs%E3%80%81path%E3%80%81gulp%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="fs-文件操作"><a href="#fs-文件操作" class="headerlink" title="fs 文件操作"></a>fs 文件操作</h2><pre><code class="js">const fs = require(&#39;fs&#39;);</code></pre><h3 id="fs-readFile-读取文件"><a href="#fs-readFile-读取文件" class="headerlink" title="fs.readFile 读取文件"></a>fs.readFile 读取文件</h3><pre><code class="js">fs.readFile(&#39;文件路径&#39;，    &#39;文件编码可选&#39;，    callback回调函数)；</code></pre><blockquote><p>callback回调函数的第一个值是错误信息，node.js中都是错误优先的回调函数；</p></blockquote><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的readFile读取文件内容fs.readFile(&#39;./a.txt&#39;, &#39;utf8&#39;, (err, doc) =&gt; {    // 如果读取错误，err包含错误信息    // 反之，err为空    // doc是读取的文件    console.log(err); // 读取正确，err返回null    console.log(doc);})</code></pre><h3 id="fs-writeFile-写入文件"><a href="#fs-writeFile-写入文件" class="headerlink" title="fs.writeFile 写入文件"></a>fs.writeFile 写入文件</h3><pre><code class="js">fs.writeFile(&#39;文件路径’， ‘数据’， callback回调函数)；</code></pre><p>如果错误，err返回错误信息；反之，err为null</p><pre><code class="js">// 调用fs模块const fs = require(&#39;fs&#39;);// 通过fs模块的writeFile写入内容fs.writeFile(&#39;./b.txt&#39;, &#39;要写入b.txt的数据&#39;, err =&gt; {    // 如果错误，err返回错误信息    // 反之，err为null    // 如果err不为空，打印err信息，return    if (err != null) {        console.log(err);        return;    }    // 如果err这空，则证明写入正确    console.log(&#39;数据写入b.txt成功&#39;);})</code></pre><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>进行路径拼接：win\os\lunix的路径符不同，使用路径拼接更安全；</p><p>node中的相对路径，是相对于node系统命令工具所在的目录</p><pre><code class="js">// 调用path模块const path = require(&#39;path&#39;);// 使用path模块进行路径拼接const p = path.join(&#39;public&#39;, &#39;halfbamoo&#39;, &#39;src&#39;);console.log(p); // public\halfbamoo\src</code></pre><p><code>__dirname</code> 为系统绝对路径；</p><pre><code class="js">const pp = path.join(__dirname, &#39;public&#39;, &#39;halfbamboo&#39;, &#39;src&#39;);console.log(pp); // D:\doc\1218\public\halfbamboo\src</code></pre><h2 id="gulp-模块"><a href="#gulp-模块" class="headerlink" title="gulp 模块"></a>gulp 模块</h2><p>基于node.js 平台的前端构建工具</p><ul><li>html、css、js文件压缩；</li><li>es6、less语法转换；</li><li>公共文件的抽离；</li><li>修改文件浏览器自动刷新；</li></ul><h3 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h3><p>安装： <code>npm install gulp</code> ，本地安装即可；</p><p>安装： <code>npm install gulp-cli -g</code> ，全局安装gulp命令行工具；</p><p>创建： <code>gulpfile.js</code> 文件写代码；</p><h3 id="gulp-方法"><a href="#gulp-方法" class="headerlink" title="gulp 方法"></a>gulp 方法</h3><ul><li>gulp.src()：获取任务要处理的文件</li><li>gulp.dest()：输出文件</li><li>gulp.task()：建立gulp任务</li><li>gulp.watch()：监控文件的变化</li></ul><p>使用gulp将src/css目录下的文件，复制到dist/css目录下：</p><blockquote><p>建立一个固定名称的文件： <code>gulpfile.js</code> ，敲如下代码，</p><p>此时，会将原/src/css中的文件，复制到/dist/css目录下，如果目标目录存在，会自动创建；</p></blockquote><pre><code class="js">gulpfile.js:    // 调用gulp模块    const gulp = require(&#39;gulp&#39;);// 使用gulp.task（任务名称，回调函数）建立任务gulp.task(&#39;first&#39;, () =&gt; {    console.log(&#39;第一个gulp任务&#39;);    // src 获取要处理的文件    gulp.src(&#39;./src/css/a.css&#39;)        // dest 输出文件地址 要放在pipei当中        .pipe(gulp.dest(&#39;./dist/css&#39;));})</code></pre><h3 id="gulp插件-第三方模块"><a href="#gulp插件-第三方模块" class="headerlink" title="gulp插件/第三方模块"></a>gulp插件/第三方模块</h3><ul><li>gulp-htmlmin ：html文件压缩</li><li>gulp-csso ：压缩css</li><li>gulp-babel ：JavaScript语法转化</li><li>gulp-less: less语法转化</li><li>gulp-uglify ：压缩混淆JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><p>安装：</p><pre><code class="js">npm install gulp - htmlminnpm install gulp - file - includenpm install gulp - lessnpm install gulp - cssonpm install gulp - babel @babel / core @babel / preset - env// https://www.npmjs.com/package/gulp-babelnpm install gulp - uglify</code></pre><ul><li>gulp-file-include：源代码中公共样式抽离出来后，使用 <code>@@include(&#39;./common/header.html&#39;)</code> 引入时，使用 gulp-file-include 模块，可以将引入的内容重新生成到一个完整的html页面当中；</li></ul><h3 id="gulpfile-js-创建任务"><a href="#gulpfile-js-创建任务" class="headerlink" title="gulpfile.js 创建任务"></a>gulpfile.js 创建任务</h3><p>压缩html、css、js，处理es6、less语法……</p><p>项目根目录下建立 <code>gulpfile.js</code> 文件；</p><p>源文件：src目录；处理后的文件：dict目录；</p><p>通过以下代码：我们可以：</p><ul><li>将所有html \ css \ js 压缩；</li><li>将 less 语法、es6 语法处理</li><li>将src目录下的所有文件 <strong>经过处理后</strong> 复制到 dist 文件夹</li></ul><pre><code class="js">// 调用gulp模块const gulp = require(&#39;gulp&#39;);// 调用处理htmlconst htmlmin = require(&#39;gulp-htmlmin&#39;);const fileinclude = require(&#39;gulp-file-include&#39;);// 调用处理css lessconst less = require(&#39;gulp-less&#39;);const csso = require(&#39;gulp-csso&#39;);// 调用处理jsconst babel = require(&#39;gulp-babel&#39;);const uglify = require(&#39;gulp-uglify&#39;);// 压缩html任务// 1 压缩html 2 抽取html公共代码gulp.task(&#39;htmlmin&#39;, () =&gt; {    gulp.src(&#39;./src/*.html&#39;)        .pipe(fileinclude())        // 压缩html代码        .pipe(htmlmin({            collapseWhitespace: true        }))        .pipe(gulp.dest(&#39;dist&#39;));})// 压缩css 及处理 lessgulp.task(&#39;cssmin&#39;, () =&gt; {    gulp.src([&#39;./src/css/*.css&#39;, &#39;./src/css/*.less&#39;])        // 处理less        .pipe(less())        // 压缩css        .pipe(csso())        .pipe(gulp.dest(&#39;dist/css&#39;));})// 处理es6 及压缩jsgulp.task(&#39;jsmin&#39;, () =&gt; {    gulp.src(&#39;./src/js/*.js&#39;)        // 处理es6语法        .pipe(babel({            // 识别当前运行环境，将代码按当前环境转换            presets: [&#39;@babel/env&#39;]        }))        // 压缩js代码        .pipe(uglify())        .pipe(gulp.dest(&#39;dist/js&#39;));})// 复制其他不需要处理的夹 img / libgulp.task(&#39;copy&#39;, () =&gt; {    gulp.src(&#39;./src/images/*&#39;)        .pipe(gulp.dest(&#39;dist/images&#39;));    gulp.src(&#39;./src/lib/**/*&#39;)        .pipe(gulp.dest(&#39;dist/lib&#39;));})// 构建任务// gulp.task(&#39;default&#39;, [&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;]);gulp.task(&#39;default&#39;, gulp.parallel(&#39;htmlmin&#39;, &#39;cssmin&#39;, &#39;jsmin&#39;, &#39;copy&#39;, function() {    console.log(&#39;任务完成&#39;);}));// 任务命令：// gulp default 或者 gulp</code></pre><h3 id="gulp3-和-gulp4的区别"><a href="#gulp3-和-gulp4的区别" class="headerlink" title="gulp3 和 gulp4的区别"></a>gulp3 和 gulp4的区别</h3><blockquote><p>操作时报错：gulp Task function must be specified。</p><p>gulp 版本的原因！</p></blockquote><p>在Gulp 4中需要使用 <code>gulp.series</code> 和 <code>gulp.parallel</code> ，因为gulp任务现在只有两个参数。</p><blockquote><p><code>gulp.series</code> ：按照顺序执行<br><code>gulp.paralle</code> ：可以并行计算</p></blockquote><pre><code class="js">gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, function() {    // Do something after a, b, and c are finished.}));gulp.task(&#39;build&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;, function() {    // Build the website.}));gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;), &#39;b&#39;, &#39;c&#39;, function() {    // Do something after a, b, and c are finished.}));</code></pre><h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><h3 id="当模块拥有路径但没有后缀时"><a href="#当模块拥有路径但没有后缀时" class="headerlink" title="当模块拥有路径但没有后缀时"></a>当模块拥有路径但没有后缀时</h3><pre><code class="js">require(&#39;./find.js&#39;);require(&#39;./find&#39;);</code></pre><ol><li>require方法根据模块路径查找模块，如果是完整路径，直接引入模块。</li><li>如果模块后缀省略，<strong>先找同名JS文件再找同名JS文件夹</strong></li><li>如果找到了同名文件夹，找文件夹中的index.js</li><li>如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件</li><li>如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li></ol><h3 id="当模块没有路径且没有后缀时"><a href="#当模块没有路径且没有后缀时" class="headerlink" title="当模块没有路径且没有后缀时"></a>当模块没有路径且没有后缀时</h3><pre><code class="js">require(&#39;find&#39;);</code></pre><ol><li>Node.js会假设它是<strong>系统模块</strong></li><li>Node.js会去node_modules文件夹中</li><li>首先看是否有该名字的JS文件</li><li>再看是否有该名字的文件夹</li><li>如果是文件夹看里面是否有index.js</li><li>如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件</li><li>否则找不到报错</li></ol><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js（1）基础</title>
      <link href="/2019/12/01/node/Node.js%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/12/01/node/Node.js%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><img src="http://mdimg.95408.com/201912182243_175.png" alt="Node.js"></p><h2 id="常用信息"><a href="#常用信息" class="headerlink" title="常用信息"></a>常用信息</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a></p><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm 官网</a></p><p>win系统中，需要将node.js放入系统环境变量；</p><p>如果不能安装成功，需要以管理员身份运行命令行工具；</p><p>查看 Node.js 版本： <code>node -v</code> ；</p><p>nodejs已经集成了 <code>npm</code> ，查看 npm 版本： <code>npm -v</code> ；</p><h2 id="Node-js-与JavaScript"><a href="#Node-js-与JavaScript" class="headerlink" title="Node.js 与JavaScript"></a>Node.js 与JavaScript</h2><ul><li><strong>Node</strong> 是一个基于 Chrome V8 引擎的 JavaScript <strong>代码运行环境</strong>；</li><li>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境；</li><li>Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境；</li><li>JavaScript 由三部分组成，<strong>ECMAScript</strong>，<strong>DOM</strong>，<strong>BOM</strong> ；</li><li>Node.js是由<strong>ECMAScript</strong>及<strong>Node 环境</strong>提供的一些<strong>附加API</strong>组成的，包括文件、网络、路径等等一些更加强大的 API ；</li><li>浏览器全局对象是 <code>window</code> ，Node.js 全局对象是 <code>global</code> 。</li></ul><p><img src="http://mdimg.95408.com/201912182202_431.png" alt="Node.js与JavaScript"></p><h2 id="Node-js-模块化"><a href="#Node-js-模块化" class="headerlink" title="Node.js 模块化"></a>Node.js 模块化</h2><ul><li>Node.js规定一个 <code>JavaScript</code> 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到；</li><li>模块内部使用 <code>exports</code> 导出对象，在其他模块（文件）中使用 <code>require</code> 导入其他模块；</li></ul><pre><code class="js">a.js文件const add = (n1, n2) =&gt; n1 + n2; // 一个加法的函数exports.add = add; // 将函数导出b.js文件const a = require(&#39;./a.js&#39;); // 导入a.js中的加法函数console.log(a.add(1, 2)) // 使用加法函数得到3</code></pre><h2 id="npm-工具"><a href="#npm-工具" class="headerlink" title="npm 工具"></a>npm 工具</h2><p>npmjs.com 第三方模块管理工具 （node package manager）</p><h3 id="安装模块："><a href="#安装模块：" class="headerlink" title="安装模块："></a>安装模块：</h3><pre><code class="js">本地安装：npm install 模块名称全局安装：npm install 模块名称 - g</code></pre><blockquote><ul><li><strong>本地安装</strong>的第三方模块，只存储在当前项目文件夹 <code>node_modules</code> ，只有本项目能使用，其他项目使用相同模块，需要在其他项目下再次安装；</li><li>命令行工具使用<strong>全局安装</strong>，在其他项目都可以使用；</li></ul></blockquote><h3 id="卸载模块："><a href="#卸载模块：" class="headerlink" title="卸载模块："></a>卸载模块：</h3><pre><code class="js">npm uninstall 模块名</code></pre><h2 id="nodemon-模块"><a href="#nodemon-模块" class="headerlink" title="nodemon 模块"></a>nodemon 模块</h2><p>是一个命令行工具，全局安装： <code>npm install nodemon -g</code> ；</p><p>辅助替换node命令，项目更改时，能自动刷新；</p><h2 id="nrm-替换国内镜像源"><a href="#nrm-替换国内镜像源" class="headerlink" title="nrm 替换国内镜像源"></a>nrm 替换国内镜像源</h2><p>nrm 安装： <code>npm install nrm -g</code> ；</p><p>查询下载地址列表： <code>nrm ls</code> ；</p><p>选择国内taobao下载源，加快下载速度： <code>nrm use taobao</code> ；</p><p><img src="http://mdimg.95408.com/201912182305_359.png?null" alt=""></p><h2 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h2><p>node_modules 文件夹中包含了项目中所有的第三方模块，数百个，多而碎；</p><p>依赖关系复杂，不同版本的兼容问题；</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。</p><p>使用 <code>npm init -y</code> 命令生成。</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><p>开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖；</p><p>正常使用 <code>npm install 包名</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;dependencies&quot;: {        &quot;jquery&quot;: &quot;^3.3.1“    }}</code></pre><h3 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h3><p>开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖；</p><p>命令行加 –save -dev 安装： <code>npm install 包名 --save -dev</code> 安装；</p><pre><code class="js">package.json文件 {    &quot;devDependencies&quot;: {        &quot;gulp&quot;: &quot;^3.9.1“    }}</code></pre><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>当我们将项目移到其他电脑，由于有了 <code>package.json</code> 和 <code>package-lock.json</code> 文件，不需要拷贝 <code>node_modules</code> 文件夹；</p><p>只需运行 <code>npm install</code> 即可通过这两个文件，自行下载所需的所有第三方模块。</p></blockquote><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
